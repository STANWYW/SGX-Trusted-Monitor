target-ppc/helper_regs.h:    tmp = env->gpr[0];
target-ppc/helper_regs.h:    env->gpr[0] = env->tgpr[0];
target-ppc/helper_regs.h:    env->tgpr[0] = tmp;
target-ppc/helper_regs.h:    tmp = env->gpr[1];
target-ppc/helper_regs.h:    env->gpr[1] = env->tgpr[1];
target-ppc/helper_regs.h:    env->tgpr[1] = tmp;
target-ppc/helper_regs.h:    tmp = env->gpr[2];
target-ppc/helper_regs.h:    env->gpr[2] = env->tgpr[2];
target-ppc/helper_regs.h:    env->tgpr[2] = tmp;
target-ppc/helper_regs.h:    tmp = env->gpr[3];
target-ppc/helper_regs.h:    env->gpr[3] = env->tgpr[3];
target-ppc/helper_regs.h:    env->tgpr[3] = tmp;
target-ppc/helper_regs.h:        env->mmu_idx = 2;
target-ppc/helper_regs.h:        env->mmu_idx = 1 - msr_pr;
target-ppc/helper_regs.h:    env->hflags = env->msr & hflags_mask;
target-ppc/helper_regs.h:    env->hflags |= env->hflags_nmsr;
target-ppc/helper_regs.h:    value &= env->msr_mask;
target-ppc/helper_regs.h:        value |= env->msr & MSR_HVB;
target-ppc/helper_regs.h:    if (unlikely((env->flags & POWERPC_FLAG_TGPR) &&
target-ppc/helper_regs.h:                 ((value ^ env->msr) & (1 << MSR_TGPR)))) {
target-ppc/helper_regs.h:        env->excp_prefix = ((value >> MSR_EP) & 1) * 0xFFF00000;
target-ppc/helper_regs.h:    env->msr = value;
target-ppc/helper_regs.h:        if (!env->pending_interrupts && (*env->check_pow)(env)) {
target-ppc/gdbstub.c:        gdb_get_regl(mem_buf, env->gpr[n]);
target-ppc/gdbstub.c:        stfq_p(mem_buf, env->fpr[n-32]);
target-ppc/gdbstub.c:            gdb_get_regl(mem_buf, env->nip);
target-ppc/gdbstub.c:            gdb_get_regl(mem_buf, env->msr);
target-ppc/gdbstub.c:                    cr |= env->crf[i] << (32 - ((i + 1) * 4));
target-ppc/gdbstub.c:            gdb_get_regl(mem_buf, env->lr);
target-ppc/gdbstub.c:            gdb_get_regl(mem_buf, env->ctr);
target-ppc/gdbstub.c:            gdb_get_regl(mem_buf, env->xer);
target-ppc/gdbstub.c:            gdb_get_reg32(mem_buf, env->fpscr);
target-ppc/gdbstub.c:        gdb_get_reg64(mem_buf, env->gpr[n]);
target-ppc/gdbstub.c:        stfq_p(mem_buf, env->fpr[n-32]);
target-ppc/gdbstub.c:            gdb_get_reg64(mem_buf, env->nip);
target-ppc/gdbstub.c:            gdb_get_reg64(mem_buf, env->msr);
target-ppc/gdbstub.c:                    cr |= env->crf[i] << (32 - ((i + 1) * 4));
target-ppc/gdbstub.c:            gdb_get_reg64(mem_buf, env->lr);
target-ppc/gdbstub.c:            gdb_get_reg64(mem_buf, env->ctr);
target-ppc/gdbstub.c:            gdb_get_reg64(mem_buf, env->xer);
target-ppc/gdbstub.c:            gdb_get_reg64(mem_buf, env->fpscr);
target-ppc/gdbstub.c:        env->gpr[n] = ldtul_p(mem_buf);
target-ppc/gdbstub.c:        env->fpr[n-32] = ldfq_p(mem_buf);
target-ppc/gdbstub.c:            env->nip = ldtul_p(mem_buf);
target-ppc/gdbstub.c:                    env->crf[i] = (cr >> (32 - ((i + 1) * 4))) & 0xF;
target-ppc/gdbstub.c:            env->lr = ldtul_p(mem_buf);
target-ppc/gdbstub.c:            env->ctr = ldtul_p(mem_buf);
target-ppc/gdbstub.c:            env->xer = ldtul_p(mem_buf);
target-ppc/gdbstub.c:        env->gpr[n] = ldq_p(mem_buf);
target-ppc/gdbstub.c:        env->fpr[n-32] = ldfq_p(mem_buf);
target-ppc/gdbstub.c:            env->nip = ldq_p(mem_buf);
target-ppc/gdbstub.c:                    env->crf[i] = (cr >> (32 - ((i + 1) * 4))) & 0xF;
target-ppc/gdbstub.c:            env->lr = ldq_p(mem_buf);
target-ppc/gdbstub.c:            env->ctr = ldq_p(mem_buf);
target-ppc/gdbstub.c:            env->xer = ldq_p(mem_buf);
target-ppc/mmu-hash32.h:    assert(!env->external_htab); /* Not supported on 32-bit for now */
target-ppc/mmu-hash32.h:    return ldl_phys(cs->as, env->htab_base + pte_offset);
target-ppc/mmu-hash32.h:    assert(!env->external_htab); /* Not supported on 32-bit for now */
target-ppc/mmu-hash32.h:    return ldl_phys(cs->as, env->htab_base + pte_offset + HASH_PTE_SIZE_32/2);
target-ppc/mmu-hash32.h:    assert(!env->external_htab); /* Not supported on 32-bit for now */
target-ppc/mmu-hash32.h:    stl_phys(cs->as, env->htab_base + pte_offset, pte0);
target-ppc/mmu-hash32.h:    assert(!env->external_htab); /* Not supported on 32-bit for now */
target-ppc/mmu-hash32.h:    stl_phys(cs->as, env->htab_base + pte_offset + HASH_PTE_SIZE_32/2, pte1);
target-ppc/dfp_helper.c:    dfp_prepare_rounding_mode(&dfp->context, env->fpscr);
target-ppc/dfp_helper.c:    dfp_prepare_rounding_mode(&dfp->context, env->fpscr);
target-ppc/dfp_helper.c:    dfp->env->fpscr |= (flag | FP_FX);
target-ppc/dfp_helper.c:    if (dfp->env->fpscr & enabled) {
target-ppc/dfp_helper.c:        dfp->env->fpscr |= FP_FEX;
target-ppc/dfp_helper.c:    dfp->env->fpscr &= ~(0x1F << 12);
target-ppc/dfp_helper.c:    dfp->env->fpscr |= (fprf << 12);
target-ppc/dfp_helper.c:    dfp->env->fpscr &= ~(0xF << 12);
target-ppc/dfp_helper.c:    dfp->env->fpscr |= (dfp->crbf << 12);
target-ppc/mem_helper.c:    if (!msr_is_64bit(env, env->msr)) {
target-ppc/mem_helper.c:            env->gpr[reg] = bswap32(cpu_ldl_data(env, addr));
target-ppc/mem_helper.c:            env->gpr[reg] = cpu_ldl_data(env, addr);
target-ppc/mem_helper.c:            cpu_stl_data(env, addr, bswap32((uint32_t)env->gpr[reg]));
target-ppc/mem_helper.c:            cpu_stl_data(env, addr, (uint32_t)env->gpr[reg]);
target-ppc/mem_helper.c:        env->gpr[reg] = cpu_ldl_data(env, addr);
target-ppc/mem_helper.c:        env->gpr[reg] = 0;
target-ppc/mem_helper.c:            env->gpr[reg] |= cpu_ldub_data(env, addr) << sh;
target-ppc/mem_helper.c:        cpu_stl_data(env, addr, env->gpr[reg]);
target-ppc/mem_helper.c:            cpu_stb_data(env, addr, (env->gpr[reg] >> sh) & 0xFF);
target-ppc/mem_helper.c:    if (env->reserve_addr == addr) {
target-ppc/mem_helper.c:        env->reserve_addr = (target_ulong)-1ULL;
target-ppc/mem_helper.c:    int dcbz_size = env->dcache_line_size;
target-ppc/mem_helper.c:        (env->excp_model == POWERPC_EXCP_970) &&
target-ppc/mem_helper.c:        ((env->spr[SPR_970_HID5] >> 7) & 0x3) == 1) {
target-ppc/mem_helper.c:    addr &= ~(env->dcache_line_size - 1);
target-ppc/mem_helper.c:            env->gpr[reg] = (env->gpr[reg] & ~(0xFF << d)) | (c << d);
target-ppc/translate.c:                env->nip, env->lr, env->ctr, cpu_read_xer(env));
target-ppc/translate.c:                TARGET_FMT_lx " idx %d\n", env->msr, env->spr[SPR_HID0],
target-ppc/translate.c:                env->hflags, env->mmu_idx);
target-ppc/translate.c:        cpu_fprintf(f, "%01x", env->crf[i]);
target-ppc/translate.c:        if (env->crf[i] & 0x08)
target-ppc/translate.c:        else if (env->crf[i] & 0x04)
target-ppc/translate.c:        else if (env->crf[i] & 0x02)
target-ppc/translate.c:        cpu_fprintf(f, " %c%c", a, env->crf[i] & 0x01 ? 'O' : ' ');
target-ppc/translate.c:                env->reserve_addr);
target-ppc/translate.c:        cpu_fprintf(f, " %016" PRIx64, *((uint64_t *)&env->fpr[i]));
target-ppc/translate.c:    cpu_fprintf(f, "FPSCR " TARGET_FMT_lx "\n", env->fpscr);
target-ppc/translate.c:                env->spr[SPR_SRR0], env->spr[SPR_SRR1],
target-ppc/translate.c:                env->spr[SPR_PVR], env->spr[SPR_VRSAVE]);
target-ppc/translate.c:                env->spr[SPR_SPRG0], env->spr[SPR_SPRG1],
target-ppc/translate.c:                env->spr[SPR_SPRG2], env->spr[SPR_SPRG3]);
target-ppc/translate.c:                env->spr[SPR_SPRG4], env->spr[SPR_SPRG5],
target-ppc/translate.c:                env->spr[SPR_SPRG6], env->spr[SPR_SPRG7]);
target-ppc/translate.c:    if (env->excp_model == POWERPC_EXCP_BOOKE) {
target-ppc/translate.c:                    env->spr[SPR_BOOKE_CSRR0], env->spr[SPR_BOOKE_CSRR1],
target-ppc/translate.c:                    env->spr[SPR_BOOKE_MCSRR0], env->spr[SPR_BOOKE_MCSRR1]);
target-ppc/translate.c:                    env->spr[SPR_BOOKE_TCR], env->spr[SPR_BOOKE_TSR],
target-ppc/translate.c:                    env->spr[SPR_BOOKE_ESR], env->spr[SPR_BOOKE_DEAR]);
target-ppc/translate.c:                    env->spr[SPR_BOOKE_PIR], env->spr[SPR_BOOKE_DECAR],
target-ppc/translate.c:                    env->spr[SPR_BOOKE_IVPR], env->spr[SPR_BOOKE_EPCR]);
target-ppc/translate.c:                    env->spr[SPR_BOOKE_MCSR], env->spr[SPR_BOOKE_SPRG8],
target-ppc/translate.c:                    env->spr[SPR_BOOKE_EPR]);
target-ppc/translate.c:                    env->spr[SPR_Exxx_MCAR], env->spr[SPR_BOOKE_PID1],
target-ppc/translate.c:                    env->spr[SPR_BOOKE_PID2], env->spr[SPR_E500_SVR]);
target-ppc/translate.c:    if (env->flags & POWERPC_FLAG_CFAR) {
target-ppc/translate.c:        cpu_fprintf(f, " CFAR " TARGET_FMT_lx"\n", env->cfar);
target-ppc/translate.c:    switch (env->mmu_model) {
target-ppc/translate.c:                       "  DSISR " TARGET_FMT_lx "\n", env->spr[SPR_SDR1],
target-ppc/translate.c:                    env->spr[SPR_DAR], env->spr[SPR_DSISR]);
target-ppc/translate.c:                    env->spr[SPR_BOOKE_MAS0], env->spr[SPR_BOOKE_MAS1],
target-ppc/translate.c:                    env->spr[SPR_BOOKE_MAS2], env->spr[SPR_BOOKE_MAS3]);
target-ppc/translate.c:                    env->spr[SPR_BOOKE_MAS4], env->spr[SPR_BOOKE_MAS6],
target-ppc/translate.c:                    env->spr[SPR_BOOKE_MAS7], env->spr[SPR_BOOKE_PID]);
target-ppc/translate.c:                    env->spr[SPR_MMUCFG], env->spr[SPR_BOOKE_TLB0CFG],
target-ppc/translate.c:                    env->spr[SPR_BOOKE_TLB1CFG]);
target-ppc/translate.c:    ctx.spr_cb = env->spr_cb;
target-ppc/translate.c:    ctx.mem_idx = env->mmu_idx;
target-ppc/translate.c:    ctx.insns_flags = env->insns_flags;
target-ppc/translate.c:    ctx.insns_flags2 = env->insns_flags2;
target-ppc/translate.c:    ctx.le_mode = env->hflags & (1 << MSR_LE) ? 1 : 0;
target-ppc/translate.c:    ctx.sf_mode = msr_is_64bit(env, env->msr);
target-ppc/translate.c:    ctx.has_cfar = !!(env->flags & POWERPC_FLAG_CFAR);
target-ppc/translate.c:    if ((env->flags & POWERPC_FLAG_SPE) && msr_spe)
target-ppc/translate.c:    if ((env->flags & POWERPC_FLAG_VRE) && msr_vr)
target-ppc/translate.c:    if ((env->flags & POWERPC_FLAG_VSX) && msr_vsx) {
target-ppc/translate.c:    if ((env->flags & POWERPC_FLAG_SE) && msr_se)
target-ppc/translate.c:    if ((env->flags & POWERPC_FLAG_BE) && msr_be)
target-ppc/translate.c:        table = env->opcodes;
target-ppc/translate.c:        flags = env->bfd_mach;
target-ppc/translate.c:    env->nip = tcg_ctx.gen_opc_pc[pc_pos];
target-ppc/kvm.c:    if (cenv->excp_model == POWERPC_EXCP_BOOKE) {
target-ppc/kvm.c:    sregs.pvr = cenv->spr[SPR_PVR];
target-ppc/kvm.c:    assert(entries == env->nb_tlb);
target-ppc/kvm.c:    env->tlb_dirty = true;
target-ppc/kvm.c:    cfg.array = (uintptr_t)env->tlb.tlbm;
target-ppc/kvm.c:    env->kvm_sw_tlb = true;
target-ppc/kvm.c:        if (env->mmu_model & POWERPC_MMU_1TSEG) {
target-ppc/kvm.c:        if (env->mmu_model == POWERPC_MMU_2_06) {
target-ppc/kvm.c:        if (env->mmu_model == POWERPC_MMU_2_06) {
target-ppc/kvm.c:    if (!(env->mmu_model & POWERPC_MMU_64)) {
target-ppc/kvm.c:    memset(&env->sps, 0, sizeof(env->sps));
target-ppc/kvm.c:        struct ppc_one_seg_page_size *qsps = &env->sps.sps[iq];
target-ppc/kvm.c:    env->slb_nr = smmu_info.slb_size;
target-ppc/kvm.c:        env->mmu_model &= ~POWERPC_MMU_1TSEG;
target-ppc/kvm.c:    switch (cenv->mmu_model) {
target-ppc/kvm.c:    if (!env->kvm_sw_tlb) {
target-ppc/kvm.c:    bitmap = g_malloc((env->nb_tlb + 7) / 8);
target-ppc/kvm.c:    memset(bitmap, 0xFF, (env->nb_tlb + 7) / 8);
target-ppc/kvm.c:    dirty_tlb.num_dirty = env->nb_tlb;
target-ppc/kvm.c:            env->spr[spr] = val.u32;
target-ppc/kvm.c:            env->spr[spr] = val.u64;
target-ppc/kvm.c:        val.u32 = env->spr[spr];
target-ppc/kvm.c:        val.u64 = env->spr[spr];
target-ppc/kvm.c:    if (env->insns_flags & PPC_FLOAT) {
target-ppc/kvm.c:        uint64_t fpscr = env->fpscr;
target-ppc/kvm.c:        bool vsx = !!(env->insns_flags2 & PPC2_VSX);
target-ppc/kvm.c:            vsr[0] = float64_val(env->fpr[i]);
target-ppc/kvm.c:            vsr[1] = env->vsr[i];
target-ppc/kvm.c:    if (env->insns_flags & PPC_ALTIVEC) {
target-ppc/kvm.c:        reg.addr = (uintptr_t)&env->vscr;
target-ppc/kvm.c:            reg.addr = (uintptr_t)&env->avr[i];
target-ppc/kvm.c:    if (env->insns_flags & PPC_FLOAT) {
target-ppc/kvm.c:        bool vsx = !!(env->insns_flags2 & PPC2_VSX);
target-ppc/kvm.c:            env->fpscr = fpscr;
target-ppc/kvm.c:                env->fpr[i] = vsr[0];
target-ppc/kvm.c:                    env->vsr[i] = vsr[1];
target-ppc/kvm.c:    if (env->insns_flags & PPC_ALTIVEC) {
target-ppc/kvm.c:        reg.addr = (uintptr_t)&env->vscr;
target-ppc/kvm.c:            reg.addr = (uintptr_t)&env->avr[i];
target-ppc/kvm.c:    reg.addr = (uintptr_t)&env->vpa_addr;
target-ppc/kvm.c:    assert((uintptr_t)&env->slb_shadow_size
target-ppc/kvm.c:           == ((uintptr_t)&env->slb_shadow_addr + 8));
target-ppc/kvm.c:    reg.addr = (uintptr_t)&env->slb_shadow_addr;
target-ppc/kvm.c:    assert((uintptr_t)&env->dtl_size == ((uintptr_t)&env->dtl_addr + 8));
target-ppc/kvm.c:    reg.addr = (uintptr_t)&env->dtl_addr;
target-ppc/kvm.c:    assert(env->vpa_addr || !(env->slb_shadow_addr || env->dtl_addr));
target-ppc/kvm.c:    if (env->vpa_addr) {
target-ppc/kvm.c:        reg.addr = (uintptr_t)&env->vpa_addr;
target-ppc/kvm.c:    assert((uintptr_t)&env->slb_shadow_size
target-ppc/kvm.c:           == ((uintptr_t)&env->slb_shadow_addr + 8));
target-ppc/kvm.c:    reg.addr = (uintptr_t)&env->slb_shadow_addr;
target-ppc/kvm.c:    assert((uintptr_t)&env->dtl_size == ((uintptr_t)&env->dtl_addr + 8));
target-ppc/kvm.c:    reg.addr = (uintptr_t)&env->dtl_addr;
target-ppc/kvm.c:    if (!env->vpa_addr) {
target-ppc/kvm.c:        reg.addr = (uintptr_t)&env->vpa_addr;
target-ppc/kvm.c:    regs.ctr = env->ctr;
target-ppc/kvm.c:    regs.lr  = env->lr;
target-ppc/kvm.c:    regs.msr = env->msr;
target-ppc/kvm.c:    regs.pc = env->nip;
target-ppc/kvm.c:    regs.srr0 = env->spr[SPR_SRR0];
target-ppc/kvm.c:    regs.srr1 = env->spr[SPR_SRR1];
target-ppc/kvm.c:    regs.sprg0 = env->spr[SPR_SPRG0];
target-ppc/kvm.c:    regs.sprg1 = env->spr[SPR_SPRG1];
target-ppc/kvm.c:    regs.sprg2 = env->spr[SPR_SPRG2];
target-ppc/kvm.c:    regs.sprg3 = env->spr[SPR_SPRG3];
target-ppc/kvm.c:    regs.sprg4 = env->spr[SPR_SPRG4];
target-ppc/kvm.c:    regs.sprg5 = env->spr[SPR_SPRG5];
target-ppc/kvm.c:    regs.sprg6 = env->spr[SPR_SPRG6];
target-ppc/kvm.c:    regs.sprg7 = env->spr[SPR_SPRG7];
target-ppc/kvm.c:    regs.pid = env->spr[SPR_BOOKE_PID];
target-ppc/kvm.c:        regs.gpr[i] = env->gpr[i];
target-ppc/kvm.c:        regs.cr |= (env->crf[i] & 15) << (4 * (7 - i));
target-ppc/kvm.c:    if (env->tlb_dirty) {
target-ppc/kvm.c:        env->tlb_dirty = false;
target-ppc/kvm.c:        sregs.pvr = env->spr[SPR_PVR];
target-ppc/kvm.c:        sregs.u.s.sdr1 = env->spr[SPR_SDR1];
target-ppc/kvm.c:        for (i = 0; i < ARRAY_SIZE(env->slb); i++) {
target-ppc/kvm.c:            sregs.u.s.ppc64.slb[i].slbe = env->slb[i].esid;
target-ppc/kvm.c:            if (env->slb[i].esid & SLB_ESID_V) {
target-ppc/kvm.c:            sregs.u.s.ppc64.slb[i].slbv = env->slb[i].vsid;
target-ppc/kvm.c:            sregs.u.s.ppc32.sr[i] = env->sr[i];
target-ppc/kvm.c:            sregs.u.s.ppc32.dbat[i] = ((uint64_t)env->DBAT[0][i] << 32)
target-ppc/kvm.c:                | env->DBAT[1][i];
target-ppc/kvm.c:            sregs.u.s.ppc32.ibat[i] = ((uint64_t)env->IBAT[0][i] << 32)
target-ppc/kvm.c:                | env->IBAT[1][i];
target-ppc/kvm.c:            uint64_t id = env->spr_cb[i].one_reg_id;
target-ppc/kvm.c:            for (i = 0; i < ARRAY_SIZE(env->tm_gpr); i++) {
target-ppc/kvm.c:                kvm_set_one_reg(cs, KVM_REG_PPC_TM_GPR(i), &env->tm_gpr[i]);
target-ppc/kvm.c:            for (i = 0; i < ARRAY_SIZE(env->tm_vsr); i++) {
target-ppc/kvm.c:                kvm_set_one_reg(cs, KVM_REG_PPC_TM_VSR(i), &env->tm_vsr[i]);
target-ppc/kvm.c:            kvm_set_one_reg(cs, KVM_REG_PPC_TM_CR, &env->tm_cr);
target-ppc/kvm.c:            kvm_set_one_reg(cs, KVM_REG_PPC_TM_LR, &env->tm_lr);
target-ppc/kvm.c:            kvm_set_one_reg(cs, KVM_REG_PPC_TM_CTR, &env->tm_ctr);
target-ppc/kvm.c:            kvm_set_one_reg(cs, KVM_REG_PPC_TM_FPSCR, &env->tm_fpscr);
target-ppc/kvm.c:            kvm_set_one_reg(cs, KVM_REG_PPC_TM_AMR, &env->tm_amr);
target-ppc/kvm.c:            kvm_set_one_reg(cs, KVM_REG_PPC_TM_PPR, &env->tm_ppr);
target-ppc/kvm.c:            kvm_set_one_reg(cs, KVM_REG_PPC_TM_VRSAVE, &env->tm_vrsave);
target-ppc/kvm.c:            kvm_set_one_reg(cs, KVM_REG_PPC_TM_VSCR, &env->tm_vscr);
target-ppc/kvm.c:            kvm_set_one_reg(cs, KVM_REG_PPC_TM_DSCR, &env->tm_dscr);
target-ppc/kvm.c:            kvm_set_one_reg(cs, KVM_REG_PPC_TM_TAR, &env->tm_tar);
target-ppc/kvm.c:        kvm_set_one_reg(cs, KVM_REG_PPC_TB_OFFSET, &env->tb_env->tb_offset);
target-ppc/kvm.c:        env->crf[i] = cr & 15;
target-ppc/kvm.c:    env->ctr = regs.ctr;
target-ppc/kvm.c:    env->lr = regs.lr;
target-ppc/kvm.c:    env->msr = regs.msr;
target-ppc/kvm.c:    env->nip = regs.pc;
target-ppc/kvm.c:    env->spr[SPR_SRR0] = regs.srr0;
target-ppc/kvm.c:    env->spr[SPR_SRR1] = regs.srr1;
target-ppc/kvm.c:    env->spr[SPR_SPRG0] = regs.sprg0;
target-ppc/kvm.c:    env->spr[SPR_SPRG1] = regs.sprg1;
target-ppc/kvm.c:    env->spr[SPR_SPRG2] = regs.sprg2;
target-ppc/kvm.c:    env->spr[SPR_SPRG3] = regs.sprg3;
target-ppc/kvm.c:    env->spr[SPR_SPRG4] = regs.sprg4;
target-ppc/kvm.c:    env->spr[SPR_SPRG5] = regs.sprg5;
target-ppc/kvm.c:    env->spr[SPR_SPRG6] = regs.sprg6;
target-ppc/kvm.c:    env->spr[SPR_SPRG7] = regs.sprg7;
target-ppc/kvm.c:    env->spr[SPR_BOOKE_PID] = regs.pid;
target-ppc/kvm.c:        env->gpr[i] = regs.gpr[i];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_CSRR0] = sregs.u.e.csrr0;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_CSRR1] = sregs.u.e.csrr1;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_ESR] = sregs.u.e.esr;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_DEAR] = sregs.u.e.dear;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_MCSR] = sregs.u.e.mcsr;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_TSR] = sregs.u.e.tsr;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_TCR] = sregs.u.e.tcr;
target-ppc/kvm.c:            env->spr[SPR_DECR] = sregs.u.e.dec;
target-ppc/kvm.c:            env->spr[SPR_TBL] = sregs.u.e.tb & 0xffffffff;
target-ppc/kvm.c:            env->spr[SPR_TBU] = sregs.u.e.tb >> 32;
target-ppc/kvm.c:            env->spr[SPR_VRSAVE] = sregs.u.e.vrsave;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_PIR] = sregs.u.e.pir;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_MCSRR0] = sregs.u.e.mcsrr0;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_MCSRR1] = sregs.u.e.mcsrr1;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_DECAR] = sregs.u.e.decar;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVPR] = sregs.u.e.ivpr;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_EPCR] = sregs.u.e.epcr;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_SPRG8] = sregs.u.e.sprg8;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR0] = sregs.u.e.ivor_low[0];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR1] = sregs.u.e.ivor_low[1];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR2] = sregs.u.e.ivor_low[2];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR3] = sregs.u.e.ivor_low[3];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR4] = sregs.u.e.ivor_low[4];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR5] = sregs.u.e.ivor_low[5];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR6] = sregs.u.e.ivor_low[6];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR7] = sregs.u.e.ivor_low[7];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR8] = sregs.u.e.ivor_low[8];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR9] = sregs.u.e.ivor_low[9];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR10] = sregs.u.e.ivor_low[10];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR11] = sregs.u.e.ivor_low[11];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR12] = sregs.u.e.ivor_low[12];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR13] = sregs.u.e.ivor_low[13];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR14] = sregs.u.e.ivor_low[14];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR15] = sregs.u.e.ivor_low[15];
target-ppc/kvm.c:                env->spr[SPR_BOOKE_IVOR32] = sregs.u.e.ivor_high[0];
target-ppc/kvm.c:                env->spr[SPR_BOOKE_IVOR33] = sregs.u.e.ivor_high[1];
target-ppc/kvm.c:                env->spr[SPR_BOOKE_IVOR34] = sregs.u.e.ivor_high[2];
target-ppc/kvm.c:                env->spr[SPR_BOOKE_IVOR35] = sregs.u.e.ivor_high[3];
target-ppc/kvm.c:                env->spr[SPR_BOOKE_IVOR36] = sregs.u.e.ivor_high[4];
target-ppc/kvm.c:                env->spr[SPR_BOOKE_IVOR37] = sregs.u.e.ivor_high[5];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_MAS0] = sregs.u.e.mas0;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_MAS1] = sregs.u.e.mas1;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_MAS2] = sregs.u.e.mas2;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_MAS3] = sregs.u.e.mas7_3 & 0xffffffff;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_MAS4] = sregs.u.e.mas4;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_MAS6] = sregs.u.e.mas6;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_MAS7] = sregs.u.e.mas7_3 >> 32;
target-ppc/kvm.c:            env->spr[SPR_MMUCFG] = sregs.u.e.mmucfg;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_TLB0CFG] = sregs.u.e.tlbcfg[0];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_TLB1CFG] = sregs.u.e.tlbcfg[1];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_EPR] = sregs.u.e.epr;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_EPLC] = sregs.u.e.eplc;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_EPSC] = sregs.u.e.epsc;
target-ppc/kvm.c:            env->spr[SPR_E500_SVR] = sregs.u.e.impl.fsl.svr;
target-ppc/kvm.c:            env->spr[SPR_Exxx_MCAR] = sregs.u.e.impl.fsl.mcar;
target-ppc/kvm.c:            env->spr[SPR_HID0] = sregs.u.e.impl.fsl.hid0;
target-ppc/kvm.c:                env->spr[SPR_BOOKE_PID1] = sregs.u.e.impl.fsl.pid1;
target-ppc/kvm.c:                env->spr[SPR_BOOKE_PID2] = sregs.u.e.impl.fsl.pid2;
target-ppc/kvm.c:        if (!env->external_htab) {
target-ppc/kvm.c:        memset(env->slb, 0, sizeof(env->slb));
target-ppc/kvm.c:        for (i = 0; i < ARRAY_SIZE(env->slb); i++) {
target-ppc/kvm.c:            env->sr[i] = sregs.u.s.ppc32.sr[i];
target-ppc/kvm.c:            env->DBAT[0][i] = sregs.u.s.ppc32.dbat[i] & 0xffffffff;
target-ppc/kvm.c:            env->DBAT[1][i] = sregs.u.s.ppc32.dbat[i] >> 32;
target-ppc/kvm.c:            env->IBAT[0][i] = sregs.u.s.ppc32.ibat[i] & 0xffffffff;
target-ppc/kvm.c:            env->IBAT[1][i] = sregs.u.s.ppc32.ibat[i] >> 32;
target-ppc/kvm.c:            uint64_t id = env->spr_cb[i].one_reg_id;
target-ppc/kvm.c:            for (i = 0; i < ARRAY_SIZE(env->tm_gpr); i++) {
target-ppc/kvm.c:                kvm_get_one_reg(cs, KVM_REG_PPC_TM_GPR(i), &env->tm_gpr[i]);
target-ppc/kvm.c:            for (i = 0; i < ARRAY_SIZE(env->tm_vsr); i++) {
target-ppc/kvm.c:                kvm_get_one_reg(cs, KVM_REG_PPC_TM_VSR(i), &env->tm_vsr[i]);
target-ppc/kvm.c:            kvm_get_one_reg(cs, KVM_REG_PPC_TM_CR, &env->tm_cr);
target-ppc/kvm.c:            kvm_get_one_reg(cs, KVM_REG_PPC_TM_LR, &env->tm_lr);
target-ppc/kvm.c:            kvm_get_one_reg(cs, KVM_REG_PPC_TM_CTR, &env->tm_ctr);
target-ppc/kvm.c:            kvm_get_one_reg(cs, KVM_REG_PPC_TM_FPSCR, &env->tm_fpscr);
target-ppc/kvm.c:            kvm_get_one_reg(cs, KVM_REG_PPC_TM_AMR, &env->tm_amr);
target-ppc/kvm.c:            kvm_get_one_reg(cs, KVM_REG_PPC_TM_PPR, &env->tm_ppr);
target-ppc/kvm.c:            kvm_get_one_reg(cs, KVM_REG_PPC_TM_VRSAVE, &env->tm_vrsave);
target-ppc/kvm.c:            kvm_get_one_reg(cs, KVM_REG_PPC_TM_VSCR, &env->tm_vscr);
target-ppc/kvm.c:            kvm_get_one_reg(cs, KVM_REG_PPC_TM_DSCR, &env->tm_dscr);
target-ppc/kvm.c:            kvm_get_one_reg(cs, KVM_REG_PPC_TM_TAR, &env->tm_tar);
target-ppc/kvm.c:        kvm_get_one_reg(cs, KVM_REG_PPC_TB_OFFSET, &env->tb_env->tb_offset);
target-ppc/kvm.c:     * interrupt, reset, etc) in PPC-specific env->irq_input_state. */
target-ppc/kvm.c:        (env->irq_input_state & (1<<PPC_INPUT_INT)))
target-ppc/kvm.c:    if (ppc_dcr_read(env->dcr_env, dcrn, data) < 0)
target-ppc/kvm.c:    if (ppc_dcr_write(env->dcr_env, dcrn, data) < 0)
target-ppc/kvm.c:        run->epr.epr = ldl_phys(cs->as, env->mpic_iack);
target-ppc/kvm.c:    uint32_t tcr = env->spr[SPR_BOOKE_TCR];
target-ppc/excp_helper.c:    env->error_code = 0;
target-ppc/excp_helper.c:    env->error_code = 0;
target-ppc/excp_helper.c:                  ppc_dump_gpr(env, 6), env->nip);
target-ppc/excp_helper.c:        lpes0 = (env->spr[SPR_LPCR] >> 1) & 1;
target-ppc/excp_helper.c:        lpes1 = (env->spr[SPR_LPCR] >> 2) & 1;
target-ppc/excp_helper.c:                  " => %08x (%02x)\n", env->nip, excp, env->error_code);
target-ppc/excp_helper.c:        msr = env->msr;
target-ppc/excp_helper.c:        msr = env->msr & ~0x783f0000ULL;
target-ppc/excp_helper.c:    new_msr = env->msr & ((target_ulong)1 << MSR_ME);
target-ppc/excp_helper.c:                 "\n", env->spr[SPR_DSISR], env->spr[SPR_DAR]);
target-ppc/excp_helper.c:                 "\n", msr, env->nip);
target-ppc/excp_helper.c:        msr |= env->error_code;
target-ppc/excp_helper.c:        if (env->mpic_proxy) {
target-ppc/excp_helper.c:            env->spr[SPR_BOOKE_EPR] = ldl_phys(cs->as, env->mpic_iack);
target-ppc/excp_helper.c:        env->spr[SPR_DSISR] |= (cpu_ldl_code(env, (env->nip - 4))
target-ppc/excp_helper.c:        switch (env->error_code & ~0xF) {
target-ppc/excp_helper.c:                env->error_code = 0;
target-ppc/excp_helper.c:            LOG_EXCP("Invalid instruction at " TARGET_FMT_lx "\n", env->nip);
target-ppc/excp_helper.c:            env->spr[SPR_BOOKE_ESR] = ESR_PIL;
target-ppc/excp_helper.c:            env->spr[SPR_BOOKE_ESR] = ESR_PPR;
target-ppc/excp_helper.c:            env->spr[SPR_BOOKE_ESR] = ESR_PTR;
target-ppc/excp_helper.c:                      env->error_code);
target-ppc/excp_helper.c:        lev = env->error_code;
target-ppc/excp_helper.c:        env->spr[SPR_BOOKE_ESR] = ESR_SPV;
target-ppc/excp_helper.c:        env->spr[SPR_BOOKE_ESR] = ESR_SPV;
target-ppc/excp_helper.c:        env->spr[SPR_BOOKE_ESR] = ESR_SPV;
target-ppc/excp_helper.c:        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);
target-ppc/excp_helper.c:        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);
target-ppc/excp_helper.c:        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);
target-ppc/excp_helper.c:        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);
target-ppc/excp_helper.c:        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);
target-ppc/excp_helper.c:                    miss = &env->spr[SPR_IMISS];
target-ppc/excp_helper.c:                    cmp = &env->spr[SPR_ICMP];
target-ppc/excp_helper.c:                    miss = &env->spr[SPR_DMISS];
target-ppc/excp_helper.c:                    cmp = &env->spr[SPR_DCMP];
target-ppc/excp_helper.c:                         env->spr[SPR_HASH1], env->spr[SPR_HASH2],
target-ppc/excp_helper.c:                         env->error_code);
target-ppc/excp_helper.c:            msr |= env->crf[0] << 28;
target-ppc/excp_helper.c:            msr |= env->error_code; /* key, D/I, S/L bits */
target-ppc/excp_helper.c:            msr |= ((env->last_way + 1) & (env->nb_ways - 1)) << 17;
target-ppc/excp_helper.c:                    miss = &env->spr[SPR_TLBMISS];
target-ppc/excp_helper.c:                    cmp = &env->spr[SPR_PTEHI];
target-ppc/excp_helper.c:                    miss = &env->spr[SPR_TLBMISS];
target-ppc/excp_helper.c:                    cmp = &env->spr[SPR_PTEHI];
target-ppc/excp_helper.c:                         env->error_code);
target-ppc/excp_helper.c:            msr |= env->error_code; /* key bit */
target-ppc/excp_helper.c:        env->spr[srr0] = env->nip - 4;
target-ppc/excp_helper.c:        env->spr[srr0] = env->nip;
target-ppc/excp_helper.c:    env->spr[srr1] = msr;
target-ppc/excp_helper.c:        env->spr[asrr0] = env->spr[srr0];
target-ppc/excp_helper.c:        env->spr[asrr1] = env->spr[srr1];
target-ppc/excp_helper.c:    if (env->spr[SPR_LPCR] & LPCR_AIL) {
target-ppc/excp_helper.c:        if (env->spr[SPR_LPCR] & LPCR_ILE) {
target-ppc/excp_helper.c:    vector = env->excp_vectors[excp];
target-ppc/excp_helper.c:    vector |= env->excp_prefix;
target-ppc/excp_helper.c:        if (env->spr[SPR_BOOKE_EPCR] & EPCR_ICM) {
target-ppc/excp_helper.c:        if (!msr_isf && !(env->mmu_model & POWERPC_MMU_64)) {
target-ppc/excp_helper.c:    env->msr = new_msr & env->msr_mask;
target-ppc/excp_helper.c:    env->nip = vector;
target-ppc/excp_helper.c:    env->error_code = 0;
target-ppc/excp_helper.c:    if ((env->mmu_model == POWERPC_MMU_BOOKE) ||
target-ppc/excp_helper.c:        (env->mmu_model == POWERPC_MMU_BOOKE206)) {
target-ppc/excp_helper.c:    powerpc_excp(cpu, env->excp_model, cs->exception_index);
target-ppc/excp_helper.c:                  __func__, env, env->pending_interrupts,
target-ppc/excp_helper.c:    if (env->pending_interrupts & (1 << PPC_INTERRUPT_RESET)) {
target-ppc/excp_helper.c:        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_RESET);
target-ppc/excp_helper.c:        powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_RESET);
target-ppc/excp_helper.c:    if (env->pending_interrupts & (1 << PPC_INTERRUPT_MCK)) {
target-ppc/excp_helper.c:        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_MCK);
target-ppc/excp_helper.c:        powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_MCHECK);
target-ppc/excp_helper.c:    if (env->pending_interrupts & (1 << PPC_INTERRUPT_DEBUG)) {
target-ppc/excp_helper.c:        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DEBUG);
target-ppc/excp_helper.c:        powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_DEBUG);
target-ppc/excp_helper.c:        hdice = env->spr[SPR_LPCR] & 1;
target-ppc/excp_helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_HDECR)) {
target-ppc/excp_helper.c:            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_HDECR);
target-ppc/excp_helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_CEXT)) {
target-ppc/excp_helper.c:            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_CEXT);
target-ppc/excp_helper.c:            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_CRITICAL);
target-ppc/excp_helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_WDT)) {
target-ppc/excp_helper.c:            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_WDT);
target-ppc/excp_helper.c:            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_WDT);
target-ppc/excp_helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_CDOORBELL)) {
target-ppc/excp_helper.c:            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_CDOORBELL);
target-ppc/excp_helper.c:            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_DOORCI);
target-ppc/excp_helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_FIT)) {
target-ppc/excp_helper.c:            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_FIT);
target-ppc/excp_helper.c:            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_FIT);
target-ppc/excp_helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_PIT)) {
target-ppc/excp_helper.c:            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_PIT);
target-ppc/excp_helper.c:            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_PIT);
target-ppc/excp_helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_DECR)) {
target-ppc/excp_helper.c:                env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DECR);
target-ppc/excp_helper.c:            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_DECR);
target-ppc/excp_helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_EXT)) {
target-ppc/excp_helper.c:            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_EXT);
target-ppc/excp_helper.c:            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_EXTERNAL);
target-ppc/excp_helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_DOORBELL)) {
target-ppc/excp_helper.c:            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DOORBELL);
target-ppc/excp_helper.c:            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_DOORI);
target-ppc/excp_helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_PERFM)) {
target-ppc/excp_helper.c:            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_PERFM);
target-ppc/excp_helper.c:            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_PERFM);
target-ppc/excp_helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_THERM)) {
target-ppc/excp_helper.c:            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_THERM);
target-ppc/excp_helper.c:            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_THERM);
target-ppc/excp_helper.c:    env->error_code = error_code;
target-ppc/excp_helper.c:            msr |= env->msr & ~((uint64_t)0xFFFFFFFF);
target-ppc/excp_helper.c:    env->nip = nip & ~((target_ulong)0x00000003);
target-ppc/excp_helper.c:    cpu_dump_rfi(env->nip, env->msr);
target-ppc/excp_helper.c:    if (env->excp_model == POWERPC_EXCP_BOOKE) {
target-ppc/excp_helper.c:        do_rfi(env, env->spr[SPR_SRR0], env->spr[SPR_SRR1],
target-ppc/excp_helper.c:        do_rfi(env, env->spr[SPR_SRR0], env->spr[SPR_SRR1],
target-ppc/excp_helper.c:    do_rfi(env, env->spr[SPR_SRR0], env->spr[SPR_SRR1],
target-ppc/excp_helper.c:    do_rfi(env, env->spr[SPR_HSRR0], env->spr[SPR_HSRR1],
target-ppc/excp_helper.c:    do_rfi(env, env->spr[SPR_40x_SRR2], env->spr[SPR_40x_SRR3],
target-ppc/excp_helper.c:    do_rfi(env, env->spr[SPR_BOOKE_CSRR0], env->spr[SPR_BOOKE_CSRR1],
target-ppc/excp_helper.c:    do_rfi(env, env->spr[SPR_BOOKE_DSRR0], env->spr[SPR_BOOKE_DSRR1],
target-ppc/excp_helper.c:    do_rfi(env, env->spr[SPR_BOOKE_MCSRR0], env->spr[SPR_BOOKE_MCSRR1],
target-ppc/excp_helper.c:    do_rfi(env, env->lr, env->ctr, 0x0000FFFF, 0);
target-ppc/excp_helper.c:    env->pending_interrupts &= ~(1 << irq);
target-ppc/excp_helper.c:        if ((rb & DBELL_BRDCAST) || (cenv->spr[SPR_BOOKE_PIR] == pir)) {
target-ppc/excp_helper.c:            cenv->pending_interrupts |= 1 << irq;
target-ppc/mmu-hash32.c:        BATlt = env->IBAT[1];
target-ppc/mmu-hash32.c:        BATut = env->IBAT[0];
target-ppc/mmu-hash32.c:        BATlt = env->DBAT[1];
target-ppc/mmu-hash32.c:        BATut = env->DBAT[0];
target-ppc/mmu-hash32.c:    for (i = 0; i < env->nb_BATs; i++) {
target-ppc/mmu-hash32.c:        if (unlikely(env->mmu_model == POWERPC_MMU_601)) {
target-ppc/mmu-hash32.c:            if (unlikely(env->mmu_model == POWERPC_MMU_601)) {
target-ppc/mmu-hash32.c:        env->error_code = 0x10000000;
target-ppc/mmu-hash32.c:    switch (env->access_type) {
target-ppc/mmu-hash32.c:        env->error_code = POWERPC_EXCP_ALIGN_FP;
target-ppc/mmu-hash32.c:        env->spr[SPR_DAR] = eaddr;
target-ppc/mmu-hash32.c:        env->error_code = 0;
target-ppc/mmu-hash32.c:        env->spr[SPR_DAR] = eaddr;
target-ppc/mmu-hash32.c:            env->spr[SPR_DSISR] = 0x06000000;
target-ppc/mmu-hash32.c:            env->spr[SPR_DSISR] = 0x04000000;
target-ppc/mmu-hash32.c:        env->error_code = 0;
target-ppc/mmu-hash32.c:        env->spr[SPR_DAR] = eaddr;
target-ppc/mmu-hash32.c:            env->spr[SPR_DSISR] = 0x06100000;
target-ppc/mmu-hash32.c:            env->spr[SPR_DSISR] = 0x04100000;
target-ppc/mmu-hash32.c:        env->error_code = 0;
target-ppc/mmu-hash32.c:        env->spr[SPR_DAR] = eaddr;
target-ppc/mmu-hash32.c:            env->spr[SPR_DSISR] = 0x0a000000;
target-ppc/mmu-hash32.c:            env->spr[SPR_DSISR] = 0x08000000;
target-ppc/mmu-hash32.c:    return (hash * HASH_PTEG_SIZE_32) & env->htab_mask;
target-ppc/mmu-hash32.c:            env->htab_base, env->htab_mask, hash);
target-ppc/mmu-hash32.c:            env->htab_base, env->htab_mask, vsid, ptem, hash);
target-ppc/mmu-hash32.c:                " hash=" TARGET_FMT_plx "\n", env->htab_base,
target-ppc/mmu-hash32.c:                env->htab_mask, vsid, ptem, ~hash);
target-ppc/mmu-hash32.c:    if (env->nb_BATs != 0) {
target-ppc/mmu-hash32.c:                    env->error_code = 0x08000000;
target-ppc/mmu-hash32.c:                    env->error_code = 0;
target-ppc/mmu-hash32.c:                    env->spr[SPR_DAR] = eaddr;
target-ppc/mmu-hash32.c:                        env->spr[SPR_DSISR] = 0x0a000000;
target-ppc/mmu-hash32.c:                        env->spr[SPR_DSISR] = 0x08000000;
target-ppc/mmu-hash32.c:    sr = env->sr[eaddr >> 28];
target-ppc/mmu-hash32.c:        env->error_code = 0x10000000;
target-ppc/mmu-hash32.c:            env->error_code = 0x40000000;
target-ppc/mmu-hash32.c:            env->error_code = 0;
target-ppc/mmu-hash32.c:            env->spr[SPR_DAR] = eaddr;
target-ppc/mmu-hash32.c:                env->spr[SPR_DSISR] = 0x42000000;
target-ppc/mmu-hash32.c:                env->spr[SPR_DSISR] = 0x40000000;
target-ppc/mmu-hash32.c:            env->error_code = 0x08000000;
target-ppc/mmu-hash32.c:            env->error_code = 0;
target-ppc/mmu-hash32.c:            env->spr[SPR_DAR] = eaddr;
target-ppc/mmu-hash32.c:                env->spr[SPR_DSISR] = 0x0a000000;
target-ppc/mmu-hash32.c:                env->spr[SPR_DSISR] = 0x08000000;
target-ppc/mmu-hash32.c:    if (env->nb_BATs != 0) {
target-ppc/mmu-hash32.c:    sr = env->sr[eaddr >> 28];
target-ppc/mmu_helper.c:    nr = (eaddr >> TARGET_PAGE_BITS) & (env->tlb_per_way - 1);
target-ppc/mmu_helper.c:    nr += env->tlb_per_way * way;
target-ppc/mmu_helper.c:    if (is_code && env->id_tlbs == 1) {
target-ppc/mmu_helper.c:        nr += env->nb_tlb;
target-ppc/mmu_helper.c:    max = env->nb_tlb;
target-ppc/mmu_helper.c:    if (env->id_tlbs == 1) {
target-ppc/mmu_helper.c:        tlb = &env->tlb.tlb6[nr];
target-ppc/mmu_helper.c:    for (way = 0; way < env->nb_ways; way++) {
target-ppc/mmu_helper.c:        tlb = &env->tlb.tlb6[nr];
target-ppc/mmu_helper.c:                      env->nb_tlb, eaddr);
target-ppc/mmu_helper.c:    tlb = &env->tlb.tlb6[nr];
target-ppc/mmu_helper.c:              " PTE1 " TARGET_FMT_lx "\n", nr, env->nb_tlb, EPN, pte0, pte1);
target-ppc/mmu_helper.c:    env->last_way = way;
target-ppc/mmu_helper.c:    for (way = 0; way < env->nb_ways; way++) {
target-ppc/mmu_helper.c:        tlb = &env->tlb.tlb6[nr];
target-ppc/mmu_helper.c:                      "] <> " TARGET_FMT_lx "\n", nr, env->nb_tlb,
target-ppc/mmu_helper.c:                  TARGET_FMT_lx " %c %c\n", nr, env->nb_tlb,
target-ppc/mmu_helper.c:        pte_update_flags(ctx, &env->tlb.tlb6[best].pte1, ret, rw);
target-ppc/mmu_helper.c:        BATlt = env->IBAT[1];
target-ppc/mmu_helper.c:        BATut = env->IBAT[0];
target-ppc/mmu_helper.c:        BATlt = env->DBAT[1];
target-ppc/mmu_helper.c:        BATut = env->DBAT[0];
target-ppc/mmu_helper.c:    for (i = 0; i < env->nb_BATs; i++) {
target-ppc/mmu_helper.c:    sr = env->sr[eaddr >> 28];
target-ppc/mmu_helper.c:            eaddr, (int)(eaddr >> 28), sr, env->nip, env->lr, (int)msr_ir,
target-ppc/mmu_helper.c:                    env->htab_base, env->htab_mask, hash);
target-ppc/mmu_helper.c:        sr = env->sr[eaddr >> 28];
target-ppc/mmu_helper.c:    for (i = 0; i < env->nb_tlb; i++) {
target-ppc/mmu_helper.c:        tlb = &env->tlb.tlbe[i];
target-ppc/mmu_helper.c:    for (i = 0; i < env->nb_tlb; i++) {
target-ppc/mmu_helper.c:        tlb = &env->tlb.tlbe[i];
target-ppc/mmu_helper.c:    for (i = 0; i < env->nb_tlb; i++) {
target-ppc/mmu_helper.c:        tlb = &env->tlb.tlbe[i];
target-ppc/mmu_helper.c:    for (i = 0; i < env->nb_tlb; i++) {
target-ppc/mmu_helper.c:        tlb = &env->tlb.tlbe[i];
target-ppc/mmu_helper.c:                             env->spr[SPR_40x_PID], 0, i) < 0) {
target-ppc/mmu_helper.c:        zpr = (env->spr[SPR_40x_ZPR] >> (30 - (2 * zsel))) & 0x3;
target-ppc/mmu_helper.c:                env->spr[SPR_40x_ESR] = 1 << 22;
target-ppc/mmu_helper.c:                env->spr[SPR_40x_ESR] = 0;
target-ppc/mmu_helper.c:    env->spr[SPR_405_SLER] = val;
target-ppc/mmu_helper.c:                         env->spr[SPR_BOOKE_PID],
target-ppc/mmu_helper.c:                         !env->nb_pids, i) >= 0) {
target-ppc/mmu_helper.c:    if (env->spr[SPR_BOOKE_PID1] &&
target-ppc/mmu_helper.c:                         env->spr[SPR_BOOKE_PID1], 0, i) >= 0) {
target-ppc/mmu_helper.c:    if (env->spr[SPR_BOOKE_PID2] &&
target-ppc/mmu_helper.c:                         env->spr[SPR_BOOKE_PID2], 0, i) >= 0) {
target-ppc/mmu_helper.c:    for (i = 0; i < env->nb_tlb; i++) {
target-ppc/mmu_helper.c:        tlb = &env->tlb.tlbe[i];
target-ppc/mmu_helper.c:    ppcmas_tlb_t *tlb = env->tlb.tlbm;
target-ppc/mmu_helper.c:                         env->spr[SPR_BOOKE_PID]) >= 0) {
target-ppc/mmu_helper.c:    if (env->spr[SPR_BOOKE_PID1] &&
target-ppc/mmu_helper.c:                         env->spr[SPR_BOOKE_PID1]) >= 0) {
target-ppc/mmu_helper.c:    if (env->spr[SPR_BOOKE_PID2] &&
target-ppc/mmu_helper.c:                         env->spr[SPR_BOOKE_PID2]) >= 0) {
target-ppc/mmu_helper.c:    if (kvm_enabled() && !env->kvm_sw_tlb) {
target-ppc/mmu_helper.c:    entry = &env->tlb.tlbe[0];
target-ppc/mmu_helper.c:    for (i = 0; i < env->nb_tlb; i++, entry++) {
target-ppc/mmu_helper.c:    entry = &env->tlb.tlbm[offset];
target-ppc/mmu_helper.c:    if (kvm_enabled() && !env->kvm_sw_tlb) {
target-ppc/mmu_helper.c:        BATlt = env->IBAT[1];
target-ppc/mmu_helper.c:        BATut = env->IBAT[0];
target-ppc/mmu_helper.c:        BATlt = env->DBAT[1];
target-ppc/mmu_helper.c:        BATut = env->DBAT[0];
target-ppc/mmu_helper.c:    for (i = 0; i < env->nb_BATs; i++) {
target-ppc/mmu_helper.c:    cpu_fprintf(f, "HTAB base = 0x%"HWADDR_PRIx"\n", env->htab_base);
target-ppc/mmu_helper.c:    cpu_fprintf(f, "HTAB mask = 0x%"HWADDR_PRIx"\n", env->htab_mask);
target-ppc/mmu_helper.c:        sr = env->sr[i];
target-ppc/mmu_helper.c:    if (env->id_tlbs != 1) {
target-ppc/mmu_helper.c:        for (way = 0; way < env->nb_ways; way++) {
target-ppc/mmu_helper.c:            for (entry = env->nb_tlb * type + env->tlb_per_way * way;
target-ppc/mmu_helper.c:                 entry < (env->nb_tlb * type + env->tlb_per_way * (way + 1));
target-ppc/mmu_helper.c:                tlb = &env->tlb.tlb6[entry];
target-ppc/mmu_helper.c:                            type ? "code" : "data", entry % env->nb_tlb,
target-ppc/mmu_helper.c:                            env->nb_tlb, way,
target-ppc/mmu_helper.c:    switch (env->mmu_model) {
target-ppc/mmu_helper.c:    switch (env->mmu_model) {
target-ppc/mmu_helper.c:                (env->pb[0] < env->pb[1] &&
target-ppc/mmu_helper.c:                 eaddr >= env->pb[0] && eaddr < env->pb[1]) ||
target-ppc/mmu_helper.c:                (env->pb[2] < env->pb[3] &&
target-ppc/mmu_helper.c:                 eaddr >= env->pb[2] && eaddr < env->pb[3]) ? 1 : 0;
target-ppc/mmu_helper.c:    switch (env->mmu_model) {
target-ppc/mmu_helper.c:            if (env->nb_BATs != 0) {
target-ppc/mmu_helper.c:    switch (env->mmu_model) {
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS0] = env->spr[SPR_BOOKE_MAS4] & MAS4_TLBSELD_MASK;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS1] = env->spr[SPR_BOOKE_MAS4] & MAS4_TSIZED_MASK;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS2] = env->spr[SPR_BOOKE_MAS4] & MAS4_WIMGED_MASK;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS3] = 0;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS6] = 0;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS7] = 0;
target-ppc/mmu_helper.c:        env->spr[SPR_BOOKE_MAS1] |= MAS1_TS;
target-ppc/mmu_helper.c:        env->spr[SPR_BOOKE_MAS6] |= MAS6_SAS;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS1] |= MAS1_VALID;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS2] |= address & MAS2_EPN_MASK;
target-ppc/mmu_helper.c:    switch (env->spr[SPR_BOOKE_MAS4] & MAS4_TIDSELD_PIDZ) {
target-ppc/mmu_helper.c:        env->spr[SPR_BOOKE_MAS1] |= env->spr[SPR_BOOKE_PID] << MAS1_TID_SHIFT;
target-ppc/mmu_helper.c:        env->spr[SPR_BOOKE_MAS1] |= env->spr[SPR_BOOKE_PID1] << MAS1_TID_SHIFT;
target-ppc/mmu_helper.c:        env->spr[SPR_BOOKE_MAS1] |= env->spr[SPR_BOOKE_PID2] << MAS1_TID_SHIFT;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS6] |= env->spr[SPR_BOOKE_PID] << 16;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS0] |= env->last_way << MAS0_ESEL_SHIFT;
target-ppc/mmu_helper.c:    env->last_way++;
target-ppc/mmu_helper.c:    env->last_way &= booke206_tlb_ways(env, 0) - 1;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS0] |= env->last_way << MAS0_NV_SHIFT;
target-ppc/mmu_helper.c:        access_type = env->access_type;
target-ppc/mmu_helper.c:                switch (env->mmu_model) {
target-ppc/mmu_helper.c:                    env->error_code = 1 << 18;
target-ppc/mmu_helper.c:                    env->spr[SPR_IMISS] = address;
target-ppc/mmu_helper.c:                    env->spr[SPR_ICMP] = 0x80000000 | ctx.ptem;
target-ppc/mmu_helper.c:                    env->error_code = 0;
target-ppc/mmu_helper.c:                    env->spr[SPR_40x_DEAR] = address;
target-ppc/mmu_helper.c:                    env->spr[SPR_40x_ESR] = 0x00000000;
target-ppc/mmu_helper.c:                    env->error_code = 0;
target-ppc/mmu_helper.c:                    env->spr[SPR_BOOKE_DEAR] = address;
target-ppc/mmu_helper.c:                env->error_code = 0x08000000;
target-ppc/mmu_helper.c:                if ((env->mmu_model == POWERPC_MMU_BOOKE) ||
target-ppc/mmu_helper.c:                    (env->mmu_model == POWERPC_MMU_BOOKE206)) {
target-ppc/mmu_helper.c:                    env->spr[SPR_BOOKE_ESR] = 0x00000000;
target-ppc/mmu_helper.c:                env->error_code = 0x10000000;
target-ppc/mmu_helper.c:                env->error_code = 0x10000000;
target-ppc/mmu_helper.c:                switch (env->mmu_model) {
target-ppc/mmu_helper.c:                        env->error_code = 1 << 16;
target-ppc/mmu_helper.c:                        env->error_code = 0;
target-ppc/mmu_helper.c:                    env->spr[SPR_DMISS] = address;
target-ppc/mmu_helper.c:                    env->spr[SPR_DCMP] = 0x80000000 | ctx.ptem;
target-ppc/mmu_helper.c:                    env->error_code |= ctx.key << 19;
target-ppc/mmu_helper.c:                    env->spr[SPR_HASH1] = env->htab_base +
target-ppc/mmu_helper.c:                    env->spr[SPR_HASH2] = env->htab_base +
target-ppc/mmu_helper.c:                    env->error_code = ctx.key << 19;
target-ppc/mmu_helper.c:                    env->spr[SPR_TLBMISS] = (address & ~((target_ulong)0x3)) |
target-ppc/mmu_helper.c:                        ((env->last_way + 1) & (env->nb_ways - 1));
target-ppc/mmu_helper.c:                    env->spr[SPR_PTEHI] = 0x80000000 | ctx.ptem;
target-ppc/mmu_helper.c:                    env->error_code = 0;
target-ppc/mmu_helper.c:                    env->spr[SPR_40x_DEAR] = address;
target-ppc/mmu_helper.c:                        env->spr[SPR_40x_ESR] = 0x00800000;
target-ppc/mmu_helper.c:                        env->spr[SPR_40x_ESR] = 0x00000000;
target-ppc/mmu_helper.c:                    env->error_code = 0;
target-ppc/mmu_helper.c:                    env->spr[SPR_BOOKE_DEAR] = address;
target-ppc/mmu_helper.c:                    env->spr[SPR_BOOKE_ESR] = rw ? ESR_ST : 0;
target-ppc/mmu_helper.c:                env->error_code = 0;
target-ppc/mmu_helper.c:                if (env->mmu_model == POWERPC_MMU_SOFT_4xx
target-ppc/mmu_helper.c:                    || env->mmu_model == POWERPC_MMU_SOFT_4xx_Z) {
target-ppc/mmu_helper.c:                    env->spr[SPR_40x_DEAR] = address;
target-ppc/mmu_helper.c:                        env->spr[SPR_40x_ESR] |= 0x00800000;
target-ppc/mmu_helper.c:                } else if ((env->mmu_model == POWERPC_MMU_BOOKE) ||
target-ppc/mmu_helper.c:                           (env->mmu_model == POWERPC_MMU_BOOKE206)) {
target-ppc/mmu_helper.c:                    env->spr[SPR_BOOKE_DEAR] = address;
target-ppc/mmu_helper.c:                    env->spr[SPR_BOOKE_ESR] = rw ? ESR_ST : 0;
target-ppc/mmu_helper.c:                    env->spr[SPR_DAR] = address;
target-ppc/mmu_helper.c:                        env->spr[SPR_DSISR] = 0x0A000000;
target-ppc/mmu_helper.c:                        env->spr[SPR_DSISR] = 0x08000000;
target-ppc/mmu_helper.c:                    env->error_code = POWERPC_EXCP_ALIGN_FP;
target-ppc/mmu_helper.c:                    env->spr[SPR_DAR] = address;
target-ppc/mmu_helper.c:                    env->error_code = 0;
target-ppc/mmu_helper.c:                    env->spr[SPR_DAR] = address;
target-ppc/mmu_helper.c:                        env->spr[SPR_DSISR] = 0x06000000;
target-ppc/mmu_helper.c:                        env->spr[SPR_DSISR] = 0x04000000;
target-ppc/mmu_helper.c:                    env->error_code = 0;
target-ppc/mmu_helper.c:                    env->spr[SPR_DAR] = address;
target-ppc/mmu_helper.c:                        env->spr[SPR_DSISR] = 0x06100000;
target-ppc/mmu_helper.c:                        env->spr[SPR_DSISR] = 0x04100000;
target-ppc/mmu_helper.c:                    env->error_code =
target-ppc/mmu_helper.c:                    env->spr[SPR_DAR] = address;
target-ppc/mmu_helper.c:               cs->exception, env->error_code);
target-ppc/mmu_helper.c:             nr, ul == 0 ? 'u' : 'l', value, env->nip);
target-ppc/mmu_helper.c:    if (env->IBAT[0][nr] != value) {
target-ppc/mmu_helper.c:        do_invalidate_BAT(env, env->IBAT[0][nr], mask);
target-ppc/mmu_helper.c:        env->IBAT[0][nr] = (value & 0x00001FFFUL) |
target-ppc/mmu_helper.c:        env->IBAT[1][nr] = (env->IBAT[1][nr] & 0x0000007B) |
target-ppc/mmu_helper.c:            (env->IBAT[1][nr] & ~0x0001FFFF & ~mask);
target-ppc/mmu_helper.c:        do_invalidate_BAT(env, env->IBAT[0][nr], mask);
target-ppc/mmu_helper.c:    env->IBAT[1][nr] = value;
target-ppc/mmu_helper.c:    if (env->DBAT[0][nr] != value) {
target-ppc/mmu_helper.c:        do_invalidate_BAT(env, env->DBAT[0][nr], mask);
target-ppc/mmu_helper.c:        env->DBAT[0][nr] = (value & 0x00001FFFUL) |
target-ppc/mmu_helper.c:        env->DBAT[1][nr] = (env->DBAT[1][nr] & 0x0000007B) |
target-ppc/mmu_helper.c:            (env->DBAT[1][nr] & ~0x0001FFFF & ~mask);
target-ppc/mmu_helper.c:        do_invalidate_BAT(env, env->DBAT[0][nr], mask);
target-ppc/mmu_helper.c:    env->DBAT[1][nr] = value;
target-ppc/mmu_helper.c:    if (env->IBAT[0][nr] != value) {
target-ppc/mmu_helper.c:        mask = (env->IBAT[1][nr] << 17) & 0x0FFE0000UL;
target-ppc/mmu_helper.c:        if (env->IBAT[1][nr] & 0x40) {
target-ppc/mmu_helper.c:            do_invalidate_BAT(env, env->IBAT[0][nr], mask);
target-ppc/mmu_helper.c:        env->IBAT[0][nr] = (value & 0x00001FFFUL) |
target-ppc/mmu_helper.c:        env->DBAT[0][nr] = env->IBAT[0][nr];
target-ppc/mmu_helper.c:        if (env->IBAT[1][nr] & 0x40) {
target-ppc/mmu_helper.c:            do_invalidate_BAT(env, env->IBAT[0][nr], mask);
target-ppc/mmu_helper.c:    if (env->IBAT[1][nr] != value) {
target-ppc/mmu_helper.c:        if (env->IBAT[1][nr] & 0x40) {
target-ppc/mmu_helper.c:            mask = (env->IBAT[1][nr] << 17) & 0x0FFE0000UL;
target-ppc/mmu_helper.c:            do_invalidate_BAT(env, env->IBAT[0][nr], mask);
target-ppc/mmu_helper.c:            do_invalidate_BAT(env, env->IBAT[0][nr], mask);
target-ppc/mmu_helper.c:        env->IBAT[1][nr] = value;
target-ppc/mmu_helper.c:        env->DBAT[1][nr] = value;
target-ppc/mmu_helper.c:    switch (env->mmu_model) {
target-ppc/mmu_helper.c:    switch (env->mmu_model) {
target-ppc/mmu_helper.c:        if (env->id_tlbs == 1) {
target-ppc/mmu_helper.c:        ppc4xx_tlb_invalidate_virt(env, addr, env->spr[SPR_40x_PID]);
target-ppc/mmu_helper.c:    assert(!env->external_htab);
target-ppc/mmu_helper.c:    if (env->spr[SPR_SDR1] != value) {
target-ppc/mmu_helper.c:        env->spr[SPR_SDR1] = value;
target-ppc/mmu_helper.c:        if (env->mmu_model & POWERPC_MMU_64) {
target-ppc/mmu_helper.c:            env->htab_mask = (1ULL << (htabsize + 18 - 7)) - 1;
target-ppc/mmu_helper.c:            env->htab_base = value & SDR_64_HTABORG;
target-ppc/mmu_helper.c:            env->htab_mask = ((value & SDR_32_HTABMASK) << 16) | 0xFFFF;
target-ppc/mmu_helper.c:            env->htab_base = value & SDR_32_HTABORG;
target-ppc/mmu_helper.c:    if (env->mmu_model & POWERPC_MMU_64) {
target-ppc/mmu_helper.c:    return env->sr[sr_num];
target-ppc/mmu_helper.c:            (int)srnum, value, env->sr[srnum]);
target-ppc/mmu_helper.c:    if (env->mmu_model & POWERPC_MMU_64) {
target-ppc/mmu_helper.c:    if (env->sr[srnum] != value) {
target-ppc/mmu_helper.c:        env->sr[srnum] = value;
target-ppc/mmu_helper.c:    RPN = env->spr[SPR_RPA];
target-ppc/mmu_helper.c:        CMP = env->spr[SPR_ICMP];
target-ppc/mmu_helper.c:        EPN = env->spr[SPR_IMISS];
target-ppc/mmu_helper.c:        CMP = env->spr[SPR_DCMP];
target-ppc/mmu_helper.c:        EPN = env->spr[SPR_DMISS];
target-ppc/mmu_helper.c:    way = (env->spr[SPR_SRR1] >> 17) & 1;
target-ppc/mmu_helper.c:    RPN = env->spr[SPR_PTELO];
target-ppc/mmu_helper.c:    CMP = env->spr[SPR_PTEHI];
target-ppc/mmu_helper.c:    EPN = env->spr[SPR_TLBMISS] & ~0x3;
target-ppc/mmu_helper.c:    way = env->spr[SPR_TLBMISS] & 0x3;
target-ppc/mmu_helper.c:    nb_BATs = env->nb_BATs;
target-ppc/mmu_helper.c:    env->nb_BATs = 0;
target-ppc/mmu_helper.c:    env->nb_BATs = nb_BATs;
target-ppc/mmu_helper.c:    tlb = &env->tlb.tlbe[entry];
target-ppc/mmu_helper.c:    env->spr[SPR_40x_PID] = tlb->PID;
target-ppc/mmu_helper.c:    tlb = &env->tlb.tlbe[entry];
target-ppc/mmu_helper.c:    tlb = &env->tlb.tlbe[entry];
target-ppc/mmu_helper.c:    tlb->PID = env->spr[SPR_40x_PID]; /* PID */
target-ppc/mmu_helper.c:    tlb = &env->tlb.tlbe[entry];
target-ppc/mmu_helper.c:    return ppcemb_tlb_search(env, address, env->spr[SPR_40x_PID]);
target-ppc/mmu_helper.c:    tlb = &env->tlb.tlbe[entry];
target-ppc/mmu_helper.c:        tlb->PID = env->spr[SPR_440_MMUCR] & 0x000000FF;
target-ppc/mmu_helper.c:    tlb = &env->tlb.tlbe[entry];
target-ppc/mmu_helper.c:        env->spr[SPR_440_MMUCR] &= ~0x000000FF;
target-ppc/mmu_helper.c:        env->spr[SPR_440_MMUCR] |= tlb->PID;
target-ppc/mmu_helper.c:    return ppcemb_tlb_search(env, address, env->spr[SPR_440_MMUCR] & 0xFF);
target-ppc/mmu_helper.c:    int esel = (env->spr[SPR_BOOKE_MAS0] & MAS0_ESEL_MASK) >> MAS0_ESEL_SHIFT;
target-ppc/mmu_helper.c:    int ea = (env->spr[SPR_BOOKE_MAS2] & MAS2_EPN_MASK);
target-ppc/mmu_helper.c:    tlb = (env->spr[SPR_BOOKE_MAS0] & MAS0_TLBSEL_MASK) >> MAS0_TLBSEL_SHIFT;
target-ppc/mmu_helper.c:    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlb];
target-ppc/mmu_helper.c:    if ((tlbncfg & TLBnCFG_HES) && (env->spr[SPR_BOOKE_MAS0] & MAS0_HES)) {
target-ppc/mmu_helper.c:    env->spr[pidn] = pid;
target-ppc/mmu_helper.c:    switch (env->spr[SPR_BOOKE_MAS0] & MAS0_WQ_MASK) {
target-ppc/mmu_helper.c:    if (((env->spr[SPR_BOOKE_MAS0] & MAS0_ATSEL) == MAS0_ATSEL_LRAT) &&
target-ppc/mmu_helper.c:    tlbn = (env->spr[SPR_BOOKE_MAS0] & MAS0_TLBSEL_MASK) >> MAS0_TLBSEL_SHIFT;
target-ppc/mmu_helper.c:    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];
target-ppc/mmu_helper.c:    size_tlb = (env->spr[SPR_BOOKE_MAS1] & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;
target-ppc/mmu_helper.c:    if ((env->spr[SPR_BOOKE_MAS1] & MAS1_VALID) && (tlbncfg & TLBnCFG_AVAIL) &&
target-ppc/mmu_helper.c:    tlb->mas7_3 = ((uint64_t)env->spr[SPR_BOOKE_MAS7] << 32) |
target-ppc/mmu_helper.c:        env->spr[SPR_BOOKE_MAS3];
target-ppc/mmu_helper.c:    tlb->mas1 = env->spr[SPR_BOOKE_MAS1];
target-ppc/mmu_helper.c:    tlb->mas2 = env->spr[SPR_BOOKE_MAS2] & mask;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS0] = tlbn << MAS0_TLBSEL_SHIFT;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS0] |= way << MAS0_ESEL_SHIFT;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS0] |= env->last_way << MAS0_NV_SHIFT;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS1] = tlb->mas1;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS2] = tlb->mas2;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS3] = tlb->mas7_3;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS7] = tlb->mas7_3 >> 32;
target-ppc/mmu_helper.c:        env->spr[SPR_BOOKE_MAS1] = 0;
target-ppc/mmu_helper.c:    spid = (env->spr[SPR_BOOKE_MAS6] & MAS6_SPID_MASK) >> MAS6_SPID_SHIFT;
target-ppc/mmu_helper.c:    sas = env->spr[SPR_BOOKE_MAS6] & MAS6_SAS;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS0] = env->spr[SPR_BOOKE_MAS4] & MAS4_TLBSELD_MASK;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS1] = env->spr[SPR_BOOKE_MAS4] & MAS4_TSIZED_MASK;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS2] = env->spr[SPR_BOOKE_MAS4] & MAS4_WIMGED_MASK;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS3] = 0;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS7] = 0;
target-ppc/mmu_helper.c:    if (env->spr[SPR_BOOKE_MAS6] & MAS6_SAS) {
target-ppc/mmu_helper.c:        env->spr[SPR_BOOKE_MAS1] |= MAS1_TS;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS1] |= (env->spr[SPR_BOOKE_MAS6] >> 16)
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS0] |= env->last_way << MAS0_ESEL_SHIFT;
target-ppc/mmu_helper.c:    env->last_way++;
target-ppc/mmu_helper.c:    env->last_way &= booke206_tlb_ways(env, 0) - 1;
target-ppc/mmu_helper.c:    env->spr[SPR_BOOKE_MAS0] |= env->last_way << MAS0_NV_SHIFT;
target-ppc/mmu_helper.c:    int tid = (env->spr[SPR_BOOKE_MAS6] & MAS6_SPID);
target-ppc/mmu_helper.c:    ppcmas_tlb_t *tlb = env->tlb.tlbm;
target-ppc/mmu_helper.c:    int tid = (env->spr[SPR_BOOKE_MAS6] & MAS6_SPID);
target-ppc/mmu_helper.c:    int sgs = env->spr[SPR_BOOKE_MAS5] & MAS5_SGS;
target-ppc/mmu_helper.c:    int ind = (env->spr[SPR_BOOKE_MAS6] & MAS6_SIND) ? MAS1_IND : 0;
target-ppc/mmu_helper.c:    int size = env->spr[SPR_BOOKE_MAS6] & MAS6_ISIZE_MASK;
target-ppc/mmu_helper.c:        helper_raise_exception_err(env, cs->exception_index, env->error_code);
target-ppc/mmu-hash64.h:    if (env->external_htab) {
target-ppc/mmu-hash64.h:    if (env->external_htab) {
target-ppc/timebase_helper.c:    if (unlikely(env->dcr_env == NULL)) {
target-ppc/timebase_helper.c:    } else if (unlikely(ppc_dcr_read(env->dcr_env,
target-ppc/timebase_helper.c:    if (unlikely(env->dcr_env == NULL)) {
target-ppc/timebase_helper.c:    } else if (unlikely(ppc_dcr_write(env->dcr_env, (uint32_t)dcrn,
target-ppc/machine.c:        qemu_get_betls(f, &env->gpr[i]);
target-ppc/machine.c:        qemu_get_betls(f, &env->gprh[i]);
target-ppc/machine.c:    qemu_get_betls(f, &env->lr);
target-ppc/machine.c:    qemu_get_betls(f, &env->ctr);
target-ppc/machine.c:        qemu_get_be32s(f, &env->crf[i]);
target-ppc/machine.c:    qemu_get_betls(f, &env->reserve_addr);
target-ppc/machine.c:    qemu_get_betls(f, &env->msr);
target-ppc/machine.c:        qemu_get_betls(f, &env->tgpr[i]);
target-ppc/machine.c:        env->fpr[i] = u.d;
target-ppc/machine.c:    env->fpscr = fpscr;
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->access_type);
target-ppc/machine.c:    qemu_get_betls(f, &env->spr[SPR_ASR]);
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->slb_nr);
target-ppc/machine.c:        qemu_get_betls(f, &env->sr[i]);
target-ppc/machine.c:            qemu_get_betls(f, &env->DBAT[i][j]);
target-ppc/machine.c:            qemu_get_betls(f, &env->IBAT[i][j]);
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->nb_tlb);
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->tlb_per_way);
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->nb_ways);
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->last_way);
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->id_tlbs);
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->nb_pids);
target-ppc/machine.c:    if (env->tlb.tlb6) {
target-ppc/machine.c:        for (i = 0; i < env->nb_tlb; i++) {
target-ppc/machine.c:            qemu_get_betls(f, &env->tlb.tlb6[i].pte0);
target-ppc/machine.c:            qemu_get_betls(f, &env->tlb.tlb6[i].pte1);
target-ppc/machine.c:            qemu_get_betls(f, &env->tlb.tlb6[i].EPN);
target-ppc/machine.c:        qemu_get_betls(f, &env->pb[i]);
target-ppc/machine.c:        qemu_get_betls(f, &env->spr[i]);
target-ppc/machine.c:    if (!env->external_htab) {
target-ppc/machine.c:    qemu_get_be32s(f, &env->vscr);
target-ppc/machine.c:    qemu_get_be64s(f, &env->spe_acc);
target-ppc/machine.c:    qemu_get_be32s(f, &env->spe_fscr);
target-ppc/machine.c:    qemu_get_betls(f, &env->msr_mask);
target-ppc/machine.c:    qemu_get_be32s(f, &env->flags);
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->error_code);
target-ppc/machine.c:    qemu_get_be32s(f, &env->pending_interrupts);
target-ppc/machine.c:    qemu_get_be32s(f, &env->irq_input_state);
target-ppc/machine.c:        qemu_get_betls(f, &env->excp_vectors[i]);
target-ppc/machine.c:    qemu_get_betls(f, &env->excp_prefix);
target-ppc/machine.c:    qemu_get_betls(f, &env->ivor_mask);
target-ppc/machine.c:    qemu_get_betls(f, &env->ivpr_mask);
target-ppc/machine.c:    qemu_get_betls(f, &env->hreset_vector);
target-ppc/machine.c:    qemu_get_betls(f, &env->nip);
target-ppc/machine.c:    qemu_get_betls(f, &env->hflags);
target-ppc/machine.c:    qemu_get_betls(f, &env->hflags_nmsr);
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->mmu_idx);
target-ppc/machine.c:    env->spr[SPR_LR] = env->lr;
target-ppc/machine.c:    env->spr[SPR_CTR] = env->ctr;
target-ppc/machine.c:    env->spr[SPR_XER] = env->xer;
target-ppc/machine.c:    env->spr[SPR_CFAR] = env->cfar;
target-ppc/machine.c:    env->spr[SPR_BOOKE_SPEFSCR] = env->spe_fscr;
target-ppc/machine.c:    for (i = 0; (i < 4) && (i < env->nb_BATs); i++) {
target-ppc/machine.c:        env->spr[SPR_DBAT0U + 2*i] = env->DBAT[0][i];
target-ppc/machine.c:        env->spr[SPR_DBAT0U + 2*i + 1] = env->DBAT[1][i];
target-ppc/machine.c:        env->spr[SPR_IBAT0U + 2*i] = env->IBAT[0][i];
target-ppc/machine.c:        env->spr[SPR_IBAT0U + 2*i + 1] = env->IBAT[1][i];
target-ppc/machine.c:    for (i = 0; (i < 4) && ((i+4) < env->nb_BATs); i++) {
target-ppc/machine.c:        env->spr[SPR_DBAT4U + 2*i] = env->DBAT[0][i+4];
target-ppc/machine.c:        env->spr[SPR_DBAT4U + 2*i + 1] = env->DBAT[1][i+4];
target-ppc/machine.c:        env->spr[SPR_IBAT4U + 2*i] = env->IBAT[0][i+4];
target-ppc/machine.c:        env->spr[SPR_IBAT4U + 2*i + 1] = env->IBAT[1][i+4];
target-ppc/machine.c:    env->spr[SPR_PVR] = env->spr_cb[SPR_PVR].default_value;
target-ppc/machine.c:    env->lr = env->spr[SPR_LR];
target-ppc/machine.c:    env->ctr = env->spr[SPR_CTR];
target-ppc/machine.c:    env->xer = env->spr[SPR_XER];
target-ppc/machine.c:    env->cfar = env->spr[SPR_CFAR];
target-ppc/machine.c:    env->spe_fscr = env->spr[SPR_BOOKE_SPEFSCR];
target-ppc/machine.c:    for (i = 0; (i < 4) && (i < env->nb_BATs); i++) {
target-ppc/machine.c:        env->DBAT[0][i] = env->spr[SPR_DBAT0U + 2*i];
target-ppc/machine.c:        env->DBAT[1][i] = env->spr[SPR_DBAT0U + 2*i + 1];
target-ppc/machine.c:        env->IBAT[0][i] = env->spr[SPR_IBAT0U + 2*i];
target-ppc/machine.c:        env->IBAT[1][i] = env->spr[SPR_IBAT0U + 2*i + 1];
target-ppc/machine.c:    for (i = 0; (i < 4) && ((i+4) < env->nb_BATs); i++) {
target-ppc/machine.c:        env->DBAT[0][i+4] = env->spr[SPR_DBAT4U + 2*i];
target-ppc/machine.c:        env->DBAT[1][i+4] = env->spr[SPR_DBAT4U + 2*i + 1];
target-ppc/machine.c:        env->IBAT[0][i+4] = env->spr[SPR_IBAT4U + 2*i];
target-ppc/machine.c:        env->IBAT[1][i+4] = env->spr[SPR_IBAT4U + 2*i + 1];
target-ppc/machine.c:    if (!env->external_htab) {
target-ppc/machine.c:        ppc_store_sdr1(env, env->spr[SPR_SDR1]);
target-ppc/machine.c:    return env->nb_tlb && (env->tlb_type == TLB_6XX);
target-ppc/machine.c:    return env->nb_tlb && (env->tlb_type == TLB_EMB);
target-ppc/machine.c:    return env->nb_tlb && (env->tlb_type == TLB_MAS);
target-ppc/cpu.h:#define PPC_INPUT(env) (env->bus_model)
target-ppc/cpu.h:#define msr_sf   ((env->msr >> MSR_SF)   & 1)
target-ppc/cpu.h:#define msr_isf  ((env->msr >> MSR_ISF)  & 1)
target-ppc/cpu.h:#define msr_shv  ((env->msr >> MSR_SHV)  & 1)
target-ppc/cpu.h:#define msr_cm   ((env->msr >> MSR_CM)   & 1)
target-ppc/cpu.h:#define msr_icm  ((env->msr >> MSR_ICM)  & 1)
target-ppc/cpu.h:#define msr_thv  ((env->msr >> MSR_THV)  & 1)
target-ppc/cpu.h:#define msr_gs   ((env->msr >> MSR_GS)   & 1)
target-ppc/cpu.h:#define msr_ucle ((env->msr >> MSR_UCLE) & 1)
target-ppc/cpu.h:#define msr_vr   ((env->msr >> MSR_VR)   & 1)
target-ppc/cpu.h:#define msr_spe  ((env->msr >> MSR_SPE)  & 1)
target-ppc/cpu.h:#define msr_ap   ((env->msr >> MSR_AP)   & 1)
target-ppc/cpu.h:#define msr_vsx  ((env->msr >> MSR_VSX)  & 1)
target-ppc/cpu.h:#define msr_sa   ((env->msr >> MSR_SA)   & 1)
target-ppc/cpu.h:#define msr_key  ((env->msr >> MSR_KEY)  & 1)
target-ppc/cpu.h:#define msr_pow  ((env->msr >> MSR_POW)  & 1)
target-ppc/cpu.h:#define msr_tgpr ((env->msr >> MSR_TGPR) & 1)
target-ppc/cpu.h:#define msr_ce   ((env->msr >> MSR_CE)   & 1)
target-ppc/cpu.h:#define msr_ile  ((env->msr >> MSR_ILE)  & 1)
target-ppc/cpu.h:#define msr_ee   ((env->msr >> MSR_EE)   & 1)
target-ppc/cpu.h:#define msr_pr   ((env->msr >> MSR_PR)   & 1)
target-ppc/cpu.h:#define msr_fp   ((env->msr >> MSR_FP)   & 1)
target-ppc/cpu.h:#define msr_me   ((env->msr >> MSR_ME)   & 1)
target-ppc/cpu.h:#define msr_fe0  ((env->msr >> MSR_FE0)  & 1)
target-ppc/cpu.h:#define msr_se   ((env->msr >> MSR_SE)   & 1)
target-ppc/cpu.h:#define msr_dwe  ((env->msr >> MSR_DWE)  & 1)
target-ppc/cpu.h:#define msr_uble ((env->msr >> MSR_UBLE) & 1)
target-ppc/cpu.h:#define msr_be   ((env->msr >> MSR_BE)   & 1)
target-ppc/cpu.h:#define msr_de   ((env->msr >> MSR_DE)   & 1)
target-ppc/cpu.h:#define msr_fe1  ((env->msr >> MSR_FE1)  & 1)
target-ppc/cpu.h:#define msr_al   ((env->msr >> MSR_AL)   & 1)
target-ppc/cpu.h:#define msr_ep   ((env->msr >> MSR_EP)   & 1)
target-ppc/cpu.h:#define msr_ir   ((env->msr >> MSR_IR)   & 1)
target-ppc/cpu.h:#define msr_dr   ((env->msr >> MSR_DR)   & 1)
target-ppc/cpu.h:#define msr_pe   ((env->msr >> MSR_PE)   & 1)
target-ppc/cpu.h:#define msr_px   ((env->msr >> MSR_PX)   & 1)
target-ppc/cpu.h:#define msr_pmm  ((env->msr >> MSR_PMM)  & 1)
target-ppc/cpu.h:#define msr_ri   ((env->msr >> MSR_RI)   & 1)
target-ppc/cpu.h:#define msr_le   ((env->msr >> MSR_LE)   & 1)
target-ppc/cpu.h:#define msr_ts   ((env->msr >> MSR_TS1)  & 3)
target-ppc/cpu.h:#define msr_tm   ((env->msr >> MSR_TM)   & 1)
target-ppc/cpu.h:#define fpscr_fex    (((env->fpscr) >> FPSCR_FEX)    & 0x1)
target-ppc/cpu.h:#define fpscr_vx     (((env->fpscr) >> FPSCR_VX)     & 0x1)
target-ppc/cpu.h:#define fpscr_ox     (((env->fpscr) >> FPSCR_OX)     & 0x1)
target-ppc/cpu.h:#define fpscr_ux     (((env->fpscr) >> FPSCR_UX)     & 0x1)
target-ppc/cpu.h:#define fpscr_zx     (((env->fpscr) >> FPSCR_ZX)     & 0x1)
target-ppc/cpu.h:#define fpscr_xx     (((env->fpscr) >> FPSCR_XX)     & 0x1)
target-ppc/cpu.h:#define fpscr_vxsnan (((env->fpscr) >> FPSCR_VXSNAN) & 0x1)
target-ppc/cpu.h:#define fpscr_vxisi  (((env->fpscr) >> FPSCR_VXISI)  & 0x1)
target-ppc/cpu.h:#define fpscr_vxidi  (((env->fpscr) >> FPSCR_VXIDI)  & 0x1)
target-ppc/cpu.h:#define fpscr_vxzdz  (((env->fpscr) >> FPSCR_VXZDZ)  & 0x1)
target-ppc/cpu.h:#define fpscr_vximz  (((env->fpscr) >> FPSCR_VXIMZ)  & 0x1)
target-ppc/cpu.h:#define fpscr_vxvc   (((env->fpscr) >> FPSCR_VXVC)   & 0x1)
target-ppc/cpu.h:#define fpscr_fpcc   (((env->fpscr) >> FPSCR_FPCC)   & 0xF)
target-ppc/cpu.h:#define fpscr_vxsoft (((env->fpscr) >> FPSCR_VXSOFT) & 0x1)
target-ppc/cpu.h:#define fpscr_vxsqrt (((env->fpscr) >> FPSCR_VXSQRT) & 0x1)
target-ppc/cpu.h:#define fpscr_vxcvi  (((env->fpscr) >> FPSCR_VXCVI)  & 0x1)
target-ppc/cpu.h:#define fpscr_ve     (((env->fpscr) >> FPSCR_VE)     & 0x1)
target-ppc/cpu.h:#define fpscr_oe     (((env->fpscr) >> FPSCR_OE)     & 0x1)
target-ppc/cpu.h:#define fpscr_ue     (((env->fpscr) >> FPSCR_UE)     & 0x1)
target-ppc/cpu.h:#define fpscr_ze     (((env->fpscr) >> FPSCR_ZE)     & 0x1)
target-ppc/cpu.h:#define fpscr_xe     (((env->fpscr) >> FPSCR_XE)     & 0x1)
target-ppc/cpu.h:#define fpscr_ni     (((env->fpscr) >> FPSCR_NI)     & 0x1)
target-ppc/cpu.h:#define fpscr_rn     (((env->fpscr) >> FPSCR_RN)     & 0x3)
target-ppc/cpu.h:#define fpscr_ix ((env->fpscr) & ((1 << FPSCR_VXSNAN) | (1 << FPSCR_VXISI)  | \
target-ppc/cpu.h:#define fpscr_ex  (((env->fpscr) >> FPSCR_XX) & 0x1F)
target-ppc/cpu.h:#define fpscr_eex (((env->fpscr) >> FPSCR_XX) & ((env->fpscr) >> FPSCR_XE) &  \
target-ppc/cpu.h:#define vscr_nj		(((env->vscr) >> VSCR_NJ)	& 0x1)
target-ppc/cpu.h:#define vscr_sat	(((env->vscr) >> VSCR_SAT)	& 0x1)
target-ppc/cpu.h:    env->fit_period[0] = (a_);                  \
target-ppc/cpu.h:    env->fit_period[1] = (b_);                  \
target-ppc/cpu.h:    env->fit_period[2] = (c_);                  \
target-ppc/cpu.h:    env->fit_period[3] = (d_);                  \
target-ppc/cpu.h:    env->wdt_period[0] = (a_);                  \
target-ppc/cpu.h:    env->wdt_period[1] = (b_);                  \
target-ppc/cpu.h:    env->wdt_period[2] = (c_);                  \
target-ppc/cpu.h:    env->wdt_period[3] = (d_);                  \
target-ppc/cpu.h:    gprv = env->gpr[gprn];
target-ppc/cpu.h:    if (env->flags & POWERPC_FLAG_SPE) {
target-ppc/cpu.h:        gprv |= (uint64_t)env->gprh[gprn] << 32;
target-ppc/cpu.h:    return env->mmu_idx;
target-ppc/cpu.h:#define xer_so  (env->so)
target-ppc/cpu.h:#define xer_ov  (env->ov)
target-ppc/cpu.h:#define xer_ca  (env->ca)
target-ppc/cpu.h:#define xer_cmp ((env->xer >> XER_CMP) & 0xFF)
target-ppc/cpu.h:#define xer_bc  ((env->xer >> XER_BC)  & 0x7F)
target-ppc/cpu.h:    return env->xer | (env->so << XER_SO) | (env->ov << XER_OV) | (env->ca << XER_CA);
target-ppc/cpu.h:    env->so = (xer >> XER_SO) & 1;
target-ppc/cpu.h:    env->ov = (xer >> XER_OV) & 1;
target-ppc/cpu.h:    env->ca = (xer >> XER_CA) & 1;
target-ppc/cpu.h:    env->xer = xer & ~((1u << XER_SO) | (1u << XER_OV) | (1u << XER_CA));
target-ppc/cpu.h:    *pc = env->nip;
target-ppc/cpu.h:    *flags = env->hflags;
target-ppc/cpu.h:    uintptr_t tlbl = (uintptr_t)env->tlb.tlbm;
target-ppc/cpu.h:    return (tlbml - tlbl) / sizeof(env->tlb.tlbm[0]);
target-ppc/cpu.h:    uint32_t tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];
target-ppc/cpu.h:    uint32_t tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];
target-ppc/cpu.h:    return &env->tlb.tlbm[r];
target-ppc/cpu.h:        ret = env->spr[SPR_BOOKE_TLB0PS + tlbn];
target-ppc/cpu.h:        uint32_t tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];
target-ppc/cpu.h:    if (env->mmu_model == POWERPC_MMU_BOOKE206) {
target-ppc/fpu_helper.c:    d.d = float32_to_float64(f.f, &env->fp_status);
target-ppc/fpu_helper.c:    f.f = float64_to_float32(d.d, &env->fp_status);
target-ppc/fpu_helper.c:        env->fpscr &= ~(0x1F << FPSCR_FPRF);
target-ppc/fpu_helper.c:        env->fpscr |= ret << FPSCR_FPRF;
target-ppc/fpu_helper.c:        env->fpscr |= 1 << FPSCR_VXSNAN;
target-ppc/fpu_helper.c:        env->fpscr |= 1 << FPSCR_VXSOFT;
target-ppc/fpu_helper.c:        env->fpscr |= 1 << FPSCR_VXISI;
target-ppc/fpu_helper.c:        env->fpscr |= 1 << FPSCR_VXIDI;
target-ppc/fpu_helper.c:        env->fpscr |= 1 << FPSCR_VXZDZ;
target-ppc/fpu_helper.c:        env->fpscr |= 1 << FPSCR_VXIMZ;
target-ppc/fpu_helper.c:        env->fpscr |= 1 << FPSCR_VXVC;
target-ppc/fpu_helper.c:            env->fpscr &= ~(0xF << FPSCR_FPCC);
target-ppc/fpu_helper.c:            env->fpscr |= 0x11 << FPSCR_FPCC;
target-ppc/fpu_helper.c:            env->error_code = POWERPC_EXCP_FP | POWERPC_EXCP_FP_VXVC;
target-ppc/fpu_helper.c:            env->fpscr |= 1 << FPSCR_FEX;
target-ppc/fpu_helper.c:        env->fpscr |= 1 << FPSCR_VXSQRT;
target-ppc/fpu_helper.c:        env->fpscr &= ~((1 << FPSCR_FR) | (1 << FPSCR_FI));
target-ppc/fpu_helper.c:                env->fpscr &= ~(0xF << FPSCR_FPCC);
target-ppc/fpu_helper.c:                env->fpscr |= 0x11 << FPSCR_FPCC;
target-ppc/fpu_helper.c:        env->fpscr |= 1 << FPSCR_VXCVI;
target-ppc/fpu_helper.c:        env->fpscr &= ~((1 << FPSCR_FR) | (1 << FPSCR_FI));
target-ppc/fpu_helper.c:                env->fpscr &= ~(0xF << FPSCR_FPCC);
target-ppc/fpu_helper.c:                env->fpscr |= 0x11 << FPSCR_FPCC;
target-ppc/fpu_helper.c:    env->fpscr |= 1 << FPSCR_VX;
target-ppc/fpu_helper.c:    env->fpscr |= 1 << FPSCR_FX;
target-ppc/fpu_helper.c:        env->fpscr |= 1 << FPSCR_FEX;
target-ppc/fpu_helper.c:    env->fpscr |= 1 << FPSCR_ZX;
target-ppc/fpu_helper.c:    env->fpscr &= ~((1 << FPSCR_FR) | (1 << FPSCR_FI));
target-ppc/fpu_helper.c:    env->fpscr |= 1 << FPSCR_FX;
target-ppc/fpu_helper.c:        env->fpscr |= 1 << FPSCR_FEX;
target-ppc/fpu_helper.c:    env->fpscr |= 1 << FPSCR_OX;
target-ppc/fpu_helper.c:    env->fpscr |= 1 << FPSCR_FX;
target-ppc/fpu_helper.c:        env->fpscr |= 1 << FPSCR_FEX;
target-ppc/fpu_helper.c:        env->error_code = POWERPC_EXCP_FP | POWERPC_EXCP_FP_OX;
target-ppc/fpu_helper.c:        env->fpscr |= 1 << FPSCR_XX;
target-ppc/fpu_helper.c:        env->fpscr |= 1 << FPSCR_FI;
target-ppc/fpu_helper.c:    env->fpscr |= 1 << FPSCR_UX;
target-ppc/fpu_helper.c:    env->fpscr |= 1 << FPSCR_FX;
target-ppc/fpu_helper.c:        env->fpscr |= 1 << FPSCR_FEX;
target-ppc/fpu_helper.c:        env->error_code = POWERPC_EXCP_FP | POWERPC_EXCP_FP_UX;
target-ppc/fpu_helper.c:    env->fpscr |= 1 << FPSCR_XX;
target-ppc/fpu_helper.c:    env->fpscr |= 1 << FPSCR_FX;
target-ppc/fpu_helper.c:        env->fpscr |= 1 << FPSCR_FEX;
target-ppc/fpu_helper.c:        env->error_code = POWERPC_EXCP_FP | POWERPC_EXCP_FP_XX;
target-ppc/fpu_helper.c:    set_float_rounding_mode(rnd_type, &env->fp_status);
target-ppc/fpu_helper.c:    prev = (env->fpscr >> bit) & 1;
target-ppc/fpu_helper.c:    env->fpscr &= ~(1 << bit);
target-ppc/fpu_helper.c:    prev = (env->fpscr >> bit) & 1;
target-ppc/fpu_helper.c:    env->fpscr |= 1 << bit;
target-ppc/fpu_helper.c:            env->fpscr |= 1 << FPSCR_FX;
target-ppc/fpu_helper.c:            env->fpscr |= 1 << FPSCR_FX;
target-ppc/fpu_helper.c:            env->fpscr |= 1 << FPSCR_FX;
target-ppc/fpu_helper.c:            env->fpscr |= 1 << FPSCR_FX;
target-ppc/fpu_helper.c:            env->fpscr |= 1 << FPSCR_FX;
target-ppc/fpu_helper.c:            env->fpscr |= 1 << FPSCR_VX;
target-ppc/fpu_helper.c:            env->fpscr |= 1 << FPSCR_FX;
target-ppc/fpu_helper.c:                env->error_code = POWERPC_EXCP_FP;
target-ppc/fpu_helper.c:                    env->error_code |= POWERPC_EXCP_FP_VXSNAN;
target-ppc/fpu_helper.c:                    env->error_code |= POWERPC_EXCP_FP_VXISI;
target-ppc/fpu_helper.c:                    env->error_code |= POWERPC_EXCP_FP_VXIDI;
target-ppc/fpu_helper.c:                    env->error_code |= POWERPC_EXCP_FP_VXZDZ;
target-ppc/fpu_helper.c:                    env->error_code |= POWERPC_EXCP_FP_VXIMZ;
target-ppc/fpu_helper.c:                    env->error_code |= POWERPC_EXCP_FP_VXVC;
target-ppc/fpu_helper.c:                    env->error_code |= POWERPC_EXCP_FP_VXSOFT;
target-ppc/fpu_helper.c:                    env->error_code |= POWERPC_EXCP_FP_VXSQRT;
target-ppc/fpu_helper.c:                    env->error_code |= POWERPC_EXCP_FP_VXCVI;
target-ppc/fpu_helper.c:                env->error_code = POWERPC_EXCP_FP | POWERPC_EXCP_FP_OX;
target-ppc/fpu_helper.c:                env->error_code = POWERPC_EXCP_FP | POWERPC_EXCP_FP_UX;
target-ppc/fpu_helper.c:                env->error_code = POWERPC_EXCP_FP | POWERPC_EXCP_FP_ZX;
target-ppc/fpu_helper.c:                env->error_code = POWERPC_EXCP_FP | POWERPC_EXCP_FP_XX;
target-ppc/fpu_helper.c:            env->fpscr |= 1 << FPSCR_FEX;
target-ppc/fpu_helper.c:    prev = env->fpscr;
target-ppc/fpu_helper.c:            env->fpscr &= ~(0xFLL << (4 * i));
target-ppc/fpu_helper.c:            env->fpscr |= new & (0xFLL << (4 * i));
target-ppc/fpu_helper.c:        env->fpscr |= 1 << FPSCR_VX;
target-ppc/fpu_helper.c:        env->fpscr &= ~(1 << FPSCR_VX);
target-ppc/fpu_helper.c:        env->fpscr |= 1 << FPSCR_FEX;
target-ppc/fpu_helper.c:        env->error_code = POWERPC_EXCP_FP;
target-ppc/fpu_helper.c:        env->fpscr &= ~(1 << FPSCR_FEX);
target-ppc/fpu_helper.c:    int status = get_float_exception_flags(&env->fp_status);
target-ppc/fpu_helper.c:        (env->error_code & POWERPC_EXCP_FP)) {
target-ppc/fpu_helper.c:                                       env->error_code);
target-ppc/fpu_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-ppc/fpu_helper.c:        farg1.d = float64_add(farg1.d, farg2.d, &env->fp_status);
target-ppc/fpu_helper.c:        farg1.d = float64_sub(farg1.d, farg2.d, &env->fp_status);
target-ppc/fpu_helper.c:        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);
target-ppc/fpu_helper.c:        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);
target-ppc/fpu_helper.c:    farg.ll = float64_to_##cvt(farg.d, &env->fp_status);               \
target-ppc/fpu_helper.c:    if (unlikely(env->fp_status.float_exception_flags)) {              \
target-ppc/fpu_helper.c:        } else if (env->fp_status.float_exception_flags &              \
target-ppc/fpu_helper.c:        float32 tmp = cvtr(arg, &env->fp_status);          \
target-ppc/fpu_helper.c:        farg.d = float32_to_float64(tmp, &env->fp_status); \
target-ppc/fpu_helper.c:        farg.d = cvtr(arg, &env->fp_status);               \
target-ppc/fpu_helper.c:        int inexact = get_float_exception_flags(&env->fp_status) &
target-ppc/fpu_helper.c:        set_float_rounding_mode(rounding_mode, &env->fp_status);
target-ppc/fpu_helper.c:        farg.ll = float64_round_to_int(farg.d, &env->fp_status);
target-ppc/fpu_helper.c:            env->fp_status.float_exception_flags &= ~float_flag_inexact;
target-ppc/fpu_helper.c:        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);
target-ppc/fpu_helper.c:        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);
target-ppc/fpu_helper.c:        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);
target-ppc/fpu_helper.c:            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);
target-ppc/fpu_helper.c:            ft0_128 = float128_add(ft0_128, ft1_128, &env->fp_status);
target-ppc/fpu_helper.c:            farg1.d = float128_to_float64(ft0_128, &env->fp_status);
target-ppc/fpu_helper.c:        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);
target-ppc/fpu_helper.c:        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);
target-ppc/fpu_helper.c:        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);
target-ppc/fpu_helper.c:            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);
target-ppc/fpu_helper.c:            ft0_128 = float128_sub(ft0_128, ft1_128, &env->fp_status);
target-ppc/fpu_helper.c:            farg1.d = float128_to_float64(ft0_128, &env->fp_status);
target-ppc/fpu_helper.c:        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);
target-ppc/fpu_helper.c:        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);
target-ppc/fpu_helper.c:        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);
target-ppc/fpu_helper.c:            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);
target-ppc/fpu_helper.c:            ft0_128 = float128_add(ft0_128, ft1_128, &env->fp_status);
target-ppc/fpu_helper.c:            farg1.d = float128_to_float64(ft0_128, &env->fp_status);
target-ppc/fpu_helper.c:        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);
target-ppc/fpu_helper.c:        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);
target-ppc/fpu_helper.c:        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);
target-ppc/fpu_helper.c:            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);
target-ppc/fpu_helper.c:            ft0_128 = float128_sub(ft0_128, ft1_128, &env->fp_status);
target-ppc/fpu_helper.c:            farg1.d = float128_to_float64(ft0_128, &env->fp_status);
target-ppc/fpu_helper.c:    f32 = float64_to_float32(farg.d, &env->fp_status);
target-ppc/fpu_helper.c:    farg.d = float32_to_float64(f32, &env->fp_status);
target-ppc/fpu_helper.c:        farg.d = float64_sqrt(farg.d, &env->fp_status);
target-ppc/fpu_helper.c:    farg.d = float64_div(float64_one, farg.d, &env->fp_status);
target-ppc/fpu_helper.c:    farg.d = float64_div(float64_one, farg.d, &env->fp_status);
target-ppc/fpu_helper.c:    f32 = float64_to_float32(farg.d, &env->fp_status);
target-ppc/fpu_helper.c:    farg.d = float32_to_float64(f32, &env->fp_status);
target-ppc/fpu_helper.c:        farg.d = float64_sqrt(farg.d, &env->fp_status);
target-ppc/fpu_helper.c:        farg.d = float64_div(float64_one, farg.d, &env->fp_status);
target-ppc/fpu_helper.c:    } else if (float64_lt(farg1.d, farg2.d, &env->fp_status)) {
target-ppc/fpu_helper.c:    } else if (!float64_le(farg1.d, farg2.d, &env->fp_status)) {
target-ppc/fpu_helper.c:    env->fpscr &= ~(0x0F << FPSCR_FPRF);
target-ppc/fpu_helper.c:    env->fpscr |= ret << FPSCR_FPRF;
target-ppc/fpu_helper.c:    env->crf[crfD] = ret;
target-ppc/fpu_helper.c:    } else if (float64_lt(farg1.d, farg2.d, &env->fp_status)) {
target-ppc/fpu_helper.c:    } else if (!float64_le(farg1.d, farg2.d, &env->fp_status)) {
target-ppc/fpu_helper.c:    env->fpscr &= ~(0x0F << FPSCR_FPRF);
target-ppc/fpu_helper.c:    env->fpscr |= ret << FPSCR_FPRF;
target-ppc/fpu_helper.c:    env->crf[crfD] = ret;
target-ppc/fpu_helper.c:    u.f = int32_to_float32(val, &env->vec_status);
target-ppc/fpu_helper.c:    u.f = uint32_to_float32(val, &env->vec_status);
target-ppc/fpu_helper.c:    return float32_to_int32(u.f, &env->vec_status);
target-ppc/fpu_helper.c:    return float32_to_uint32(u.f, &env->vec_status);
target-ppc/fpu_helper.c:    return float32_to_int32_round_to_zero(u.f, &env->vec_status);
target-ppc/fpu_helper.c:    return float32_to_uint32_round_to_zero(u.f, &env->vec_status);
target-ppc/fpu_helper.c:    u.f = int32_to_float32(val, &env->vec_status);
target-ppc/fpu_helper.c:    tmp = int64_to_float32(1ULL << 32, &env->vec_status);
target-ppc/fpu_helper.c:    u.f = float32_div(u.f, tmp, &env->vec_status);
target-ppc/fpu_helper.c:    u.f = uint32_to_float32(val, &env->vec_status);
target-ppc/fpu_helper.c:    tmp = uint64_to_float32(1ULL << 32, &env->vec_status);
target-ppc/fpu_helper.c:    u.f = float32_div(u.f, tmp, &env->vec_status);
target-ppc/fpu_helper.c:    tmp = uint64_to_float32(1ULL << 32, &env->vec_status);
target-ppc/fpu_helper.c:    u.f = float32_mul(u.f, tmp, &env->vec_status);
target-ppc/fpu_helper.c:    return float32_to_int32(u.f, &env->vec_status);
target-ppc/fpu_helper.c:    tmp = uint64_to_float32(1ULL << 32, &env->vec_status);
target-ppc/fpu_helper.c:    u.f = float32_mul(u.f, tmp, &env->vec_status);
target-ppc/fpu_helper.c:    return float32_to_uint32(u.f, &env->vec_status);
target-ppc/fpu_helper.c:    u1.f = float32_add(u1.f, u2.f, &env->vec_status);
target-ppc/fpu_helper.c:    u1.f = float32_sub(u1.f, u2.f, &env->vec_status);
target-ppc/fpu_helper.c:    u1.f = float32_mul(u1.f, u2.f, &env->vec_status);
target-ppc/fpu_helper.c:    u1.f = float32_div(u1.f, u2.f, &env->vec_status);
target-ppc/fpu_helper.c:    return float32_lt(u1.f, u2.f, &env->vec_status) ? 4 : 0;
target-ppc/fpu_helper.c:    return float32_le(u1.f, u2.f, &env->vec_status) ? 0 : 4;
target-ppc/fpu_helper.c:    return float32_eq(u1.f, u2.f, &env->vec_status) ? 4 : 0;
target-ppc/fpu_helper.c:    u.d = int32_to_float64(val, &env->vec_status);
target-ppc/fpu_helper.c:    u.d = int64_to_float64(val, &env->vec_status);
target-ppc/fpu_helper.c:    u.d = uint32_to_float64(val, &env->vec_status);
target-ppc/fpu_helper.c:    u.d = uint64_to_float64(val, &env->vec_status);
target-ppc/fpu_helper.c:    return float64_to_int32(u.d, &env->vec_status);
target-ppc/fpu_helper.c:    return float64_to_uint32(u.d, &env->vec_status);
target-ppc/fpu_helper.c:    return float64_to_int32_round_to_zero(u.d, &env->vec_status);
target-ppc/fpu_helper.c:    return float64_to_int64_round_to_zero(u.d, &env->vec_status);
target-ppc/fpu_helper.c:    return float64_to_uint32_round_to_zero(u.d, &env->vec_status);
target-ppc/fpu_helper.c:    return float64_to_uint64_round_to_zero(u.d, &env->vec_status);
target-ppc/fpu_helper.c:    u.d = int32_to_float64(val, &env->vec_status);
target-ppc/fpu_helper.c:    tmp = int64_to_float64(1ULL << 32, &env->vec_status);
target-ppc/fpu_helper.c:    u.d = float64_div(u.d, tmp, &env->vec_status);
target-ppc/fpu_helper.c:    u.d = uint32_to_float64(val, &env->vec_status);
target-ppc/fpu_helper.c:    tmp = int64_to_float64(1ULL << 32, &env->vec_status);
target-ppc/fpu_helper.c:    u.d = float64_div(u.d, tmp, &env->vec_status);
target-ppc/fpu_helper.c:    tmp = uint64_to_float64(1ULL << 32, &env->vec_status);
target-ppc/fpu_helper.c:    u.d = float64_mul(u.d, tmp, &env->vec_status);
target-ppc/fpu_helper.c:    return float64_to_int32(u.d, &env->vec_status);
target-ppc/fpu_helper.c:    tmp = uint64_to_float64(1ULL << 32, &env->vec_status);
target-ppc/fpu_helper.c:    u.d = float64_mul(u.d, tmp, &env->vec_status);
target-ppc/fpu_helper.c:    return float64_to_uint32(u.d, &env->vec_status);
target-ppc/fpu_helper.c:    u2.f = float64_to_float32(u1.d, &env->vec_status);
target-ppc/fpu_helper.c:    u2.d = float32_to_float64(u1.f, &env->vec_status);
target-ppc/fpu_helper.c:    u1.d = float64_add(u1.d, u2.d, &env->vec_status);
target-ppc/fpu_helper.c:    u1.d = float64_sub(u1.d, u2.d, &env->vec_status);
target-ppc/fpu_helper.c:    u1.d = float64_mul(u1.d, u2.d, &env->vec_status);
target-ppc/fpu_helper.c:    u1.d = float64_div(u1.d, u2.d, &env->vec_status);
target-ppc/fpu_helper.c:    return float64_lt(u1.d, u2.d, &env->vec_status) ? 4 : 0;
target-ppc/fpu_helper.c:    return float64_le(u1.d, u2.d, &env->vec_status) ? 0 : 4;
target-ppc/fpu_helper.c:    return float64_eq_quiet(u1.d, u2.d, &env->vec_status) ? 4 : 0;
target-ppc/fpu_helper.c:        vsr->VsrD(0) = env->fpr[n];
target-ppc/fpu_helper.c:        vsr->VsrD(1) = env->vsr[n];
target-ppc/fpu_helper.c:        vsr->u64[0] = env->avr[n-32].u64[0];
target-ppc/fpu_helper.c:        vsr->u64[1] = env->avr[n-32].u64[1];
target-ppc/fpu_helper.c:        env->fpr[n] = vsr->VsrD(0);
target-ppc/fpu_helper.c:        env->vsr[n] = vsr->VsrD(1);
target-ppc/fpu_helper.c:        env->avr[n-32].u64[0] = vsr->u64[0];
target-ppc/fpu_helper.c:        env->avr[n-32].u64[1] = vsr->u64[1];
target-ppc/fpu_helper.c:        float_status tstat = env->fp_status;                                 \
target-ppc/fpu_helper.c:        env->fp_status.float_exception_flags |= tstat.float_exception_flags; \
target-ppc/fpu_helper.c:        float_status tstat = env->fp_status;                                 \
target-ppc/fpu_helper.c:        env->fp_status.float_exception_flags |= tstat.float_exception_flags; \
target-ppc/fpu_helper.c:        float_status tstat = env->fp_status;                                  \
target-ppc/fpu_helper.c:        env->fp_status.float_exception_flags |= tstat.float_exception_flags;  \
target-ppc/fpu_helper.c:        xt.fld = tp##_div(tp##_one, xb.fld, &env->fp_status);                 \
target-ppc/fpu_helper.c:        float_status tstat = env->fp_status;                                 \
target-ppc/fpu_helper.c:        env->fp_status.float_exception_flags |= tstat.float_exception_flags; \
target-ppc/fpu_helper.c:        float_status tstat = env->fp_status;                                 \
target-ppc/fpu_helper.c:        env->fp_status.float_exception_flags |= tstat.float_exception_flags; \
target-ppc/fpu_helper.c:    env->crf[BF(opcode)] = 0x8 | (fg_flag ? 4 : 0) | (fe_flag ? 2 : 0); \
target-ppc/fpu_helper.c:    env->crf[BF(opcode)] = 0x8 | (fg_flag ? 4 : 0) | (fe_flag ? 2 : 0); \
target-ppc/fpu_helper.c:        float_status tstat = env->fp_status;                                  \
target-ppc/fpu_helper.c:        env->fp_status.float_exception_flags |= tstat.float_exception_flags;  \
target-ppc/fpu_helper.c:                    POWERPC_EXCP_FP_VXIMZ, sfprf), &env->fp_status);          \
target-ppc/fpu_helper.c:        if (float64_lt(xa.VsrD(0), xb.VsrD(0), &env->fp_status)) {       \
target-ppc/fpu_helper.c:                               &env->fp_status)) { \
target-ppc/fpu_helper.c:    env->fpscr &= ~(0x0F << FPSCR_FPRF);                                 \
target-ppc/fpu_helper.c:    env->fpscr |= cc << FPSCR_FPRF;                                      \
target-ppc/fpu_helper.c:    env->crf[BF(opcode)] = cc;                                           \
target-ppc/fpu_helper.c:        xt.fld = tp##_##op(xa.fld, xb.fld, &env->fp_status);                  \
target-ppc/fpu_helper.c:            if (tp##_##cmp(xb.fld, xa.fld, &env->fp_status) == 1) {       \
target-ppc/fpu_helper.c:        env->crf[6] = (all_true ? 0x8 : 0) | (all_false ? 0x2 : 0);       \
target-ppc/fpu_helper.c:        xt.tfld = stp##_to_##ttp(xb.sfld, &env->fp_status);        \
target-ppc/fpu_helper.c:                                &env->fp_status), sfprf);          \
target-ppc/fpu_helper.c:    float_status tstat = env->fp_status;
target-ppc/fpu_helper.c:    float_status tstat = env->fp_status;
target-ppc/fpu_helper.c:                          &env->fp_status);                                  \
target-ppc/fpu_helper.c:            if (env->fp_status.float_exception_flags & float_flag_invalid) { \
target-ppc/fpu_helper.c:        xt.tfld = stp##_to_##ttp(xb.sfld, &env->fp_status);             \
target-ppc/fpu_helper.c:        set_float_rounding_mode(rmode, &env->fp_status);               \
target-ppc/fpu_helper.c:            xt.fld = tp##_round_to_int(xb.fld, &env->fp_status);       \
target-ppc/fpu_helper.c:        env->fp_status.float_exception_flags &= ~float_flag_inexact;   \
target-ppc/misc_helper.c:             env->spr[sprn]);
target-ppc/misc_helper.c:             env->spr[sprn]);
target-ppc/misc_helper.c:    env->spr[SPR_FSCR] &= ~((target_ulong)FSCR_IC_MASK << FSCR_IC_POS);
target-ppc/misc_helper.c:    env->spr[SPR_FSCR] |= (target_ulong)cause << FSCR_IC_POS;
target-ppc/misc_helper.c:    if (env->spr[SPR_FSCR] & (1ULL << bit)) {
target-ppc/misc_helper.c:    if (env->msr & (1ULL << bit)) {
target-ppc/misc_helper.c:    if (!env->external_htab) {
target-ppc/misc_helper.c:    hid0 = env->spr[SPR_HID0];
target-ppc/misc_helper.c:        env->hflags &= ~(1 << MSR_LE);
target-ppc/misc_helper.c:        env->hflags_nmsr &= ~(1 << MSR_LE);
target-ppc/misc_helper.c:        env->hflags_nmsr |= (1 << MSR_LE) & (((val >> 3) & 1) << MSR_LE);
target-ppc/misc_helper.c:        env->hflags |= env->hflags_nmsr;
target-ppc/misc_helper.c:                 val & 0x8 ? 'l' : 'b', env->hflags);
target-ppc/misc_helper.c:    env->spr[SPR_HID0] = (uint32_t)val;
target-ppc/misc_helper.c:    if (likely(env->pb[num] != value)) {
target-ppc/misc_helper.c:        env->pb[num] = value;
target-ppc/misc_helper.c:        return env->icache_line_size;
target-ppc/misc_helper.c:        return env->dcache_line_size;
target-ppc/misc_helper.c:        return (env->icache_line_size < env->dcache_line_size) ?
target-ppc/misc_helper.c:            env->icache_line_size : env->dcache_line_size;
target-ppc/misc_helper.c:        return (env->icache_line_size > env->dcache_line_size) ?
target-ppc/misc_helper.c:            env->icache_line_size : env->dcache_line_size;
target-ppc/mmu-hash64.c:    for (n = 0; n < env->slb_nr; n++) {
target-ppc/mmu-hash64.c:        ppc_slb_t *slb = &env->slb[n];
target-ppc/mmu-hash64.c:    for (i = 0; i < env->slb_nr; i++) {
target-ppc/mmu-hash64.c:        slbe = env->slb[i].esid;
target-ppc/mmu-hash64.c:        slbv = env->slb[i].vsid;
target-ppc/mmu-hash64.c:    for (n = 1; n < env->slb_nr; n++) {
target-ppc/mmu-hash64.c:        ppc_slb_t *slb = &env->slb[n];
target-ppc/mmu-hash64.c:    ppc_slb_t *slb = &env->slb[slot];
target-ppc/mmu-hash64.c:    if (rb & (0x1000 - env->slb_nr)) {
target-ppc/mmu-hash64.c:    if ((rs & SLB_VSID_B) && !(env->mmu_model & POWERPC_MMU_1TSEG)) {
target-ppc/mmu-hash64.c:    ppc_slb_t *slb = &env->slb[slot];
target-ppc/mmu-hash64.c:    if (slot >= env->slb_nr) {
target-ppc/mmu-hash64.c:    ppc_slb_t *slb = &env->slb[slot];
target-ppc/mmu-hash64.c:    if (slot >= env->slb_nr) {
target-ppc/mmu-hash64.c:    if (!(env->mmu_model & POWERPC_MMU_AMR)) {
target-ppc/mmu-hash64.c:    amrbits = (env->spr[SPR_AMR] >> 2*(31 - key)) & 0x3;
target-ppc/mmu-hash64.c:    /*         env->spr[SPR_AMR]); */
target-ppc/mmu-hash64.c:    pte_index = (hash & env->htab_mask) * HPTES_PER_GROUP;
target-ppc/mmu-hash64.c:            env->htab_base, env->htab_mask, hash);
target-ppc/mmu-hash64.c:            env->htab_base, env->htab_mask, vsid, ptem,  hash);
target-ppc/mmu-hash64.c:                " hash=" TARGET_FMT_plx "\n", env->htab_base,
target-ppc/mmu-hash64.c:                env->htab_mask, vsid, ptem, ~hash);
target-ppc/mmu-hash64.c:            env->error_code = 0;
target-ppc/mmu-hash64.c:            env->error_code = 0;
target-ppc/mmu-hash64.c:            env->spr[SPR_DAR] = eaddr;
target-ppc/mmu-hash64.c:        env->error_code = 0x10000000;
target-ppc/mmu-hash64.c:            env->error_code = 0x40000000;
target-ppc/mmu-hash64.c:            env->error_code = 0;
target-ppc/mmu-hash64.c:            env->spr[SPR_DAR] = eaddr;
target-ppc/mmu-hash64.c:                env->spr[SPR_DSISR] = 0x42000000;
target-ppc/mmu-hash64.c:                env->spr[SPR_DSISR] = 0x40000000;
target-ppc/mmu-hash64.c:            env->error_code = 0x08000000;
target-ppc/mmu-hash64.c:            env->error_code = 0;
target-ppc/mmu-hash64.c:            env->spr[SPR_DAR] = eaddr;
target-ppc/mmu-hash64.c:            env->spr[SPR_DSISR] = dsisr;
target-ppc/mmu-hash64.c:    if (env->external_htab) {
target-ppc/mmu-hash64.c:        stq_p(env->external_htab + pte_index, pte0);
target-ppc/mmu-hash64.c:        stq_p(env->external_htab + pte_index + HASH_PTE_SIZE_64/2, pte1);
target-ppc/mmu-hash64.c:        stq_phys(cs->as, env->htab_base + pte_index, pte0);
target-ppc/mmu-hash64.c:        stq_phys(cs->as, env->htab_base + pte_index + HASH_PTE_SIZE_64/2, pte1);
target-ppc/translate_init.c:    env->vscr = val;
target-ppc/translate_init.c:    set_float_rounding_mode(float_round_nearest_even, &env->vec_status);
target-ppc/translate_init.c:    set_flush_to_zero(vscr_nj, &env->vec_status);
target-ppc/translate_init.c:    spr = &env->spr_cb[num];
target-ppc/translate_init.c:    if (spr->name != NULL ||env-> spr[num] != 0x00000000 ||
target-ppc/translate_init.c:    env->spr[num] = spr->default_value = initial_value;
target-ppc/translate_init.c:    env->nb_BATs += 4;
target-ppc/translate_init.c:    env->nb_BATs += 4;
target-ppc/translate_init.c:    env->nb_tlb = nb_tlbs;
target-ppc/translate_init.c:    env->nb_ways = nb_ways;
target-ppc/translate_init.c:    env->id_tlbs = 1;
target-ppc/translate_init.c:    env->tlb_type = TLB_6XX;
target-ppc/translate_init.c:    env->nb_BATs = 4;
target-ppc/translate_init.c:    env->nb_tlb = nb_tlbs;
target-ppc/translate_init.c:    env->nb_ways = nb_ways;
target-ppc/translate_init.c:    env->id_tlbs = 1;
target-ppc/translate_init.c:    env->tlb_type = TLB_6XX;
target-ppc/translate_init.c:        if (i == 2 && (mas_mask & (1 << i)) && (env->insns_flags & PPC_64B)) {
target-ppc/translate_init.c:    if (env->nb_pids > 1) {
target-ppc/translate_init.c:    if (env->nb_pids > 2) {
target-ppc/translate_init.c:    switch (env->nb_ways) {
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_CRITICAL] = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PIT]      = 0x00001000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FIT]      = 0x00001010;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_WDT]      = 0x00001020;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DEBUG]    = 0x00002000;
target-ppc/translate_init.c:    env->ivor_mask = 0x0000FFF0UL;
target-ppc/translate_init.c:    env->ivpr_mask = 0xFFFF0000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0xFFFFFFFCUL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_CRITICAL] = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PIT]      = 0x00001000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FIT]      = 0x00001010;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_WDT]      = 0x00001020;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DTLB]     = 0x00001100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ITLB]     = 0x00001200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DEBUG]    = 0x00002000;
target-ppc/translate_init.c:    env->ivor_mask = 0x0000FFF0UL;
target-ppc/translate_init.c:    env->ivpr_mask = 0xFFFF0000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0xFFFFFFFCUL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPA]      = 0x00000E00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EMUL]     = 0x00001000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DABR]     = 0x00001C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MEXTBR]   = 0x00001E00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_NMEXTBR]  = 0x00001F00;
target-ppc/translate_init.c:    env->ivor_mask = 0x0000FFF0UL;
target-ppc/translate_init.c:    env->ivpr_mask = 0xFFFF0000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0x00000100UL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPA]      = 0x00000E00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EMUL]     = 0x00001000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ITLB]     = 0x00001100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DTLB]     = 0x00001200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ITLBE]    = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DTLBE]    = 0x00001400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DABR]     = 0x00001C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MEXTBR]   = 0x00001E00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_NMEXTBR]  = 0x00001F00;
target-ppc/translate_init.c:    env->ivor_mask = 0x0000FFF0UL;
target-ppc/translate_init.c:    env->ivpr_mask = 0xFFFF0000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0x00000100UL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_CRITICAL] = 0x00000A00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IFTLB]    = 0x00001000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DLTLB]    = 0x00001100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSTLB]    = 0x00001200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;
target-ppc/translate_init.c:    env->hreset_vector = 0x00000100UL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000FFC;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_CRITICAL] = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_APU]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FIT]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_WDT]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DTLB]     = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ITLB]     = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DEBUG]    = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SPEU]     = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EFPDI]    = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EFPRI]    = 0x00000000;
target-ppc/translate_init.c:    env->ivor_mask = 0x0000FFF7UL;
target-ppc/translate_init.c:    env->ivpr_mask = ivpr_mask;
target-ppc/translate_init.c:    env->hreset_vector = 0xFFFFFFFCUL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_CRITICAL] = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_APU]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FIT]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_WDT]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DTLB]     = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ITLB]     = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DEBUG]    = 0x00000000;
target-ppc/translate_init.c:    env->ivor_mask = 0x0000FFE0UL;
target-ppc/translate_init.c:    env->ivpr_mask = 0xFFFF0000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0xFFFFFFFCUL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IO]       = 0x00000A00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RUNM]     = 0x00002000;
target-ppc/translate_init.c:    env->hreset_vector = 0x00000100UL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IFTLB]    = 0x00001000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DLTLB]    = 0x00001100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSTLB]    = 0x00001200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_WDT]      = 0x00001500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EMUL]     = 0x00001600;
target-ppc/translate_init.c:    env->hreset_vector = 0x00000100UL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IFTLB]    = 0x00001000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DLTLB]    = 0x00001100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSTLB]    = 0x00001200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;
target-ppc/translate_init.c:    env->hreset_vector = 0x00000100UL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;
target-ppc/translate_init.c:    env->hreset_vector = 0x00000100UL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_THERM]    = 0x00001700;
target-ppc/translate_init.c:    env->hreset_vector = 0x00000100UL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;
target-ppc/translate_init.c:    env->hreset_vector = 0x00000100UL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_THERM]    = 0x00001700;
target-ppc/translate_init.c:    env->hreset_vector = 0x00000100UL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IFTLB]    = 0x00001000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DLTLB]    = 0x00001100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSTLB]    = 0x00001200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_THERM]    = 0x00001700;
target-ppc/translate_init.c:    env->hreset_vector = 0x00000100UL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_VPU]      = 0x00000F20;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_VPUA]     = 0x00001600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_THERM]    = 0x00001700;
target-ppc/translate_init.c:    env->hreset_vector = 0x00000100UL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_VPU]      = 0x00000F20;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IFTLB]    = 0x00001000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DLTLB]    = 0x00001100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSTLB]    = 0x00001200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_VPUA]     = 0x00001600;
target-ppc/translate_init.c:    env->hreset_vector = 0x00000100UL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSEG]     = 0x00000380;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISEG]     = 0x00000480;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_HDECR]    = 0x00000980;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_VPU]      = 0x00000F20;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MAINT]    = 0x00001600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_VPUA]     = 0x00001700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_THERM]    = 0x00001800;
target-ppc/translate_init.c:    env->hreset_vector = 0x0000000000000100ULL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSEG]     = 0x00000380;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISEG]     = 0x00000480;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_HDECR]    = 0x00000980;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_VPU]      = 0x00000F20;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_VSXU]     = 0x00000F40;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FU]       = 0x00000F60;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MAINT]    = 0x00001600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_VPUA]     = 0x00001700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_THERM]    = 0x00001800;
target-ppc/translate_init.c:    env->hreset_vector = 0x0000000000000100ULL;
target-ppc/translate_init.c:    if (env->spr[SPR_HID0] & 0x00E00000)
target-ppc/translate_init.c:    if (env->spr[SPR_HID0] & 0x00600000)
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_pids = 3;
target-ppc/translate_init.c:    env->nb_ways = 2;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:        cpu_abort(CPU(cpu), "Unknown CPU: " TARGET_FMT_lx "\n", env->spr[SPR_PVR]);
target-ppc/translate_init.c:        env->dcache_line_size = 32;
target-ppc/translate_init.c:        env->icache_line_size = 32;
target-ppc/translate_init.c:        env->dcache_line_size = 64;
target-ppc/translate_init.c:        env->icache_line_size = 64;
target-ppc/translate_init.c:        cpu_abort(CPU(cpu), "Unknown CPU: " TARGET_FMT_lx "\n", env->spr[SPR_PVR]);
target-ppc/translate_init.c:    env->nb_tlb = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_MAS;
target-ppc/translate_init.c:        env->nb_tlb += booke206_tlb_size(env, i);
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 64;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    if (env->spr[SPR_HID0] & (HID0_DEEPNAP | HID0_DOZE | HID0_NAP)) {
target-ppc/translate_init.c:    if (!(env->insns_flags & PPC_ALTIVEC)) {
target-ppc/translate_init.c:        env->slb_nr = 64;
target-ppc/translate_init.c:        env->slb_nr = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 128;
target-ppc/translate_init.c:    env->icache_line_size = 128;
target-ppc/translate_init.c:    env->irq_inputs = NULL;
target-ppc/translate_init.c:        env->excp_vectors[i] = (target_ulong)(-1ULL);
target-ppc/translate_init.c:    env->ivor_mask = 0x00000000;
target-ppc/translate_init.c:    env->ivpr_mask = 0x00000000;
target-ppc/translate_init.c:    env->nb_BATs = 0;
target-ppc/translate_init.c:    env->nb_tlb = 0;
target-ppc/translate_init.c:    env->nb_ways = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_NONE;
target-ppc/translate_init.c:    if (env->msr_mask & (1 << 25)) {
target-ppc/translate_init.c:        switch (env->flags & (POWERPC_FLAG_SPE | POWERPC_FLAG_VRE)) {
target-ppc/translate_init.c:    } else if (env->flags & (POWERPC_FLAG_SPE | POWERPC_FLAG_VRE)) {
target-ppc/translate_init.c:    if (env->msr_mask & (1 << 17)) {
target-ppc/translate_init.c:        switch (env->flags & (POWERPC_FLAG_TGPR | POWERPC_FLAG_CE)) {
target-ppc/translate_init.c:    } else if (env->flags & (POWERPC_FLAG_TGPR | POWERPC_FLAG_CE)) {
target-ppc/translate_init.c:    if (env->msr_mask & (1 << 10)) {
target-ppc/translate_init.c:        switch (env->flags & (POWERPC_FLAG_SE | POWERPC_FLAG_DWE |
target-ppc/translate_init.c:    } else if (env->flags & (POWERPC_FLAG_SE | POWERPC_FLAG_DWE |
target-ppc/translate_init.c:    if (env->msr_mask & (1 << 9)) {
target-ppc/translate_init.c:        switch (env->flags & (POWERPC_FLAG_BE | POWERPC_FLAG_DE)) {
target-ppc/translate_init.c:    } else if (env->flags & (POWERPC_FLAG_BE | POWERPC_FLAG_DE)) {
target-ppc/translate_init.c:    if (env->msr_mask & (1 << 2)) {
target-ppc/translate_init.c:        switch (env->flags & (POWERPC_FLAG_PX | POWERPC_FLAG_PMM)) {
target-ppc/translate_init.c:    } else if (env->flags & (POWERPC_FLAG_PX | POWERPC_FLAG_PMM)) {
target-ppc/translate_init.c:    if ((env->flags & (POWERPC_FLAG_RTC_CLK | POWERPC_FLAG_BUS_CLK)) == 0) {
target-ppc/translate_init.c:    if (env->nb_tlb != 0) {
target-ppc/translate_init.c:        int nb_tlb = env->nb_tlb;
target-ppc/translate_init.c:        if (env->id_tlbs != 0)
target-ppc/translate_init.c:        switch (env->tlb_type) {
target-ppc/translate_init.c:            env->tlb.tlb6 = g_malloc0(nb_tlb * sizeof(ppc6xx_tlb_t));
target-ppc/translate_init.c:            env->tlb.tlbe = g_malloc0(nb_tlb * sizeof(ppcemb_tlb_t));
target-ppc/translate_init.c:            env->tlb.tlbm = g_malloc0(nb_tlb * sizeof(ppcmas_tlb_t));
target-ppc/translate_init.c:        env->tlb_per_way = env->nb_tlb / env->nb_ways;
target-ppc/translate_init.c:    if (env->irq_inputs == NULL) {
target-ppc/translate_init.c:    if (env->check_pow == NULL) {
target-ppc/translate_init.c:            spr = &env->spr_cb[n];
target-ppc/translate_init.c:    fill_new_table(env->opcodes, 0x40);
target-ppc/translate_init.c:            if (register_insn(env->opcodes, opc) < 0) {
target-ppc/translate_init.c:    fix_opcode_tables(env->opcodes);
target-ppc/translate_init.c:        table = env->opcodes;
target-ppc/translate_init.c:                table = env->opcodes;
target-ppc/translate_init.c:                handler = env->opcodes[opc1];
target-ppc/translate_init.c:        stfq_p(mem_buf, env->fpr[n]);
target-ppc/translate_init.c:        stl_p(mem_buf, env->fpscr);
target-ppc/translate_init.c:        env->fpr[n] = ldfq_p(mem_buf);
target-ppc/translate_init.c:        stq_p(mem_buf, env->avr[n].u64[0]);
target-ppc/translate_init.c:        stq_p(mem_buf+8, env->avr[n].u64[1]);
target-ppc/translate_init.c:        stq_p(mem_buf, env->avr[n].u64[1]);
target-ppc/translate_init.c:        stq_p(mem_buf+8, env->avr[n].u64[0]);
target-ppc/translate_init.c:        stl_p(mem_buf, env->vscr);
target-ppc/translate_init.c:        stl_p(mem_buf, (uint32_t)env->spr[SPR_VRSAVE]);
target-ppc/translate_init.c:        env->avr[n].u64[0] = ldq_p(mem_buf);
target-ppc/translate_init.c:        env->avr[n].u64[1] = ldq_p(mem_buf+8);
target-ppc/translate_init.c:        env->avr[n].u64[1] = ldq_p(mem_buf);
target-ppc/translate_init.c:        env->avr[n].u64[0] = ldq_p(mem_buf+8);
target-ppc/translate_init.c:        env->vscr = ldl_p(mem_buf);
target-ppc/translate_init.c:        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);
target-ppc/translate_init.c:        stl_p(mem_buf, env->gpr[n] >> 32);
target-ppc/translate_init.c:        stl_p(mem_buf, env->gprh[n]);
target-ppc/translate_init.c:        stq_p(mem_buf, env->spe_acc);
target-ppc/translate_init.c:        stl_p(mem_buf, env->spe_fscr);
target-ppc/translate_init.c:        target_ulong lo = (uint32_t)env->gpr[n];
target-ppc/translate_init.c:        env->gpr[n] = lo | hi;
target-ppc/translate_init.c:        env->gprh[n] = ldl_p(mem_buf);
target-ppc/translate_init.c:        env->spe_acc = ldq_p(mem_buf);
target-ppc/translate_init.c:        env->spe_fscr = ldl_p(mem_buf);
target-ppc/translate_init.c:    if ((env->insns_flags & ~PPC_TCG_INSNS)
target-ppc/translate_init.c:        || (env->insns_flags2 & ~PPC_TCG_INSNS2)) {
target-ppc/translate_init.c:                env->insns_flags & ~PPC_TCG_INSNS,
target-ppc/translate_init.c:                env->insns_flags2 & ~PPC_TCG_INSNS2);
target-ppc/translate_init.c:    env->insns_flags &= PPC_TCG_INSNS;
target-ppc/translate_init.c:    env->insns_flags2 &= PPC_TCG_INSNS2;
target-ppc/translate_init.c:        switch (env->mmu_model) {
target-ppc/translate_init.c:        switch (env->excp_model) {
target-ppc/translate_init.c:        switch (env->bus_model) {
target-ppc/translate_init.c:        if (env->tlb.tlb6) {
target-ppc/translate_init.c:                   env->nb_tlb, env->id_tlbs ? "splitted" : "merged",
target-ppc/translate_init.c:                   env->nb_ways);
target-ppc/translate_init.c:        if (env->flags & POWERPC_FLAG_SPE)
target-ppc/translate_init.c:        else if (env->flags & POWERPC_FLAG_VRE)
target-ppc/translate_init.c:        if (env->flags & POWERPC_FLAG_TGPR)
target-ppc/translate_init.c:        else if (env->flags & POWERPC_FLAG_CE)
target-ppc/translate_init.c:        if (env->flags & POWERPC_FLAG_SE)
target-ppc/translate_init.c:        else if (env->flags & POWERPC_FLAG_DWE)
target-ppc/translate_init.c:        else if (env->flags & POWERPC_FLAG_UBLE)
target-ppc/translate_init.c:        if (env->flags & POWERPC_FLAG_BE)
target-ppc/translate_init.c:        else if (env->flags & POWERPC_FLAG_DE)
target-ppc/translate_init.c:        if (env->flags & POWERPC_FLAG_PX)
target-ppc/translate_init.c:        else if (env->flags & POWERPC_FLAG_PMM)
target-ppc/translate_init.c:        if (env->flags == POWERPC_FLAG_NONE)
target-ppc/translate_init.c:               env->flags & POWERPC_FLAG_RTC_CLK ? "RTC clock" : "bus clock");
target-ppc/translate_init.c:        if (env->opcodes[i] != &invalid_handler) {
target-ppc/translate_init.c:            g_free(env->opcodes[i]);
target-ppc/translate_init.c:        env->spr[SPR_PCR] = PCR_COMPAT_2_05;
target-ppc/translate_init.c:        env->spr[SPR_PCR] = PCR_COMPAT_2_06;
target-ppc/translate_init.c:        env->spr[SPR_PCR] = PCR_COMPAT_2_06;
target-ppc/translate_init.c:        env->spr[SPR_PCR] = 0;
target-ppc/translate_init.c:    if (!((env->msr_mask >> MSR_LE) & 1)) {
target-ppc/translate_init.c:    if (env->mmu_model & POWERPC_MMU_64) {
target-ppc/translate_init.c:        env->msr |= (1ULL << MSR_SF);
target-ppc/translate_init.c:    env->nip = env->hreset_vector | env->excp_prefix;
target-ppc/translate_init.c:    if (env->mmu_model != POWERPC_MMU_REAL) {
target-ppc/translate_init.c:    env->reserve_addr = (target_ulong)-1ULL;
target-ppc/translate_init.c:    env->pending_interrupts = 0;
target-ppc/translate_init.c:    env->error_code = 0;
target-ppc/translate_init.c:    env->vpa_addr = 0;
target-ppc/translate_init.c:    env->slb_shadow_addr = 0;
target-ppc/translate_init.c:    env->slb_shadow_size = 0;
target-ppc/translate_init.c:    env->dtl_addr = 0;
target-ppc/translate_init.c:    env->dtl_size = 0;
target-ppc/translate_init.c:    for (i = 0; i < ARRAY_SIZE(env->spr_cb); i++) {
target-ppc/translate_init.c:        ppc_spr_t *spr = &env->spr_cb[i];
target-ppc/translate_init.c:        env->spr[i] = spr->default_value;
target-ppc/translate_init.c:    env->msr_mask = pcc->msr_mask;
target-ppc/translate_init.c:    env->mmu_model = pcc->mmu_model;
target-ppc/translate_init.c:    env->excp_model = pcc->excp_model;
target-ppc/translate_init.c:    env->bus_model = pcc->bus_model;
target-ppc/translate_init.c:    env->insns_flags = pcc->insns_flags;
target-ppc/translate_init.c:    env->insns_flags2 = pcc->insns_flags2;
target-ppc/translate_init.c:    env->flags = pcc->flags;
target-ppc/translate_init.c:    env->bfd_mach = pcc->bfd_mach;
target-ppc/translate_init.c:    env->check_pow = pcc->check_pow;
target-ppc/translate_init.c:        env->sps = *pcc->sps;
target-ppc/translate_init.c:    } else if (env->mmu_model & POWERPC_MMU_64) {
target-ppc/translate_init.c:        env->sps = defsps;
target-ppc/int_helper.c:        env->ov = 0;
target-ppc/int_helper.c:        env->so = env->ov = 1;
target-ppc/int_helper.c:            env->so = env->ov = 1;
target-ppc/int_helper.c:            env->ov = 0;
target-ppc/int_helper.c:            env->so = env->ov = 1;
target-ppc/int_helper.c:            env->ov = 0;
target-ppc/int_helper.c:            env->so = env->ov = 1;
target-ppc/int_helper.c:            env->ov = 0;
target-ppc/int_helper.c:            env->so = env->ov = 1;
target-ppc/int_helper.c:            env->ov = 0;
target-ppc/int_helper.c:                env->ca = 0;
target-ppc/int_helper.c:                env->ca = 1;
target-ppc/int_helper.c:            env->ca = 0;
target-ppc/int_helper.c:        env->ca = (ret != 0);
target-ppc/int_helper.c:                env->ca = 0;
target-ppc/int_helper.c:                env->ca = 1;
target-ppc/int_helper.c:            env->ca = 0;
target-ppc/int_helper.c:        env->ca = (ret != 0);
target-ppc/int_helper.c:    uint64_t tmp = (uint64_t)arg1 << 32 | env->spr[SPR_MQ];
target-ppc/int_helper.c:        env->spr[SPR_MQ] = 0;
target-ppc/int_helper.c:        env->spr[SPR_MQ] = tmp % arg2;
target-ppc/int_helper.c:    uint64_t tmp = (uint64_t)arg1 << 32 | env->spr[SPR_MQ];
target-ppc/int_helper.c:        env->so = env->ov = 1;
target-ppc/int_helper.c:        env->spr[SPR_MQ] = 0;
target-ppc/int_helper.c:        env->spr[SPR_MQ] = tmp % arg2;
target-ppc/int_helper.c:            env->so = env->ov = 1;
target-ppc/int_helper.c:            env->ov = 0;
target-ppc/int_helper.c:        env->spr[SPR_MQ] = 0;
target-ppc/int_helper.c:        env->spr[SPR_MQ] = (int32_t)arg1 % (int32_t)arg2;
target-ppc/int_helper.c:        env->so = env->ov = 1;
target-ppc/int_helper.c:        env->spr[SPR_MQ] = 0;
target-ppc/int_helper.c:        env->ov = 0;
target-ppc/int_helper.c:        env->spr[SPR_MQ] = (int32_t)arg1 % (int32_t)arg2;
target-ppc/int_helper.c:    env->vscr = r->u32[3];
target-ppc/int_helper.c:    env->vscr = r->u32[0];
target-ppc/int_helper.c:    set_flush_to_zero(vscr_nj, &env->vec_status);
target-ppc/int_helper.c:            r->f[i] = func(a->f[i], b->f[i], &env->vec_status);         \
target-ppc/int_helper.c:                                     type, &env->vec_status);           \
target-ppc/int_helper.c:            env->vscr |= (1 << VSCR_SAT);                               \
target-ppc/int_helper.c:            float32 t = cvt(b->element[i], &env->vec_status);           \
target-ppc/int_helper.c:            r->f[i] = float32_scalbn(t, -uim, &env->vec_status);        \
target-ppc/int_helper.c:            env->crf[6] = ((all != 0) << 3) | ((none == 0) << 1);       \
target-ppc/int_helper.c:                                            &env->vec_status);          \
target-ppc/int_helper.c:            env->crf[6] = ((all != 0) << 3) | ((none == 0) << 1);       \
target-ppc/int_helper.c:        int le_rel = float32_compare_quiet(a->f[i], b->f[i], &env->vec_status);
target-ppc/int_helper.c:            int ge_rel = float32_compare_quiet(a->f[i], bneg, &env->vec_status);
target-ppc/int_helper.c:        env->crf[6] = (all_in == 0) << 1;
target-ppc/int_helper.c:        float_status s = env->vec_status;                               \
target-ppc/int_helper.c:            env->vscr |= (1 << VSCR_SAT);                               \
target-ppc/int_helper.c:        env->vscr |= (1 << VSCR_SAT);
target-ppc/int_helper.c:        env->vscr |= (1 << VSCR_SAT);
target-ppc/int_helper.c:        env->vscr |= (1 << VSCR_SAT);
target-ppc/int_helper.c:        env->vscr |= (1 << VSCR_SAT);
target-ppc/int_helper.c:            env->vscr |= (1 << VSCR_SAT);                               \
target-ppc/int_helper.c:        r->f[i] = float32_div(float32_one, b->f[i], &env->vec_status);
target-ppc/int_helper.c:        float_status s = env->vec_status;                       \
target-ppc/int_helper.c:        float32 t = float32_sqrt(b->f[i], &env->vec_status);
target-ppc/int_helper.c:        r->f[i] = float32_div(float32_one, t, &env->vec_status);
target-ppc/int_helper.c:        r->f[i] = float32_exp2(b->f[i], &env->vec_status);
target-ppc/int_helper.c:        r->f[i] = float32_log2(b->f[i], &env->vec_status);
target-ppc/int_helper.c:        env->vscr |= (1 << VSCR_SAT);
target-ppc/int_helper.c:        env->vscr |= (1 << VSCR_SAT);
target-ppc/int_helper.c:        env->vscr |= (1 << VSCR_SAT);
target-ppc/int_helper.c:        env->vscr |= (1 << VSCR_SAT);
target-ppc/int_helper.c:        env->vscr |= (1 << VSCR_SAT);
target-ppc/int_helper.c:                env->crf[0] = 0x4;
target-ppc/int_helper.c:                env->crf[0] = 0x8;
target-ppc/int_helper.c:        env->crf[0] = 0x2;
target-ppc/int_helper.c:    env->xer = (env->xer & ~0x7F) | i;
target-ppc/int_helper.c:        env->crf[0] |= xer_so;
target-ppc/user_only_helper.c:        env->spr[SPR_DAR] = address;
target-ppc/user_only_helper.c:        env->spr[SPR_DSISR] = error_code;
target-ppc/user_only_helper.c:    env->error_code = error_code;
cputlb.c:    memset(env->tlb_table, -1, sizeof(env->tlb_table));
cputlb.c:    env->tlb_flush_addr = -1;
cputlb.c:    env->tlb_flush_mask = 0;
cputlb.c:    if ((addr & env->tlb_flush_mask) == env->tlb_flush_addr) {
cputlb.c:               env->tlb_flush_addr, env->tlb_flush_mask);
cputlb.c:        tlb_flush_entry(&env->tlb_table[mmu_idx][i], addr);
cputlb.c:                tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i],
cputlb.c:        tlb_set_dirty1(&env->tlb_table[mmu_idx][i], vaddr);
cputlb.c:    if (env->tlb_flush_addr == (target_ulong)-1) {
cputlb.c:        env->tlb_flush_addr = vaddr & mask;
cputlb.c:        env->tlb_flush_mask = mask;
cputlb.c:    mask &= env->tlb_flush_mask;
cputlb.c:    while (((env->tlb_flush_addr ^ vaddr) & mask) != 0) {
cputlb.c:    env->tlb_flush_addr &= mask;
cputlb.c:    env->tlb_flush_mask = mask;
cputlb.c:    env->iotlb[mmu_idx][index] = iotlb - vaddr;
cputlb.c:    te = &env->tlb_table[mmu_idx][index];
target-alpha/gdbstub.c:        val = env->ir[n];
target-alpha/gdbstub.c:        d.d = env->fir[n - 32];
target-alpha/gdbstub.c:        val = env->pc;
target-alpha/gdbstub.c:        val = env->unique;
target-alpha/gdbstub.c:        env->ir[n] = tmp;
target-alpha/gdbstub.c:        env->fir[n - 32] = d.d;
target-alpha/gdbstub.c:        env->pc = tmp;
target-alpha/gdbstub.c:        env->unique = tmp;
target-alpha/mem_helper.c:    env->lock_addr = p;
target-alpha/mem_helper.c:    return env->lock_value = (int32_t)ldl_phys(cs->as, p);
target-alpha/mem_helper.c:    env->lock_addr = p;
target-alpha/mem_helper.c:    return env->lock_value = ldq_phys(cs->as, p);
target-alpha/mem_helper.c:    if (p == env->lock_addr) {
target-alpha/mem_helper.c:        if (old == (int32_t)env->lock_value) {
target-alpha/mem_helper.c:    env->lock_addr = -1;
target-alpha/mem_helper.c:    if (p == env->lock_addr) {
target-alpha/mem_helper.c:        if (old == env->lock_value) {
target-alpha/mem_helper.c:    env->lock_addr = -1;
target-alpha/mem_helper.c:    pc = env->pc;
target-alpha/mem_helper.c:    env->trap_arg0 = addr;
target-alpha/mem_helper.c:    env->trap_arg1 = insn >> 26;                /* opcode */
target-alpha/mem_helper.c:    env->trap_arg2 = (insn >> 21) & 31;         /* dest regno */
target-alpha/mem_helper.c:    env->error_code = 0;
target-alpha/mem_helper.c:    env->trap_arg0 = addr;
target-alpha/mem_helper.c:    env->trap_arg1 = is_write ? 1 : 0;
target-alpha/translate.c:    ctx.implver = env->implver;
target-alpha/translate.c:    env->pc = tcg_ctx.gen_opc_pc[pc_pos];
target-alpha/helper.c:    t = env->fpcr_exc_status;
target-alpha/helper.c:    t = env->fpcr_exc_mask;
target-alpha/helper.c:    switch (env->fpcr_dyn_round) {
target-alpha/helper.c:    if (env->fp_status.flush_inputs_to_zero) {
target-alpha/helper.c:    if (env->fpcr_dnod) {
target-alpha/helper.c:    if (env->fpcr_undz) {
target-alpha/helper.c:    env->fpcr_exc_status = t;
target-alpha/helper.c:    env->fpcr_exc_mask = t;
target-alpha/helper.c:    env->fpcr_dyn_round = t;
target-alpha/helper.c:    env->fpcr_dnod = (val & FPCR_DNOD) != 0;
target-alpha/helper.c:    env->fpcr_undz = (val & FPCR_UNDZ) != 0;
target-alpha/helper.c:    env->fpcr_flush_to_zero = env->fpcr_dnod & env->fpcr_undz;
target-alpha/helper.c:    env->fp_status.flush_inputs_to_zero = (val & FPCR_DNZ) != 0;
target-alpha/helper.c:    i0 = env->ir[8];
target-alpha/helper.c:    i1 = env->ir[9];
target-alpha/helper.c:    i2 = env->ir[10];
target-alpha/helper.c:    i3 = env->ir[11];
target-alpha/helper.c:    i4 = env->ir[12];
target-alpha/helper.c:    i5 = env->ir[13];
target-alpha/helper.c:    i6 = env->ir[14];
target-alpha/helper.c:    i7 = env->ir[25];
target-alpha/helper.c:    env->ir[8]  = env->shadow[0];
target-alpha/helper.c:    env->ir[9]  = env->shadow[1];
target-alpha/helper.c:    env->ir[10] = env->shadow[2];
target-alpha/helper.c:    env->ir[11] = env->shadow[3];
target-alpha/helper.c:    env->ir[12] = env->shadow[4];
target-alpha/helper.c:    env->ir[13] = env->shadow[5];
target-alpha/helper.c:    env->ir[14] = env->shadow[6];
target-alpha/helper.c:    env->ir[25] = env->shadow[7];
target-alpha/helper.c:    env->shadow[0] = i0;
target-alpha/helper.c:    env->shadow[1] = i1;
target-alpha/helper.c:    env->shadow[2] = i2;
target-alpha/helper.c:    env->shadow[3] = i3;
target-alpha/helper.c:    env->shadow[4] = i4;
target-alpha/helper.c:    env->shadow[5] = i5;
target-alpha/helper.c:    env->shadow[6] = i6;
target-alpha/helper.c:    env->shadow[7] = i7;
target-alpha/helper.c:    pt = env->ptbr;
target-alpha/helper.c:        env->trap_arg0 = addr;
target-alpha/helper.c:        env->trap_arg1 = fail;
target-alpha/helper.c:        env->trap_arg2 = (rw == 2 ? -1 : rw);
target-alpha/helper.c:                 ++count, name, env->error_code, env->pc, env->ir[IR_SP]);
target-alpha/helper.c:        i = env->error_code;
target-alpha/helper.c:    env->exc_addr = env->pc | env->pal_mode;
target-alpha/helper.c:    env->pc = env->palbr + i;
target-alpha/helper.c:    if (!env->pal_mode) {
target-alpha/helper.c:        env->pal_mode = 1;
target-alpha/helper.c:                env->pc, env->ps);
target-alpha/helper.c:                    linux_reg_names[i], env->ir[i]);
target-alpha/helper.c:                env->lock_addr, env->lock_value);
target-alpha/helper.c:                    *((uint64_t *)(&env->fir[i])));
target-alpha/helper.c:    env->error_code = error;
target-alpha/helper.c:    env->error_code = error;
target-alpha/helper.c:    env->trap_arg0 = exc;
target-alpha/helper.c:    env->trap_arg1 = mask;
target-alpha/sys_helper.c:    return (((uint64_t)env->pcc_ofs << 32)
target-alpha/sys_helper.c:    env->pc = a & ~3;
target-alpha/sys_helper.c:    env->intr_flag = 0;
target-alpha/sys_helper.c:    env->lock_addr = -1;
target-alpha/sys_helper.c:        env->pal_mode = 0;
target-alpha/sys_helper.c:    int pal_mode = env->pal_mode;
target-alpha/sys_helper.c:    env->exc_addr = pc | pal_mode;
target-alpha/sys_helper.c:    env->pc = env->palbr + entry_ofs;
target-alpha/sys_helper.c:        env->pal_mode = 1;
target-alpha/sys_helper.c:        env->alarm_expire = expire;
target-alpha/cpu.h:    if (env->pal_mode) {
target-alpha/cpu.h:    } else if (env->ps & PS_USER_MODE) {
target-alpha/cpu.h:    *pc = env->pc;
target-alpha/cpu.h:    if (env->pal_mode) {
target-alpha/cpu.h:        flags = env->ps & PS_USER_MODE;
target-alpha/cpu.h:    if (env->fen) {
target-alpha/cpu.h:    flags |= env->amask << TB_FLAGS_AMASK_SHIFT;
target-alpha/fpu_helper.c:#define FP_STATUS (env->fp_status)
target-alpha/fpu_helper.c:        env->fpcr_exc_status |= exc;
target-alpha/fpu_helper.c:        exc &= ~env->fpcr_exc_mask;
target-alpha/fpu_helper.c:        if (frac != 0 && !env->fp_status.flush_inputs_to_zero) {
target-alpha/fpu_helper.c:        if (frac != 0 && !env->fp_status.flush_inputs_to_zero) {
target-alpha/cpu.c:    env->implver = IMPLVER_2106x;
target-alpha/cpu.c:    env->implver = IMPLVER_21164;
target-alpha/cpu.c:    env->amask |= AMASK_BWX;
target-alpha/cpu.c:    env->amask |= AMASK_MVI;
target-alpha/cpu.c:    env->implver = IMPLVER_21264;
target-alpha/cpu.c:    env->amask = AMASK_BWX | AMASK_FIX | AMASK_MVI | AMASK_TRAP;
target-alpha/cpu.c:    env->amask |= AMASK_CIX | AMASK_PREFETCH;
target-alpha/cpu.c:    env->ps = PS_USER_MODE;
target-alpha/cpu.c:    env->lock_addr = -1;
target-alpha/cpu.c:    env->fen = 1;
target-i386/gdbstub.c:        if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {
target-i386/gdbstub.c:            return gdb_get_reg64(mem_buf, env->regs[gpr_map[n]]);
target-i386/gdbstub.c:            return gdb_get_reg32(mem_buf, env->regs[gpr_map32[n]]);
target-i386/gdbstub.c:        memcpy(mem_buf, &env->fpregs[n - IDX_FP_REGS], 10);
target-i386/gdbstub.c:            (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK)) {
target-i386/gdbstub.c:            stq_p(mem_buf, env->xmm_regs[n].XMM_Q(0));
target-i386/gdbstub.c:            stq_p(mem_buf + 8, env->xmm_regs[n].XMM_Q(1));
target-i386/gdbstub.c:            if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {
target-i386/gdbstub.c:                return gdb_get_reg64(mem_buf, env->eip);
target-i386/gdbstub.c:                return gdb_get_reg32(mem_buf, env->eip);
target-i386/gdbstub.c:            return gdb_get_reg32(mem_buf, env->eflags);
target-i386/gdbstub.c:            return gdb_get_reg32(mem_buf, env->segs[R_CS].selector);
target-i386/gdbstub.c:            return gdb_get_reg32(mem_buf, env->segs[R_SS].selector);
target-i386/gdbstub.c:            return gdb_get_reg32(mem_buf, env->segs[R_DS].selector);
target-i386/gdbstub.c:            return gdb_get_reg32(mem_buf, env->segs[R_ES].selector);
target-i386/gdbstub.c:            return gdb_get_reg32(mem_buf, env->segs[R_FS].selector);
target-i386/gdbstub.c:            return gdb_get_reg32(mem_buf, env->segs[R_GS].selector);
target-i386/gdbstub.c:            return gdb_get_reg32(mem_buf, env->fpuc);
target-i386/gdbstub.c:            return gdb_get_reg32(mem_buf, (env->fpus & ~0x3800) |
target-i386/gdbstub.c:                                          (env->fpstt & 0x7) << 11);
target-i386/gdbstub.c:            return gdb_get_reg32(mem_buf, env->mxcsr);
target-i386/gdbstub.c:    if (selector != env->segs[sreg].selector) {
target-i386/gdbstub.c:        if (!(env->cr[0] & CR0_PE_MASK) || (env->eflags & VM_MASK)) {
target-i386/gdbstub.c:            int dpl = (env->eflags & VM_MASK) ? 3 : 0;
target-i386/gdbstub.c:        if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {
target-i386/gdbstub.c:            env->regs[gpr_map[n]] = ldtul_p(mem_buf);
target-i386/gdbstub.c:            env->regs[n] &= ~0xffffffffUL;
target-i386/gdbstub.c:            env->regs[n] |= (uint32_t)ldl_p(mem_buf);
target-i386/gdbstub.c:        memcpy(&env->fpregs[n - IDX_FP_REGS], mem_buf, 10);
target-i386/gdbstub.c:            (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK)) {
target-i386/gdbstub.c:            env->xmm_regs[n].XMM_Q(0) = ldq_p(mem_buf);
target-i386/gdbstub.c:            env->xmm_regs[n].XMM_Q(1) = ldq_p(mem_buf + 8);
target-i386/gdbstub.c:            if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {
target-i386/gdbstub.c:                env->eip = ldq_p(mem_buf);
target-i386/gdbstub.c:                env->eip &= ~0xffffffffUL;
target-i386/gdbstub.c:                env->eip |= (uint32_t)ldl_p(mem_buf);
target-i386/gdbstub.c:            env->eflags = ldl_p(mem_buf);
target-i386/gdbstub.c:            env->fpuc = ldl_p(mem_buf);
target-i386/gdbstub.c:            env->fpstt = (tmp >> 11) & 7;
target-i386/gdbstub.c:            env->fpus = tmp & ~0x3800;
Binary file target-i386/.mem_helper.c.swp matches
target-i386/shift_helper_template.h:        eflags = env->cc_src;
target-i386/shift_helper_template.h:        env->cc_src = (eflags & ~(CC_C | CC_O)) |
target-i386/shift_helper_template.h:        eflags = env->cc_src;
target-i386/shift_helper_template.h:        env->cc_src = (eflags & ~(CC_C | CC_O)) |
target-i386/mem_helper.c:    if (d == (((uint64_t)env->regs[R_EDX] << 32) | (uint32_t)env->regs[R_EAX])) {
target-i386/mem_helper.c:        cpu_stq_data(env, a0, ((uint64_t)env->regs[R_ECX] << 32) | (uint32_t)env->regs[R_EBX]);
target-i386/mem_helper.c:        env->regs[R_EDX] = (uint32_t)(d >> 32);
target-i386/mem_helper.c:        env->regs[R_EAX] = (uint32_t)d;
target-i386/mem_helper.c:    if (d0 == env->regs[R_EAX] && d1 == env->regs[R_EDX]) {
target-i386/mem_helper.c:        cpu_stq_data(env, a0, env->regs[R_EBX]);
target-i386/mem_helper.c:        cpu_stq_data(env, a0 + 8, env->regs[R_ECX]);
target-i386/mem_helper.c:        env->regs[R_EDX] = d1;
target-i386/mem_helper.c:        env->regs[R_EAX] = d0;
target-i386/mem_helper.c:    async_exit_t *async_exit_pointer = (async_exit_t*)env->regs[R_ECX];
target-i386/mem_helper.c:    //tcs_t **tcs_addr  =	(tcs_t**)&env->regs[R_EBX]; // double pointer ? originally no & pointer
target-i386/mem_helper.c:    tcs_t *tcs = (tcs_t *)env->regs[R_EBX]; // originally no uint32 cast - Also 64 -> 32 ?
target-i386/mem_helper.c:    //	uint64_t baseEPC = (uint64_t)(epc_t*)env->regs[R_EDX]; // originally no uint32 cast - 64 -> 32?
target-i386/mem_helper.c:    epcm_entry_t *epcm = (epcm_entry_t*)env->regs[R_EDI];
target-i386/mem_helper.c:    if (!(env->cr[4] & CR4_OSFXSR_MASK))
target-i386/mem_helper.c:    if (!(env->cr[4] & CR4_OSXSAVE_MASK))
target-i386/mem_helper.c:       uint64_t cr_tcs_la = env->regs[R_ECX];
target-i386/mem_helper.c:    async.rbp = env->regs[R_EBP];
target-i386/mem_helper.c:    async.rsp = env->regs[R_ESP];
target-i386/mem_helper.c:     *(async_exit_pointer++) = env->regs[R_EBP];
target-i386/mem_helper.c:     *(async_exit_pointer++) = env->regs[R_ESP];
target-i386/mem_helper.c:            env->regs[R_EAX],
target-i386/mem_helper.c:            env->regs[R_EBX],
target-i386/mem_helper.c:            env->regs[R_ECX],
target-i386/mem_helper.c:            env->regs[R_EDX]);
target-i386/mem_helper.c:    switch (env->regs[R_EAX]) {
target-i386/mem_helper.c:    pageinfo_t *pageInfo = (pageinfo_t *)env->regs[R_EBX];
target-i386/mem_helper.c:    secs_t *tmp_secs = (secs_t *)env->regs[R_ECX];
target-i386/mem_helper.c:    pageinfo_t *pageInfo = (pageinfo_t *)env->regs[R_EBX];
target-i386/mem_helper.c:    epc_t *destPage = (epc_t *)env->regs[R_ECX];
target-i386/mem_helper.c:    uint64_t *target_addr = (uint64_t *)env->regs[R_ECX];
target-i386/mem_helper.c:    epc_t *firstPage = (epc_t *)env->regs[R_EBX];
target-i386/mem_helper.c:            env->regs[R_EAX],
target-i386/mem_helper.c:            env->regs[R_EBX],
target-i386/mem_helper.c:            env->regs[R_ECX],
target-i386/mem_helper.c:            env->regs[R_EDX]);
target-i386/mem_helper.c:    switch (env->regs[R_EAX]) {
target-i386/mem_helper.c:        raise_exception_err(env, cs->exception_index, env->error_code);
target-i386/translate.c:        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)
target-i386/translate.c:        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)
target-i386/translate.c:    dc->cpuid_features = env->features[FEAT_1_EDX];
target-i386/translate.c:    dc->cpuid_ext_features = env->features[FEAT_1_ECX];
target-i386/translate.c:    dc->cpuid_ext2_features = env->features[FEAT_8000_0001_EDX];
target-i386/translate.c:    dc->cpuid_ext3_features = env->features[FEAT_8000_0001_ECX];
target-i386/translate.c:    dc->cpuid_7_0_ebx_features = env->features[FEAT_7_0_EBX];
target-i386/translate.c:    env->eip = tcg_ctx.gen_opc_pc[pc_pos] - tb->cs_base;
target-i386/translate.c:        env->cc_op = cc_op;
target-i386/kvm.c:    if ((env->mcg_cap & MCG_SER_P) && addr
target-i386/kvm.c:    if (!kvm_has_vcpu_events() && env->exception_injected == EXCP12_MCHK) {
target-i386/kvm.c:        unsigned int bank, bank_num = env->mcg_cap & 0xff;
target-i386/kvm.c:        env->exception_injected = -1;
target-i386/kvm.c:            if (env->mce_banks[bank * 4 + 1] & MCI_STATUS_VAL) {
target-i386/kvm.c:        mce.status = env->mce_banks[bank * 4 + 1];
target-i386/kvm.c:        mce.mcg_status = env->mcg_status;
target-i386/kvm.c:        mce.addr = env->mce_banks[bank * 4 + 2];
target-i386/kvm.c:        mce.misc = env->mce_banks[bank * 4 + 3];
target-i386/kvm.c:        env->tsc_valid = false;
target-i386/kvm.c:        c->eax = env->features[FEAT_KVM];
target-i386/kvm.c:    if (env->cpuid_xlevel2 > 0) {
target-i386/kvm.c:    if (((env->cpuid_version >> 8)&0xF) >= 6
target-i386/kvm.c:        && (env->features[FEAT_1_EDX] & (CPUID_MCE | CPUID_MCA)) ==
target-i386/kvm.c:        env->mcg_cap = mcg_cap;
target-i386/kvm.c:    if (r && env->tsc_khz) {
target-i386/kvm.c:        r = kvm_vcpu_ioctl(cs, KVM_SET_TSC_KHZ, env->tsc_khz);
target-i386/kvm.c:        env->kvm_xsave_buf = qemu_memalign(4096, sizeof(struct kvm_xsave));
target-i386/kvm.c:    if (env->features[FEAT_1_EDX] & CPUID_MTRR) {
target-i386/kvm.c:    env->exception_injected = -1;
target-i386/kvm.c:    env->interrupt_injected = -1;
target-i386/kvm.c:    env->xcr0 = 1;
target-i386/kvm.c:        env->mp_state = cpu_is_bsp(cpu) ? KVM_MP_STATE_RUNNABLE :
target-i386/kvm.c:        env->mp_state = KVM_MP_STATE_RUNNABLE;
target-i386/kvm.c:    if (env->mp_state == KVM_MP_STATE_UNINITIALIZED) {
target-i386/kvm.c:        env->mp_state = KVM_MP_STATE_INIT_RECEIVED;
target-i386/kvm.c:    kvm_getput_reg(&regs.rax, &env->regs[R_EAX], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.rbx, &env->regs[R_EBX], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.rcx, &env->regs[R_ECX], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.rdx, &env->regs[R_EDX], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.rsi, &env->regs[R_ESI], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.rdi, &env->regs[R_EDI], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.rsp, &env->regs[R_ESP], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.rbp, &env->regs[R_EBP], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.r8, &env->regs[8], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.r9, &env->regs[9], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.r10, &env->regs[10], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.r11, &env->regs[11], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.r12, &env->regs[12], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.r13, &env->regs[13], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.r14, &env->regs[14], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.r15, &env->regs[15], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.rflags, &env->eflags, set);
target-i386/kvm.c:    kvm_getput_reg(&regs.rip, &env->eip, set);
target-i386/kvm.c:    fpu.fsw = env->fpus & ~(7 << 11);
target-i386/kvm.c:    fpu.fsw |= (env->fpstt & 7) << 11;
target-i386/kvm.c:    fpu.fcw = env->fpuc;
target-i386/kvm.c:    fpu.last_opcode = env->fpop;
target-i386/kvm.c:    fpu.last_ip = env->fpip;
target-i386/kvm.c:    fpu.last_dp = env->fpdp;
target-i386/kvm.c:        fpu.ftwx |= (!env->fptags[i]) << i;
target-i386/kvm.c:    memcpy(fpu.fpr, env->fpregs, sizeof env->fpregs);
target-i386/kvm.c:    memcpy(fpu.xmm, env->xmm_regs, sizeof env->xmm_regs);
target-i386/kvm.c:    fpu.mxcsr = env->mxcsr;
target-i386/kvm.c:    struct kvm_xsave* xsave = env->kvm_xsave_buf;
target-i386/kvm.c:    swd = env->fpus & ~(7 << 11);
target-i386/kvm.c:    swd |= (env->fpstt & 7) << 11;
target-i386/kvm.c:    cwd = env->fpuc;
target-i386/kvm.c:        twd |= (!env->fptags[i]) << i;
target-i386/kvm.c:    xsave->region[XSAVE_FTW_FOP] = (uint32_t)(env->fpop << 16) + twd;
target-i386/kvm.c:    memcpy(&xsave->region[XSAVE_CWD_RIP], &env->fpip, sizeof(env->fpip));
target-i386/kvm.c:    memcpy(&xsave->region[XSAVE_CWD_RDP], &env->fpdp, sizeof(env->fpdp));
target-i386/kvm.c:    memcpy(&xsave->region[XSAVE_ST_SPACE], env->fpregs,
target-i386/kvm.c:            sizeof env->fpregs);
target-i386/kvm.c:    memcpy(&xsave->region[XSAVE_XMM_SPACE], env->xmm_regs,
target-i386/kvm.c:            sizeof env->xmm_regs);
target-i386/kvm.c:    xsave->region[XSAVE_MXCSR] = env->mxcsr;
target-i386/kvm.c:    *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV] = env->xstate_bv;
target-i386/kvm.c:    memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,
target-i386/kvm.c:            sizeof env->ymmh_regs);
target-i386/kvm.c:    memcpy(&xsave->region[XSAVE_BNDREGS], env->bnd_regs,
target-i386/kvm.c:            sizeof env->bnd_regs);
target-i386/kvm.c:    memcpy(&xsave->region[XSAVE_BNDCSR], &env->bndcs_regs,
target-i386/kvm.c:            sizeof(env->bndcs_regs));
target-i386/kvm.c:    xcrs.xcrs[0].value = env->xcr0;
target-i386/kvm.c:    if (env->interrupt_injected >= 0) {
target-i386/kvm.c:        sregs.interrupt_bitmap[env->interrupt_injected / 64] |=
target-i386/kvm.c:                (uint64_t)1 << (env->interrupt_injected % 64);
target-i386/kvm.c:    if ((env->eflags & VM_MASK)) {
target-i386/kvm.c:        set_v8086_seg(&sregs.cs, &env->segs[R_CS]);
target-i386/kvm.c:        set_v8086_seg(&sregs.ds, &env->segs[R_DS]);
target-i386/kvm.c:        set_v8086_seg(&sregs.es, &env->segs[R_ES]);
target-i386/kvm.c:        set_v8086_seg(&sregs.fs, &env->segs[R_FS]);
target-i386/kvm.c:        set_v8086_seg(&sregs.gs, &env->segs[R_GS]);
target-i386/kvm.c:        set_v8086_seg(&sregs.ss, &env->segs[R_SS]);
target-i386/kvm.c:        set_seg(&sregs.cs, &env->segs[R_CS]);
target-i386/kvm.c:        set_seg(&sregs.ds, &env->segs[R_DS]);
target-i386/kvm.c:        set_seg(&sregs.es, &env->segs[R_ES]);
target-i386/kvm.c:        set_seg(&sregs.fs, &env->segs[R_FS]);
target-i386/kvm.c:        set_seg(&sregs.gs, &env->segs[R_GS]);
target-i386/kvm.c:        set_seg(&sregs.ss, &env->segs[R_SS]);
target-i386/kvm.c:    set_seg(&sregs.tr, &env->tr);
target-i386/kvm.c:    set_seg(&sregs.ldt, &env->ldt);
target-i386/kvm.c:    sregs.idt.limit = env->idt.limit;
target-i386/kvm.c:    sregs.idt.base = env->idt.base;
target-i386/kvm.c:    sregs.gdt.limit = env->gdt.limit;
target-i386/kvm.c:    sregs.gdt.base = env->gdt.base;
target-i386/kvm.c:    sregs.cr0 = env->cr[0];
target-i386/kvm.c:    sregs.cr2 = env->cr[2];
target-i386/kvm.c:    sregs.cr3 = env->cr[3];
target-i386/kvm.c:    sregs.cr4 = env->cr[4];
target-i386/kvm.c:    sregs.efer = env->efer;
target-i386/kvm.c:    kvm_msr_entry_set(&msrs[0], MSR_IA32_TSCDEADLINE, env->tsc_deadline);
target-i386/kvm.c:    kvm_msr_entry_set(&msrs[n++], MSR_IA32_SYSENTER_CS, env->sysenter_cs);
target-i386/kvm.c:    kvm_msr_entry_set(&msrs[n++], MSR_IA32_SYSENTER_ESP, env->sysenter_esp);
target-i386/kvm.c:    kvm_msr_entry_set(&msrs[n++], MSR_IA32_SYSENTER_EIP, env->sysenter_eip);
target-i386/kvm.c:    kvm_msr_entry_set(&msrs[n++], MSR_PAT, env->pat);
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_STAR, env->star);
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_VM_HSAVE_PA, env->vm_hsave);
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_TSC_ADJUST, env->tsc_adjust);
target-i386/kvm.c:                          env->msr_ia32_misc_enable);
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_IA32_BNDCFGS, env->msr_bndcfgs);
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_CSTAR, env->cstar);
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_KERNELGSBASE, env->kernelgsbase);
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_FMASK, env->fmask);
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_LSTAR, env->lstar);
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_IA32_TSC, env->tsc);
target-i386/kvm.c:                          env->system_time_msr);
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_KVM_WALL_CLOCK, env->wall_clock_msr);
target-i386/kvm.c:                              env->async_pf_en_msr);
target-i386/kvm.c:                              env->pv_eoi_en_msr);
target-i386/kvm.c:                              env->steal_time_msr);
target-i386/kvm.c:                                  env->msr_fixed_counters[i]);
target-i386/kvm.c:                                  env->msr_gp_counters[i]);
target-i386/kvm.c:                                  env->msr_gp_evtsel[i]);
target-i386/kvm.c:                              env->msr_global_status);
target-i386/kvm.c:                              env->msr_global_ovf_ctrl);
target-i386/kvm.c:                              env->msr_fixed_ctr_ctrl);
target-i386/kvm.c:                              env->msr_global_ctrl);
target-i386/kvm.c:                              env->msr_hv_guest_os_id);
target-i386/kvm.c:                              env->msr_hv_hypercall);
target-i386/kvm.c:                              env->msr_hv_vapic);
target-i386/kvm.c:                              env->msr_hv_tsc);
target-i386/kvm.c:            kvm_msr_entry_set(&msrs[n++], MSR_MTRRdefType, env->mtrr_deftype);
target-i386/kvm.c:                              MSR_MTRRfix64K_00000, env->mtrr_fixed[0]);
target-i386/kvm.c:                              MSR_MTRRfix16K_80000, env->mtrr_fixed[1]);
target-i386/kvm.c:                              MSR_MTRRfix16K_A0000, env->mtrr_fixed[2]);
target-i386/kvm.c:                              MSR_MTRRfix4K_C0000, env->mtrr_fixed[3]);
target-i386/kvm.c:                              MSR_MTRRfix4K_C8000, env->mtrr_fixed[4]);
target-i386/kvm.c:                              MSR_MTRRfix4K_D0000, env->mtrr_fixed[5]);
target-i386/kvm.c:                              MSR_MTRRfix4K_D8000, env->mtrr_fixed[6]);
target-i386/kvm.c:                              MSR_MTRRfix4K_E0000, env->mtrr_fixed[7]);
target-i386/kvm.c:                              MSR_MTRRfix4K_E8000, env->mtrr_fixed[8]);
target-i386/kvm.c:                              MSR_MTRRfix4K_F0000, env->mtrr_fixed[9]);
target-i386/kvm.c:                              MSR_MTRRfix4K_F8000, env->mtrr_fixed[10]);
target-i386/kvm.c:                                  MSR_MTRRphysBase(i), env->mtrr_var[i].base);
target-i386/kvm.c:                                  MSR_MTRRphysMask(i), env->mtrr_var[i].mask);
target-i386/kvm.c:    if (env->mcg_cap) {
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_MCG_STATUS, env->mcg_status);
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_MCG_CTL, env->mcg_ctl);
target-i386/kvm.c:        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {
target-i386/kvm.c:            kvm_msr_entry_set(&msrs[n++], MSR_MC0_CTL + i, env->mce_banks[i]);
target-i386/kvm.c:    env->fpstt = (fpu.fsw >> 11) & 7;
target-i386/kvm.c:    env->fpus = fpu.fsw;
target-i386/kvm.c:    env->fpuc = fpu.fcw;
target-i386/kvm.c:    env->fpop = fpu.last_opcode;
target-i386/kvm.c:    env->fpip = fpu.last_ip;
target-i386/kvm.c:    env->fpdp = fpu.last_dp;
target-i386/kvm.c:        env->fptags[i] = !((fpu.ftwx >> i) & 1);
target-i386/kvm.c:    memcpy(env->fpregs, fpu.fpr, sizeof env->fpregs);
target-i386/kvm.c:    memcpy(env->xmm_regs, fpu.xmm, sizeof env->xmm_regs);
target-i386/kvm.c:    env->mxcsr = fpu.mxcsr;
target-i386/kvm.c:    struct kvm_xsave* xsave = env->kvm_xsave_buf;
target-i386/kvm.c:    env->fpop = (uint16_t)(xsave->region[XSAVE_FTW_FOP] >> 16);
target-i386/kvm.c:    env->fpstt = (swd >> 11) & 7;
target-i386/kvm.c:    env->fpus = swd;
target-i386/kvm.c:    env->fpuc = cwd;
target-i386/kvm.c:        env->fptags[i] = !((twd >> i) & 1);
target-i386/kvm.c:    memcpy(&env->fpip, &xsave->region[XSAVE_CWD_RIP], sizeof(env->fpip));
target-i386/kvm.c:    memcpy(&env->fpdp, &xsave->region[XSAVE_CWD_RDP], sizeof(env->fpdp));
target-i386/kvm.c:    env->mxcsr = xsave->region[XSAVE_MXCSR];
target-i386/kvm.c:    memcpy(env->fpregs, &xsave->region[XSAVE_ST_SPACE],
target-i386/kvm.c:            sizeof env->fpregs);
target-i386/kvm.c:    memcpy(env->xmm_regs, &xsave->region[XSAVE_XMM_SPACE],
target-i386/kvm.c:            sizeof env->xmm_regs);
target-i386/kvm.c:    env->xstate_bv = *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV];
target-i386/kvm.c:    memcpy(env->ymmh_regs, &xsave->region[XSAVE_YMMH_SPACE],
target-i386/kvm.c:            sizeof env->ymmh_regs);
target-i386/kvm.c:    memcpy(env->bnd_regs, &xsave->region[XSAVE_BNDREGS],
target-i386/kvm.c:            sizeof env->bnd_regs);
target-i386/kvm.c:    memcpy(&env->bndcs_regs, &xsave->region[XSAVE_BNDCSR],
target-i386/kvm.c:            sizeof(env->bndcs_regs));
target-i386/kvm.c:            env->xcr0 = xcrs.xcrs[i].value;
target-i386/kvm.c:    env->interrupt_injected = -1;
target-i386/kvm.c:            env->interrupt_injected = i * 64 + bit;
target-i386/kvm.c:    get_seg(&env->segs[R_CS], &sregs.cs);
target-i386/kvm.c:    get_seg(&env->segs[R_DS], &sregs.ds);
target-i386/kvm.c:    get_seg(&env->segs[R_ES], &sregs.es);
target-i386/kvm.c:    get_seg(&env->segs[R_FS], &sregs.fs);
target-i386/kvm.c:    get_seg(&env->segs[R_GS], &sregs.gs);
target-i386/kvm.c:    get_seg(&env->segs[R_SS], &sregs.ss);
target-i386/kvm.c:    get_seg(&env->tr, &sregs.tr);
target-i386/kvm.c:    get_seg(&env->ldt, &sregs.ldt);
target-i386/kvm.c:    env->idt.limit = sregs.idt.limit;
target-i386/kvm.c:    env->idt.base = sregs.idt.base;
target-i386/kvm.c:    env->gdt.limit = sregs.gdt.limit;
target-i386/kvm.c:    env->gdt.base = sregs.gdt.base;
target-i386/kvm.c:    env->cr[0] = sregs.cr0;
target-i386/kvm.c:    env->cr[2] = sregs.cr2;
target-i386/kvm.c:    env->cr[3] = sregs.cr3;
target-i386/kvm.c:    env->cr[4] = sregs.cr4;
target-i386/kvm.c:    env->efer = sregs.efer;
target-i386/kvm.c:    hflags = (env->segs[R_SS].flags >> DESC_DPL_SHIFT) & HF_CPL_MASK;
target-i386/kvm.c:    hflags |= (env->cr[0] & CR0_PE_MASK) << (HF_PE_SHIFT - CR0_PE_SHIFT);
target-i386/kvm.c:    hflags |= (env->cr[0] << (HF_MP_SHIFT - CR0_MP_SHIFT)) &
target-i386/kvm.c:    hflags |= (env->eflags & (HF_TF_MASK | HF_VM_MASK | HF_IOPL_MASK));
target-i386/kvm.c:    hflags |= (env->cr[4] & CR4_OSFXSR_MASK) <<
target-i386/kvm.c:    if (env->efer & MSR_EFER_LMA) {
target-i386/kvm.c:    if ((hflags & HF_LMA_MASK) && (env->segs[R_CS].flags & DESC_L_MASK)) {
target-i386/kvm.c:        hflags |= (env->segs[R_CS].flags & DESC_B_MASK) >>
target-i386/kvm.c:        hflags |= (env->segs[R_SS].flags & DESC_B_MASK) >>
target-i386/kvm.c:        if (!(env->cr[0] & CR0_PE_MASK) || (env->eflags & VM_MASK) ||
target-i386/kvm.c:            hflags |= ((env->segs[R_DS].base | env->segs[R_ES].base |
target-i386/kvm.c:                        env->segs[R_SS].base) != 0) << HF_ADDSEG_SHIFT;
target-i386/kvm.c:    env->hflags = (env->hflags & HFLAG_COPY_MASK) | hflags;
target-i386/kvm.c:    if (!env->tsc_valid) {
target-i386/kvm.c:        env->tsc_valid = !runstate_is_running();
target-i386/kvm.c:    if (env->mcg_cap) {
target-i386/kvm.c:        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {
target-i386/kvm.c:            env->sysenter_cs = msrs[i].data;
target-i386/kvm.c:            env->sysenter_esp = msrs[i].data;
target-i386/kvm.c:            env->sysenter_eip = msrs[i].data;
target-i386/kvm.c:            env->pat = msrs[i].data;
target-i386/kvm.c:            env->star = msrs[i].data;
target-i386/kvm.c:            env->cstar = msrs[i].data;
target-i386/kvm.c:            env->kernelgsbase = msrs[i].data;
target-i386/kvm.c:            env->fmask = msrs[i].data;
target-i386/kvm.c:            env->lstar = msrs[i].data;
target-i386/kvm.c:            env->tsc = msrs[i].data;
target-i386/kvm.c:            env->tsc_adjust = msrs[i].data;
target-i386/kvm.c:            env->tsc_deadline = msrs[i].data;
target-i386/kvm.c:            env->vm_hsave = msrs[i].data;
target-i386/kvm.c:            env->system_time_msr = msrs[i].data;
target-i386/kvm.c:            env->wall_clock_msr = msrs[i].data;
target-i386/kvm.c:            env->mcg_status = msrs[i].data;
target-i386/kvm.c:            env->mcg_ctl = msrs[i].data;
target-i386/kvm.c:            env->msr_ia32_misc_enable = msrs[i].data;
target-i386/kvm.c:            env->msr_ia32_feature_control = msrs[i].data;
target-i386/kvm.c:            env->msr_bndcfgs = msrs[i].data;
target-i386/kvm.c:                msrs[i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) {
target-i386/kvm.c:                env->mce_banks[msrs[i].index - MSR_MC0_CTL] = msrs[i].data;
target-i386/kvm.c:            env->async_pf_en_msr = msrs[i].data;
target-i386/kvm.c:            env->pv_eoi_en_msr = msrs[i].data;
target-i386/kvm.c:            env->steal_time_msr = msrs[i].data;
target-i386/kvm.c:            env->msr_fixed_ctr_ctrl = msrs[i].data;
target-i386/kvm.c:            env->msr_global_ctrl = msrs[i].data;
target-i386/kvm.c:            env->msr_global_status = msrs[i].data;
target-i386/kvm.c:            env->msr_global_ovf_ctrl = msrs[i].data;
target-i386/kvm.c:            env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;
target-i386/kvm.c:            env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;
target-i386/kvm.c:            env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;
target-i386/kvm.c:            env->msr_hv_hypercall = msrs[i].data;
target-i386/kvm.c:            env->msr_hv_guest_os_id = msrs[i].data;
target-i386/kvm.c:            env->msr_hv_vapic = msrs[i].data;
target-i386/kvm.c:            env->msr_hv_tsc = msrs[i].data;
target-i386/kvm.c:            env->mtrr_deftype = msrs[i].data;
target-i386/kvm.c:            env->mtrr_fixed[0] = msrs[i].data;
target-i386/kvm.c:            env->mtrr_fixed[1] = msrs[i].data;
target-i386/kvm.c:            env->mtrr_fixed[2] = msrs[i].data;
target-i386/kvm.c:            env->mtrr_fixed[3] = msrs[i].data;
target-i386/kvm.c:            env->mtrr_fixed[4] = msrs[i].data;
target-i386/kvm.c:            env->mtrr_fixed[5] = msrs[i].data;
target-i386/kvm.c:            env->mtrr_fixed[6] = msrs[i].data;
target-i386/kvm.c:            env->mtrr_fixed[7] = msrs[i].data;
target-i386/kvm.c:            env->mtrr_fixed[8] = msrs[i].data;
target-i386/kvm.c:            env->mtrr_fixed[9] = msrs[i].data;
target-i386/kvm.c:            env->mtrr_fixed[10] = msrs[i].data;
target-i386/kvm.c:                env->mtrr_var[MSR_MTRRphysIndex(index)].mask = msrs[i].data;
target-i386/kvm.c:                env->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data;
target-i386/kvm.c:    env->mp_state = mp_state.mp_state;
target-i386/kvm.c:    events.exception.injected = (env->exception_injected >= 0);
target-i386/kvm.c:    events.exception.nr = env->exception_injected;
target-i386/kvm.c:    events.exception.has_error_code = env->has_error_code;
target-i386/kvm.c:    events.exception.error_code = env->error_code;
target-i386/kvm.c:    events.interrupt.injected = (env->interrupt_injected >= 0);
target-i386/kvm.c:    events.interrupt.nr = env->interrupt_injected;
target-i386/kvm.c:    events.interrupt.soft = env->soft_interrupt;
target-i386/kvm.c:    events.nmi.injected = env->nmi_injected;
target-i386/kvm.c:    events.nmi.pending = env->nmi_pending;
target-i386/kvm.c:    events.nmi.masked = !!(env->hflags2 & HF2_NMI_MASK);
target-i386/kvm.c:    events.sipi_vector = env->sipi_vector;
target-i386/kvm.c:    env->exception_injected =
target-i386/kvm.c:    env->has_error_code = events.exception.has_error_code;
target-i386/kvm.c:    env->error_code = events.exception.error_code;
target-i386/kvm.c:    env->interrupt_injected =
target-i386/kvm.c:    env->soft_interrupt = events.interrupt.soft;
target-i386/kvm.c:    env->nmi_injected = events.nmi.injected;
target-i386/kvm.c:    env->nmi_pending = events.nmi.pending;
target-i386/kvm.c:        env->hflags2 |= HF2_NMI_MASK;
target-i386/kvm.c:        env->hflags2 &= ~HF2_NMI_MASK;
target-i386/kvm.c:    env->sipi_vector = events.sipi_vector;
target-i386/kvm.c:        if (env->exception_injected == 1) {
target-i386/kvm.c:        } else if (env->exception_injected == 3) {
target-i386/kvm.c:        env->exception_injected = -1;
target-i386/kvm.c:        dbgregs.db[i] = env->dr[i];
target-i386/kvm.c:    dbgregs.dr6 = env->dr[6];
target-i386/kvm.c:    dbgregs.dr7 = env->dr[7];
target-i386/kvm.c:        env->dr[i] = dbgregs.db[i];
target-i386/kvm.c:    env->dr[4] = env->dr[6] = dbgregs.dr6;
target-i386/kvm.c:    env->dr[5] = env->dr[7] = dbgregs.dr7;
target-i386/kvm.c:            (env->eflags & IF_MASK)) {
target-i386/kvm.c:        env->eflags |= IF_MASK;
target-i386/kvm.c:        env->eflags &= ~IF_MASK;
target-i386/kvm.c:        assert(env->mcg_cap);
target-i386/kvm.c:        if (env->exception_injected == EXCP08_DBLE) {
target-i386/kvm.c:        env->exception_injected = EXCP12_MCHK;
target-i386/kvm.c:        env->has_error_code = 0;
target-i386/kvm.c:        if (kvm_irqchip_in_kernel() && env->mp_state == KVM_MP_STATE_HALTED) {
target-i386/kvm.c:            env->mp_state = KVM_MP_STATE_RUNNABLE;
target-i386/kvm.c:         (env->eflags & IF_MASK)) ||
target-i386/kvm.c:        apic_handle_tpr_access_report(cpu->apic_state, env->eip,
target-i386/kvm.c:                                      env->tpr_access_type);
target-i386/kvm.c:          (env->eflags & IF_MASK)) &&
target-i386/kvm.c:        assert(env->exception_injected == -1);
target-i386/kvm.c:        env->exception_injected = arch_info->exception;
target-i386/kvm.c:        env->has_error_code = 0;
target-i386/kvm.c:    return !(env->cr[0] & CR0_PE_MASK) ||
target-i386/kvm.c:           ((env->segs[R_CS].selector  & 3) != 3);
target-i386/excp_helper.c:    int first_contributory = env->old_exception == 0 ||
target-i386/excp_helper.c:                              (env->old_exception >= 10 &&
target-i386/excp_helper.c:                               env->old_exception <= 13);
target-i386/excp_helper.c:                env->old_exception, intno);
target-i386/excp_helper.c:    if (env->old_exception == EXCP08_DBLE) {
target-i386/excp_helper.c:        if (env->hflags & HF_SVMI_MASK) {
target-i386/excp_helper.c:        || (env->old_exception == EXCP0E_PAGE &&
target-i386/excp_helper.c:        env->old_exception = intno;
target-i386/excp_helper.c: * env->eip value AFTER the interrupt instruction. It is only relevant if
target-i386/excp_helper.c:    env->error_code = error_code;
target-i386/excp_helper.c:    env->exception_is_int = is_int;
target-i386/excp_helper.c:    env->exception_next_eip = env->eip + next_eip_addend;
target-i386/helper.c:    int cpuver = env->cpuid_version;
target-i386/helper.c:    if (env->hflags & HF_CS64_MASK) {
target-i386/helper.c:    if (!(env->hflags & HF_PE_MASK) || !(sc->flags & DESC_P_MASK))
target-i386/helper.c:                        (sc->flags & DESC_B_MASK || env->hflags & HF_LMA_MASK)
target-i386/helper.c:                    sys_type_name[(env->hflags & HF_LMA_MASK) ? 1 : 0]
target-i386/helper.c:    if (env->hflags & HF_CS64_MASK) {
target-i386/helper.c:                    env->regs[R_EAX],
target-i386/helper.c:                    env->regs[R_EBX],
target-i386/helper.c:                    env->regs[R_ECX],
target-i386/helper.c:                    env->regs[R_EDX],
target-i386/helper.c:                    env->regs[R_ESI],
target-i386/helper.c:                    env->regs[R_EDI],
target-i386/helper.c:                    env->regs[R_EBP],
target-i386/helper.c:                    env->regs[R_ESP],
target-i386/helper.c:                    env->regs[8],
target-i386/helper.c:                    env->regs[9],
target-i386/helper.c:                    env->regs[10],
target-i386/helper.c:                    env->regs[11],
target-i386/helper.c:                    env->regs[12],
target-i386/helper.c:                    env->regs[13],
target-i386/helper.c:                    env->regs[14],
target-i386/helper.c:                    env->regs[15],
target-i386/helper.c:                    env->eip, eflags,
target-i386/helper.c:                    env->hflags & HF_CPL_MASK,
target-i386/helper.c:                    (env->hflags >> HF_INHIBIT_IRQ_SHIFT) & 1,
target-i386/helper.c:                    (env->a20_mask >> 20) & 1,
target-i386/helper.c:                    (env->hflags >> HF_SMM_SHIFT) & 1,
target-i386/helper.c:                    (uint32_t)env->regs[R_EAX],
target-i386/helper.c:                    (uint32_t)env->regs[R_EBX],
target-i386/helper.c:                    (uint32_t)env->regs[R_ECX],
target-i386/helper.c:                    (uint32_t)env->regs[R_EDX],
target-i386/helper.c:                    (uint32_t)env->regs[R_ESI],
target-i386/helper.c:                    (uint32_t)env->regs[R_EDI],
target-i386/helper.c:                    (uint32_t)env->regs[R_EBP],
target-i386/helper.c:                    (uint32_t)env->regs[R_ESP],
target-i386/helper.c:                    (uint32_t)env->eip, eflags,
target-i386/helper.c:                    env->hflags & HF_CPL_MASK,
target-i386/helper.c:                    (env->hflags >> HF_INHIBIT_IRQ_SHIFT) & 1,
target-i386/helper.c:                    (env->a20_mask >> 20) & 1,
target-i386/helper.c:                    (env->hflags >> HF_SMM_SHIFT) & 1,
target-i386/helper.c:                               &env->segs[i]);
target-i386/helper.c:    cpu_x86_dump_seg_cache(env, f, cpu_fprintf, "LDT", &env->ldt);
target-i386/helper.c:    cpu_x86_dump_seg_cache(env, f, cpu_fprintf, "TR", &env->tr);
target-i386/helper.c:    if (env->hflags & HF_LMA_MASK) {
target-i386/helper.c:                    env->gdt.base, env->gdt.limit);
target-i386/helper.c:                    env->idt.base, env->idt.limit);
target-i386/helper.c:                    (uint32_t)env->cr[0],
target-i386/helper.c:                    env->cr[2],
target-i386/helper.c:                    env->cr[3],
target-i386/helper.c:                    (uint32_t)env->cr[4]);
target-i386/helper.c:            cpu_fprintf(f, "DR%d=%016" PRIx64 " ", i, env->dr[i]);
target-i386/helper.c:                    env->dr[6], env->dr[7]);
target-i386/helper.c:                    (uint32_t)env->gdt.base, env->gdt.limit);
target-i386/helper.c:                    (uint32_t)env->idt.base, env->idt.limit);
target-i386/helper.c:                    (uint32_t)env->cr[0],
target-i386/helper.c:                    (uint32_t)env->cr[2],
target-i386/helper.c:                    (uint32_t)env->cr[3],
target-i386/helper.c:                    (uint32_t)env->cr[4]);
target-i386/helper.c:            cpu_fprintf(f, "DR%d=" TARGET_FMT_lx " ", i, env->dr[i]);
target-i386/helper.c:                    env->dr[6], env->dr[7]);
target-i386/helper.c:        if ((unsigned)env->cc_op < CC_OP_NB)
target-i386/helper.c:            snprintf(cc_op_name, sizeof(cc_op_name), "%s", cc_op_str[env->cc_op]);
target-i386/helper.c:            snprintf(cc_op_name, sizeof(cc_op_name), "[%d]", env->cc_op);
target-i386/helper.c:        if (env->hflags & HF_CS64_MASK) {
target-i386/helper.c:                        env->cc_src, env->cc_dst,
target-i386/helper.c:                        (uint32_t)env->cc_src, (uint32_t)env->cc_dst,
target-i386/helper.c:    cpu_fprintf(f, "EFER=%016" PRIx64 "\n", env->efer);
target-i386/helper.c:            fptag |= ((!env->fptags[i]) << i);
target-i386/helper.c:                    env->fpuc,
target-i386/helper.c:                    (env->fpus & ~0x3800) | (env->fpstt & 0x7) << 11,
target-i386/helper.c:                    env->fpstt,
target-i386/helper.c:                    env->mxcsr);
target-i386/helper.c:            u.d = env->fpregs[i].d;
target-i386/helper.c:        if (env->hflags & HF_CS64_MASK)
target-i386/helper.c:                        env->xmm_regs[i].XMM_L(3),
target-i386/helper.c:                        env->xmm_regs[i].XMM_L(2),
target-i386/helper.c:                        env->xmm_regs[i].XMM_L(1),
target-i386/helper.c:                        env->xmm_regs[i].XMM_L(0));
target-i386/helper.c:        target_ulong base = env->segs[R_CS].base + env->eip;
target-i386/helper.c:        target_ulong offs = MIN(env->eip, DUMP_CODE_BYTES_BACKWARD);
target-i386/helper.c:    if (a20_state != ((env->a20_mask >> 20) & 1)) {
target-i386/helper.c:        env->a20_mask = ~(1 << 20) | (a20_state << 20);
target-i386/helper.c:        (env->cr[0] & (CR0_PG_MASK | CR0_WP_MASK | CR0_PE_MASK))) {
target-i386/helper.c:    if (!(env->cr[0] & CR0_PG_MASK) && (new_cr0 & CR0_PG_MASK) &&
target-i386/helper.c:        (env->efer & MSR_EFER_LME)) {
target-i386/helper.c:        if (!(env->cr[4] & CR4_PAE_MASK))
target-i386/helper.c:        env->efer |= MSR_EFER_LMA;
target-i386/helper.c:        env->hflags |= HF_LMA_MASK;
target-i386/helper.c:    } else if ((env->cr[0] & CR0_PG_MASK) && !(new_cr0 & CR0_PG_MASK) &&
target-i386/helper.c:               (env->efer & MSR_EFER_LMA)) {
target-i386/helper.c:        env->efer &= ~MSR_EFER_LMA;
target-i386/helper.c:        env->hflags &= ~(HF_LMA_MASK | HF_CS64_MASK);
target-i386/helper.c:        env->eip &= 0xffffffff;
target-i386/helper.c:    env->cr[0] = new_cr0 | CR0_ET_MASK;
target-i386/helper.c:    pe_state = (env->cr[0] & CR0_PE_MASK);
target-i386/helper.c:    env->hflags = (env->hflags & ~HF_PE_MASK) | (pe_state << HF_PE_SHIFT);
target-i386/helper.c:    env->hflags |= ((pe_state ^ 1) << HF_ADDSEG_SHIFT);
target-i386/helper.c:    env->hflags = (env->hflags & ~(HF_MP_MASK | HF_EM_MASK | HF_TS_MASK)) |
target-i386/helper.c:    env->cr[3] = new_cr3;
target-i386/helper.c:    if (env->cr[0] & CR0_PG_MASK) {
target-i386/helper.c:    printf("CR4 update: CR4=%08x\n", (uint32_t)env->cr[4]);
target-i386/helper.c:    if ((new_cr4 ^ env->cr[4]) &
target-i386/helper.c:    if (!(env->features[FEAT_1_EDX] & CPUID_SSE)) {
target-i386/helper.c:    env->hflags &= ~HF_OSFXSR_MASK;
target-i386/helper.c:        env->hflags |= HF_OSFXSR_MASK;
target-i386/helper.c:    if (!(env->features[FEAT_7_0_EBX] & CPUID_7_0_EBX_SMAP)) {
target-i386/helper.c:    env->hflags &= ~HF_SMAP_MASK;
target-i386/helper.c:        env->hflags |= HF_SMAP_MASK;
target-i386/helper.c:    env->cr[4] = new_cr4;
target-i386/helper.c:    env->cr[2] = addr;
target-i386/helper.c:    env->error_code = (is_write << PG_ERROR_W_BIT);
target-i386/helper.c:    env->error_code |= PG_ERROR_U_MASK;
target-i386/helper.c:           addr, is_write1, is_user, env->eip);
target-i386/helper.c:    if (!(env->cr[0] & CR0_PG_MASK)) {
target-i386/helper.c:        if (!(env->hflags & HF_LMA_MASK)) {
target-i386/helper.c:    if (!(env->efer & MSR_EFER_NXE)) {
target-i386/helper.c:    if (env->cr[4] & CR4_PAE_MASK) {
target-i386/helper.c:        if (env->hflags & HF_LMA_MASK) {
target-i386/helper.c:                env->error_code = 0;
target-i386/helper.c:            pml4e_addr = ((env->cr[3] & ~0xfff) + (((addr >> 39) & 0x1ff) << 3)) &
target-i386/helper.c:                env->a20_mask;
target-i386/helper.c:                env->a20_mask;
target-i386/helper.c:            pdpe_addr = ((env->cr[3] & ~0x1f) + ((addr >> 27) & 0x18)) &
target-i386/helper.c:                env->a20_mask;
target-i386/helper.c:            env->a20_mask;
target-i386/helper.c:            env->a20_mask;
target-i386/helper.c:        pde_addr = ((env->cr[3] & ~0xfff) + ((addr >> 20) & 0xffc)) &
target-i386/helper.c:            env->a20_mask;
target-i386/helper.c:        if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {
target-i386/helper.c:            env->a20_mask;
target-i386/helper.c:        if (is_write1 == 2 && (env->cr[4] & CR4_SMEP_MASK) &&
target-i386/helper.c:        if ((env->cr[0] & CR0_WP_MASK) &&
target-i386/helper.c:         !((env->cr[4] & CR4_SMEP_MASK) && (ptep & PG_USER_MASK)))) {
target-i386/helper.c:            if (!(env->cr[0] & CR0_WP_MASK) ||
target-i386/helper.c:    pte = pte & env->a20_mask;
target-i386/helper.c:        (((env->efer & MSR_EFER_NXE) &&
target-i386/helper.c:          (env->cr[4] & CR4_PAE_MASK)) ||
target-i386/helper.c:         (env->cr[4] & CR4_SMEP_MASK)))
target-i386/helper.c:    if (env->intercept_exceptions & (1 << EXCP0E_PAGE)) {
target-i386/helper.c:                 env->vm_vmcb + offsetof(struct vmcb, control.exit_info_2),
target-i386/helper.c:        env->cr[2] = addr;
target-i386/helper.c:    env->error_code = error_code;
target-i386/helper.c:    if (!(env->cr[0] & CR0_PG_MASK)) {
target-i386/helper.c:        pte = addr & env->a20_mask;
target-i386/helper.c:    } else if (env->cr[4] & CR4_PAE_MASK) {
target-i386/helper.c:        if (env->hflags & HF_LMA_MASK) {
target-i386/helper.c:            pml4e_addr = ((env->cr[3] & ~0xfff) + (((addr >> 39) & 0x1ff) << 3)) &
target-i386/helper.c:                env->a20_mask;
target-i386/helper.c:                         (((addr >> 30) & 0x1ff) << 3)) & env->a20_mask;
target-i386/helper.c:            pdpe_addr = ((env->cr[3] & ~0x1f) + ((addr >> 27) & 0x18)) &
target-i386/helper.c:                env->a20_mask;
target-i386/helper.c:                    (((addr >> 21) & 0x1ff) << 3)) & env->a20_mask;
target-i386/helper.c:                        (((addr >> 12) & 0x1ff) << 3)) & env->a20_mask;
target-i386/helper.c:        pde_addr = ((env->cr[3] & ~0xfff) + ((addr >> 20) & 0xffc)) & env->a20_mask;
target-i386/helper.c:        if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {
target-i386/helper.c:            pte_addr = ((pde & ~0xfff) + ((addr >> 10) & 0xffc)) & env->a20_mask;
target-i386/helper.c:        pte = pte & env->a20_mask;
target-i386/helper.c:    switch (hw_breakpoint_type(env->dr[7], index)) {
target-i386/helper.c:        if (hw_breakpoint_enabled(env->dr[7], index)) {
target-i386/helper.c:            err = cpu_breakpoint_insert(cs, env->dr[index], BP_CPU,
target-i386/helper.c:                                        &env->cpu_breakpoint[index]);
target-i386/helper.c:        err = cpu_watchpoint_insert(cs, env->dr[index],
target-i386/helper.c:                                    hw_breakpoint_len(env->dr[7], index),
target-i386/helper.c:                                    type, &env->cpu_watchpoint[index]);
target-i386/helper.c:        env->cpu_breakpoint[index] = NULL;
target-i386/helper.c:    if (!env->cpu_breakpoint[index]) {
target-i386/helper.c:    switch (hw_breakpoint_type(env->dr[7], index)) {
target-i386/helper.c:        if (hw_breakpoint_enabled(env->dr[7], index)) {
target-i386/helper.c:            cpu_breakpoint_remove_by_ref(cs, env->cpu_breakpoint[index]);
target-i386/helper.c:        cpu_watchpoint_remove_by_ref(cs, env->cpu_watchpoint[index]);
target-i386/helper.c:    dr6 = env->dr[6] & ~0xf;
target-i386/helper.c:        switch (hw_breakpoint_type(env->dr[7], reg)) {
target-i386/helper.c:            if (env->dr[reg] == env->eip) {
target-i386/helper.c:            if (env->cpu_watchpoint[reg] &&
target-i386/helper.c:                env->cpu_watchpoint[reg]->flags & BP_WATCHPOINT_HIT) {
target-i386/helper.c:            if (hw_breakpoint_enabled(env->dr[7], reg)) {
target-i386/helper.c:        env->dr[6] = dr6;
target-i386/helper.c:            if (bp->pc == env->eip) {
target-i386/helper.c:    uint64_t *banks = cenv->mce_banks + 4 * params->bank;
target-i386/helper.c:        && (cenv->mcg_status & MCG_STATUS_MCIP)) {
target-i386/helper.c:        if ((cenv->mcg_cap & MCG_CTL_P) && cenv->mcg_ctl != ~(uint64_t)0) {
target-i386/helper.c:        if ((cenv->mcg_status & MCG_STATUS_MCIP) ||
target-i386/helper.c:            !(cenv->cr[4] & CR4_MCE_MASK)) {
target-i386/helper.c:        cenv->mcg_status = params->mcg_status;
target-i386/helper.c:    unsigned bank_num = cenv->mcg_cap & 0xff;
target-i386/helper.c:    if (!cenv->mcg_cap) {
target-i386/helper.c:        env->tpr_access_type = access;
target-i386/helper.c:        apic_handle_tpr_access_report(cpu->apic_state, env->eip, access);
target-i386/helper.c:        dt = &env->ldt;
target-i386/helper.c:        dt = &env->gdt;
target-i386/helper.c:    memcpy(&env->start_init_save, &save->start_init_save,
target-i386/arch_dump.c:    regs.r15 = env->regs[15];
target-i386/arch_dump.c:    regs.r14 = env->regs[14];
target-i386/arch_dump.c:    regs.r13 = env->regs[13];
target-i386/arch_dump.c:    regs.r12 = env->regs[12];
target-i386/arch_dump.c:    regs.r11 = env->regs[11];
target-i386/arch_dump.c:    regs.r10 = env->regs[10];
target-i386/arch_dump.c:    regs.r9  = env->regs[9];
target-i386/arch_dump.c:    regs.r8  = env->regs[8];
target-i386/arch_dump.c:    regs.rbp = env->regs[R_EBP];
target-i386/arch_dump.c:    regs.rsp = env->regs[R_ESP];
target-i386/arch_dump.c:    regs.rdi = env->regs[R_EDI];
target-i386/arch_dump.c:    regs.rsi = env->regs[R_ESI];
target-i386/arch_dump.c:    regs.rdx = env->regs[R_EDX];
target-i386/arch_dump.c:    regs.rcx = env->regs[R_ECX];
target-i386/arch_dump.c:    regs.rbx = env->regs[R_EBX];
target-i386/arch_dump.c:    regs.rax = env->regs[R_EAX];
target-i386/arch_dump.c:    regs.rip = env->eip;
target-i386/arch_dump.c:    regs.eflags = env->eflags;
target-i386/arch_dump.c:    regs.cs = env->segs[R_CS].selector;
target-i386/arch_dump.c:    regs.ss = env->segs[R_SS].selector;
target-i386/arch_dump.c:    regs.fs_base = env->segs[R_FS].base;
target-i386/arch_dump.c:    regs.gs_base = env->segs[R_GS].base;
target-i386/arch_dump.c:    regs.ds = env->segs[R_DS].selector;
target-i386/arch_dump.c:    regs.es = env->segs[R_ES].selector;
target-i386/arch_dump.c:    regs.fs = env->segs[R_FS].selector;
target-i386/arch_dump.c:    regs.gs = env->segs[R_GS].selector;
target-i386/arch_dump.c:    prstatus->regs.ebp = env->regs[R_EBP] & 0xffffffff;
target-i386/arch_dump.c:    prstatus->regs.esp = env->regs[R_ESP] & 0xffffffff;
target-i386/arch_dump.c:    prstatus->regs.edi = env->regs[R_EDI] & 0xffffffff;
target-i386/arch_dump.c:    prstatus->regs.esi = env->regs[R_ESI] & 0xffffffff;
target-i386/arch_dump.c:    prstatus->regs.edx = env->regs[R_EDX] & 0xffffffff;
target-i386/arch_dump.c:    prstatus->regs.ecx = env->regs[R_ECX] & 0xffffffff;
target-i386/arch_dump.c:    prstatus->regs.ebx = env->regs[R_EBX] & 0xffffffff;
target-i386/arch_dump.c:    prstatus->regs.eax = env->regs[R_EAX] & 0xffffffff;
target-i386/arch_dump.c:    prstatus->regs.eip = env->eip & 0xffffffff;
target-i386/arch_dump.c:    prstatus->regs.eflags = env->eflags & 0xffffffff;
target-i386/arch_dump.c:    prstatus->regs.cs = env->segs[R_CS].selector;
target-i386/arch_dump.c:    prstatus->regs.ss = env->segs[R_SS].selector;
target-i386/arch_dump.c:    prstatus->regs.ds = env->segs[R_DS].selector;
target-i386/arch_dump.c:    prstatus->regs.es = env->segs[R_ES].selector;
target-i386/arch_dump.c:    prstatus->regs.fs = env->segs[R_FS].selector;
target-i386/arch_dump.c:    prstatus->regs.gs = env->segs[R_GS].selector;
target-i386/arch_dump.c:    s->rax = env->regs[R_EAX];
target-i386/arch_dump.c:    s->rbx = env->regs[R_EBX];
target-i386/arch_dump.c:    s->rcx = env->regs[R_ECX];
target-i386/arch_dump.c:    s->rdx = env->regs[R_EDX];
target-i386/arch_dump.c:    s->rsi = env->regs[R_ESI];
target-i386/arch_dump.c:    s->rdi = env->regs[R_EDI];
target-i386/arch_dump.c:    s->rsp = env->regs[R_ESP];
target-i386/arch_dump.c:    s->rbp = env->regs[R_EBP];
target-i386/arch_dump.c:    s->r8  = env->regs[8];
target-i386/arch_dump.c:    s->r9  = env->regs[9];
target-i386/arch_dump.c:    s->r10 = env->regs[10];
target-i386/arch_dump.c:    s->r11 = env->regs[11];
target-i386/arch_dump.c:    s->r12 = env->regs[12];
target-i386/arch_dump.c:    s->r13 = env->regs[13];
target-i386/arch_dump.c:    s->r14 = env->regs[14];
target-i386/arch_dump.c:    s->r15 = env->regs[15];
target-i386/arch_dump.c:    s->rip = env->eip;
target-i386/arch_dump.c:    s->rflags = env->eflags;
target-i386/arch_dump.c:    copy_segment(&s->cs, &env->segs[R_CS]);
target-i386/arch_dump.c:    copy_segment(&s->ds, &env->segs[R_DS]);
target-i386/arch_dump.c:    copy_segment(&s->es, &env->segs[R_ES]);
target-i386/arch_dump.c:    copy_segment(&s->fs, &env->segs[R_FS]);
target-i386/arch_dump.c:    copy_segment(&s->gs, &env->segs[R_GS]);
target-i386/arch_dump.c:    copy_segment(&s->ss, &env->segs[R_SS]);
target-i386/arch_dump.c:    copy_segment(&s->ldt, &env->ldt);
target-i386/arch_dump.c:    copy_segment(&s->tr, &env->tr);
target-i386/arch_dump.c:    copy_segment(&s->gdt, &env->gdt);
target-i386/arch_dump.c:    copy_segment(&s->idt, &env->idt);
target-i386/arch_dump.c:    s->cr[0] = env->cr[0];
target-i386/arch_dump.c:    s->cr[1] = env->cr[1];
target-i386/arch_dump.c:    s->cr[2] = env->cr[2];
target-i386/arch_dump.c:    s->cr[3] = env->cr[3];
target-i386/arch_dump.c:    s->cr[4] = env->cr[4];
target-i386/machine.c:    return (env->fpregs_format_vmstate == 0);
target-i386/machine.c:    guess_mmx = ((env->fptag_vmstate == 0xff) &&
target-i386/machine.c:                 (env->fpus_vmstate & 0x3800) == 0);
target-i386/machine.c:    return (guess_mmx && (env->fpregs_format_vmstate == 1));
target-i386/machine.c:    guess_mmx = ((env->fptag_vmstate == 0xff) &&
target-i386/machine.c:                 (env->fpus_vmstate & 0x3800) == 0);
target-i386/machine.c:    return (!guess_mmx && (env->fpregs_format_vmstate == 1));
target-i386/machine.c:    env->fpus_vmstate = (env->fpus & ~0x3800) | (env->fpstt & 0x7) << 11;
target-i386/machine.c:    env->fptag_vmstate = 0;
target-i386/machine.c:        env->fptag_vmstate |= ((!env->fptags[i]) << i);
target-i386/machine.c:    env->fpregs_format_vmstate = 0;
target-i386/machine.c:    if (!(env->cr[0] & CR0_PE_MASK) &&
target-i386/machine.c:        (env->segs[R_CS].flags >> DESC_DPL_SHIFT & 3) != 0) {
target-i386/machine.c:        env->segs[R_CS].flags &= ~(env->segs[R_CS].flags & DESC_DPL_MASK);
target-i386/machine.c:        env->segs[R_DS].flags &= ~(env->segs[R_DS].flags & DESC_DPL_MASK);
target-i386/machine.c:        env->segs[R_ES].flags &= ~(env->segs[R_ES].flags & DESC_DPL_MASK);
target-i386/machine.c:        env->segs[R_FS].flags &= ~(env->segs[R_FS].flags & DESC_DPL_MASK);
target-i386/machine.c:        env->segs[R_GS].flags &= ~(env->segs[R_GS].flags & DESC_DPL_MASK);
target-i386/machine.c:        env->segs[R_SS].flags &= ~(env->segs[R_SS].flags & DESC_DPL_MASK);
target-i386/machine.c:    if (!(env->cr[0] & CR0_PE_MASK) &&
target-i386/machine.c:        (env->segs[R_CS].flags >> DESC_DPL_SHIFT & 3) != 0) {
target-i386/machine.c:        env->segs[R_CS].flags &= ~(env->segs[R_CS].flags & DESC_DPL_MASK);
target-i386/machine.c:        env->segs[R_DS].flags &= ~(env->segs[R_DS].flags & DESC_DPL_MASK);
target-i386/machine.c:        env->segs[R_ES].flags &= ~(env->segs[R_ES].flags & DESC_DPL_MASK);
target-i386/machine.c:        env->segs[R_FS].flags &= ~(env->segs[R_FS].flags & DESC_DPL_MASK);
target-i386/machine.c:        env->segs[R_GS].flags &= ~(env->segs[R_GS].flags & DESC_DPL_MASK);
target-i386/machine.c:        env->segs[R_SS].flags &= ~(env->segs[R_SS].flags & DESC_DPL_MASK);
target-i386/machine.c:    env->hflags &= ~HF_CPL_MASK;
target-i386/machine.c:    env->hflags |= (env->segs[R_SS].flags >> DESC_DPL_SHIFT) & HF_CPL_MASK;
target-i386/machine.c:    env->fpstt = (env->fpus_vmstate >> 11) & 7;
target-i386/machine.c:    env->fpus = env->fpus_vmstate & ~0x3800;
target-i386/machine.c:    env->fptag_vmstate ^= 0xff;
target-i386/machine.c:        env->fptags[i] = (env->fptag_vmstate >> i) & 1;
target-i386/machine.c:    return env->fpop != 0 || env->fpip != 0 || env->fpdp != 0;
target-i386/machine.c:    return env->tsc_adjust != 0;
target-i386/machine.c:    return env->tsc_deadline != 0;
target-i386/machine.c:    return env->msr_ia32_misc_enable != MSR_IA32_MISC_ENABLE_DEFAULT;
target-i386/machine.c:    return env->msr_ia32_feature_control != 0;
target-i386/machine.c:    if (env->msr_fixed_ctr_ctrl || env->msr_global_ctrl ||
target-i386/machine.c:        env->msr_global_status || env->msr_global_ovf_ctrl) {
target-i386/machine.c:        if (env->msr_fixed_counters[i]) {
target-i386/machine.c:        if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
target-i386/machine.c:        if (env->bnd_regs[i].lb || env->bnd_regs[i].ub) {
target-i386/machine.c:    if (env->bndcs_regs.cfgu || env->bndcs_regs.sts) {
target-i386/machine.c:    return !!env->msr_bndcfgs;
target-i386/machine.c:    return env->msr_hv_hypercall != 0 || env->msr_hv_guest_os_id != 0;
target-i386/machine.c:    return env->msr_hv_vapic != 0;
target-i386/machine.c:    return env->msr_hv_tsc != 0;
target-i386/cpu.h:    sc = &env->segs[seg_reg];
target-i386/cpu.h:            if ((env->hflags & HF_LMA_MASK) && (flags & DESC_L_MASK)) {
target-i386/cpu.h:                env->hflags |= HF_CS32_MASK | HF_SS32_MASK | HF_CS64_MASK;
target-i386/cpu.h:                env->hflags &= ~(HF_ADDSEG_MASK);
target-i386/cpu.h:                new_hflags = (env->segs[R_CS].flags & DESC_B_MASK)
target-i386/cpu.h:                env->hflags = (env->hflags & ~(HF_CS32_MASK | HF_CS64_MASK)) |
target-i386/cpu.h:            env->hflags = (env->hflags & ~HF_CPL_MASK) | cpl;
target-i386/cpu.h:        new_hflags = (env->segs[R_SS].flags & DESC_B_MASK)
target-i386/cpu.h:        if (env->hflags & HF_CS64_MASK) {
target-i386/cpu.h:        } else if (!(env->cr[0] & CR0_PE_MASK) ||
target-i386/cpu.h:                   (env->eflags & VM_MASK) ||
target-i386/cpu.h:                   !(env->hflags & HF_CS32_MASK)) {
target-i386/cpu.h:            new_hflags |= ((env->segs[R_DS].base |
target-i386/cpu.h:                            env->segs[R_ES].base |
target-i386/cpu.h:                            env->segs[R_SS].base) != 0) <<
target-i386/cpu.h:        env->hflags = (env->hflags &
target-i386/cpu.h:    env->eip = 0;
target-i386/cpu.h:                           env->segs[R_CS].limit,
target-i386/cpu.h:                           env->segs[R_CS].flags);
target-i386/cpu.h:    return (env->hflags & HF_CPL_MASK) == 3 ? MMU_USER_IDX :
target-i386/cpu.h:        (!(env->hflags & HF_SMAP_MASK) || (env->eflags & AC_MASK))
target-i386/cpu.h:    return !(env->hflags & HF_SMAP_MASK) ? MMU_KNOSMAP_IDX :
target-i386/cpu.h:        ((env->hflags & HF_CPL_MASK) < 3 && (env->eflags & AC_MASK))
target-i386/cpu.h:#define CC_DST  (env->cc_dst)
target-i386/cpu.h:#define CC_SRC  (env->cc_src)
target-i386/cpu.h:#define CC_SRC2 (env->cc_src2)
target-i386/cpu.h:#define CC_OP   (env->cc_op)
target-i386/cpu.h:#define FT0    (env->ft0)
target-i386/cpu.h:#define ST0    (env->fpregs[env->fpstt].d)
target-i386/cpu.h:#define ST(n)  (env->fpregs[(env->fpstt + (n)) & 7].d)
target-i386/cpu.h:    *cs_base = env->segs[R_CS].base;
target-i386/cpu.h:    *pc = *cs_base + env->eip;
target-i386/cpu.h:    *flags = env->hflags |
target-i386/cpu.h:        (env->eflags & (IOPL_MASK | TF_MASK | RF_MASK | VM_MASK | AC_MASK));
target-i386/cpu.h:    return env->eflags | cpu_cc_compute_all(env, CC_OP) | (env->df & DF_MASK);
target-i386/cpu.h:    env->df = 1 - (2 * ((eflags >> 10) & 1));
target-i386/cpu.h:    env->eflags = (env->eflags & ~update_mask) |
target-i386/cpu.h:    env->efer = val;
target-i386/cpu.h:    env->hflags &= ~(HF_LMA_MASK | HF_SVME_MASK);
target-i386/cpu.h:    if (env->efer & MSR_EFER_LMA) {
target-i386/cpu.h:        env->hflags |= HF_LMA_MASK;
target-i386/cpu.h:    if (env->efer & MSR_EFER_SVME) {
target-i386/cpu.h:        env->hflags |= HF_SVME_MASK;
target-i386/fpu_helper.c:    env->fpstt = (env->fpstt - 1) & 7;
target-i386/fpu_helper.c:    env->fptags[env->fpstt] = 0; /* validate stack entry */
target-i386/fpu_helper.c:    env->fptags[env->fpstt] = 1; /* invalidate stack entry */
target-i386/fpu_helper.c:    env->fpstt = (env->fpstt + 1) & 7;
target-i386/fpu_helper.c:    u.f64 = floatx80_to_float64(a, &env->fp_status);
target-i386/fpu_helper.c:    return float64_to_floatx80(u.f64, &env->fp_status);
target-i386/fpu_helper.c:    env->fpus |= mask;
target-i386/fpu_helper.c:    if (env->fpus & (~env->fpuc & FPUC_EM)) {
target-i386/fpu_helper.c:        env->fpus |= FPUS_SE | FPUS_B;
target-i386/fpu_helper.c:    return floatx80_div(a, b, &env->fp_status);
target-i386/fpu_helper.c:    if (env->cr[0] & CR0_NE_MASK) {
target-i386/fpu_helper.c:    FT0 = float32_to_floatx80(u.f, &env->fp_status);
target-i386/fpu_helper.c:    FT0 = float64_to_floatx80(u.f, &env->fp_status);
target-i386/fpu_helper.c:    FT0 = int32_to_floatx80(val, &env->fp_status);
target-i386/fpu_helper.c:    new_fpstt = (env->fpstt - 1) & 7;
target-i386/fpu_helper.c:    env->fpregs[new_fpstt].d = float32_to_floatx80(u.f, &env->fp_status);
target-i386/fpu_helper.c:    env->fpstt = new_fpstt;
target-i386/fpu_helper.c:    env->fptags[new_fpstt] = 0; /* validate stack entry */
target-i386/fpu_helper.c:    new_fpstt = (env->fpstt - 1) & 7;
target-i386/fpu_helper.c:    env->fpregs[new_fpstt].d = float64_to_floatx80(u.f, &env->fp_status);
target-i386/fpu_helper.c:    env->fpstt = new_fpstt;
target-i386/fpu_helper.c:    env->fptags[new_fpstt] = 0; /* validate stack entry */
target-i386/fpu_helper.c:    new_fpstt = (env->fpstt - 1) & 7;
target-i386/fpu_helper.c:    env->fpregs[new_fpstt].d = int32_to_floatx80(val, &env->fp_status);
target-i386/fpu_helper.c:    env->fpstt = new_fpstt;
target-i386/fpu_helper.c:    env->fptags[new_fpstt] = 0; /* validate stack entry */
target-i386/fpu_helper.c:    new_fpstt = (env->fpstt - 1) & 7;
target-i386/fpu_helper.c:    env->fpregs[new_fpstt].d = int64_to_floatx80(val, &env->fp_status);
target-i386/fpu_helper.c:    env->fpstt = new_fpstt;
target-i386/fpu_helper.c:    env->fptags[new_fpstt] = 0; /* validate stack entry */
target-i386/fpu_helper.c:    u.f = floatx80_to_float32(ST0, &env->fp_status);
target-i386/fpu_helper.c:    u.f = floatx80_to_float64(ST0, &env->fp_status);
target-i386/fpu_helper.c:    val = floatx80_to_int32(ST0, &env->fp_status);
target-i386/fpu_helper.c:    val = floatx80_to_int32(ST0, &env->fp_status);
target-i386/fpu_helper.c:    val = floatx80_to_int64(ST0, &env->fp_status);
target-i386/fpu_helper.c:    val = floatx80_to_int32_round_to_zero(ST0, &env->fp_status);
target-i386/fpu_helper.c:    val = floatx80_to_int32_round_to_zero(ST0, &env->fp_status);
target-i386/fpu_helper.c:    val = floatx80_to_int64_round_to_zero(ST0, &env->fp_status);
target-i386/fpu_helper.c:    new_fpstt = (env->fpstt - 1) & 7;
target-i386/fpu_helper.c:    env->fpregs[new_fpstt].d = helper_fldt(env, ptr);
target-i386/fpu_helper.c:    env->fpstt = new_fpstt;
target-i386/fpu_helper.c:    env->fptags[new_fpstt] = 0; /* validate stack entry */
target-i386/fpu_helper.c:    env->fpstt = (env->fpstt - 1) & 7;
target-i386/fpu_helper.c:    env->fpus &= ~0x4700;
target-i386/fpu_helper.c:    env->fpstt = (env->fpstt + 1) & 7;
target-i386/fpu_helper.c:    env->fpus &= ~0x4700;
target-i386/fpu_helper.c:    env->fptags[(env->fpstt + st_index) & 7] = 1;
target-i386/fpu_helper.c:    ret = floatx80_compare(ST0, FT0, &env->fp_status);
target-i386/fpu_helper.c:    env->fpus = (env->fpus & ~0x4500) | fcom_ccval[ret + 1];
target-i386/fpu_helper.c:    ret = floatx80_compare_quiet(ST0, FT0, &env->fp_status);
target-i386/fpu_helper.c:    env->fpus = (env->fpus & ~0x4500) | fcom_ccval[ret + 1];
target-i386/fpu_helper.c:    ret = floatx80_compare(ST0, FT0, &env->fp_status);
target-i386/fpu_helper.c:    ret = floatx80_compare_quiet(ST0, FT0, &env->fp_status);
target-i386/fpu_helper.c:    ST0 = floatx80_add(ST0, FT0, &env->fp_status);
target-i386/fpu_helper.c:    ST0 = floatx80_mul(ST0, FT0, &env->fp_status);
target-i386/fpu_helper.c:    ST0 = floatx80_sub(ST0, FT0, &env->fp_status);
target-i386/fpu_helper.c:    ST0 = floatx80_sub(FT0, ST0, &env->fp_status);
target-i386/fpu_helper.c:    ST(st_index) = floatx80_add(ST(st_index), ST0, &env->fp_status);
target-i386/fpu_helper.c:    ST(st_index) = floatx80_mul(ST(st_index), ST0, &env->fp_status);
target-i386/fpu_helper.c:    ST(st_index) = floatx80_sub(ST(st_index), ST0, &env->fp_status);
target-i386/fpu_helper.c:    ST(st_index) = floatx80_sub(ST0, ST(st_index), &env->fp_status);
target-i386/fpu_helper.c:    return (env->fpus & ~0x3800) | (env->fpstt & 0x7) << 11;
target-i386/fpu_helper.c:    return env->fpuc;
target-i386/fpu_helper.c:    switch (env->fpuc & FPU_RC_MASK) {
target-i386/fpu_helper.c:    set_float_rounding_mode(rnd_type, &env->fp_status);
target-i386/fpu_helper.c:    switch ((env->fpuc >> 8) & 3) {
target-i386/fpu_helper.c:    set_floatx80_rounding_precision(rnd_type, &env->fp_status);
target-i386/fpu_helper.c:    env->fpuc = val;
target-i386/fpu_helper.c:    env->fpus &= 0x7f00;
target-i386/fpu_helper.c:    if (env->fpus & FPUS_SE) {
target-i386/fpu_helper.c:    env->fpus = 0;
target-i386/fpu_helper.c:    env->fpstt = 0;
target-i386/fpu_helper.c:    env->fpuc = 0x37f;
target-i386/fpu_helper.c:    env->fptags[0] = 1;
target-i386/fpu_helper.c:    env->fptags[1] = 1;
target-i386/fpu_helper.c:    env->fptags[2] = 1;
target-i386/fpu_helper.c:    env->fptags[3] = 1;
target-i386/fpu_helper.c:    env->fptags[4] = 1;
target-i386/fpu_helper.c:    env->fptags[5] = 1;
target-i386/fpu_helper.c:    env->fptags[6] = 1;
target-i386/fpu_helper.c:    env->fptags[7] = 1;
target-i386/fpu_helper.c:    tmp = int64_to_floatx80(val, &env->fp_status);
target-i386/fpu_helper.c:    val = floatx80_to_int64(ST0, &env->fp_status);
target-i386/fpu_helper.c:        env->fpus &= ~0x4700;
target-i386/fpu_helper.c:        env->fpus |= 0x400;
target-i386/fpu_helper.c:        env->fpus |= 0x400;
target-i386/fpu_helper.c:        env->fpus &= ~0x400; /* C2 <-- 0 */
target-i386/fpu_helper.c:                           &env->fp_status);
target-i386/fpu_helper.c:        ST0 = int32_to_floatx80(expdif, &env->fp_status);
target-i386/fpu_helper.c:        env->fpus &= ~0x4700; /* (C3,C2,C1,C0) <-- 0000 */
target-i386/fpu_helper.c:        env->fpus &= ~0x4700; /* (C3,C2,C1,C0) <-- 0000 */
target-i386/fpu_helper.c:        env->fpus &= ~0x4700; /* (C3,C2,C1,C0) <-- 0000 */
target-i386/fpu_helper.c:        env->fpus |= (q & 0x4) << (8 - 2);  /* (C0) <-- q2 */
target-i386/fpu_helper.c:        env->fpus |= (q & 0x2) << (14 - 1); /* (C3) <-- q1 */
target-i386/fpu_helper.c:        env->fpus |= (q & 0x1) << (9 - 0);  /* (C1) <-- q0 */
target-i386/fpu_helper.c:        env->fpus |= 0x400;  /* C2 <-- 1 */
target-i386/fpu_helper.c:        env->fpus &= ~0x4700; /* (C3,C2,C1,C0) <-- 0000 */
target-i386/fpu_helper.c:        env->fpus &= ~0x4700; /* (C3,C2,C1,C0) <-- 0000 */
target-i386/fpu_helper.c:        env->fpus &= ~0x4700; /* (C3,C2,C1,C0) <-- 0000 */
target-i386/fpu_helper.c:        env->fpus |= (q & 0x4) << (8 - 2);  /* (C0) <-- q2 */
target-i386/fpu_helper.c:        env->fpus |= (q & 0x2) << (14 - 1); /* (C3) <-- q1 */
target-i386/fpu_helper.c:        env->fpus |= (q & 0x1) << (9 - 0);  /* (C1) <-- q0 */
target-i386/fpu_helper.c:        env->fpus |= 0x400;  /* C2 <-- 1 */
target-i386/fpu_helper.c:        env->fpus &= ~0x4700;
target-i386/fpu_helper.c:        env->fpus |= 0x400;
target-i386/fpu_helper.c:        env->fpus &= ~0x4700;  /* (C3,C2,C1,C0) <-- 0000 */
target-i386/fpu_helper.c:        env->fpus |= 0x400;
target-i386/fpu_helper.c:    ST0 = floatx80_sqrt(ST0, &env->fp_status);
target-i386/fpu_helper.c:        env->fpus |= 0x400;
target-i386/fpu_helper.c:        env->fpus &= ~0x400;  /* C2 <-- 0 */
target-i386/fpu_helper.c:    ST0 = floatx80_round_to_int(ST0, &env->fp_status);
target-i386/fpu_helper.c:        int n = floatx80_to_int32_round_to_zero(ST1, &env->fp_status);
target-i386/fpu_helper.c:        ST0 = floatx80_scalbn(ST0, n, &env->fp_status);
target-i386/fpu_helper.c:        env->fpus |= 0x400;
target-i386/fpu_helper.c:        env->fpus &= ~0x400;  /* C2 <-- 0 */
target-i386/fpu_helper.c:        env->fpus |= 0x400;
target-i386/fpu_helper.c:        env->fpus &= ~0x400;  /* C2 <-- 0 */
target-i386/fpu_helper.c:    env->fpus &= ~0x4700; /* (C3,C2,C1,C0) <-- 0000 */
target-i386/fpu_helper.c:        env->fpus |= 0x200; /* C1 <-- 1 */
target-i386/fpu_helper.c:            env->fpus |= 0x500; /* Infinity */
target-i386/fpu_helper.c:            env->fpus |= 0x100; /* NaN */
target-i386/fpu_helper.c:            env->fpus |=  0x4000; /* Zero */
target-i386/fpu_helper.c:            env->fpus |= 0x4400; /* Denormal */
target-i386/fpu_helper.c:        env->fpus |= 0x400;
target-i386/fpu_helper.c:    fpus = (env->fpus & ~0x3800) | (env->fpstt & 0x7) << 11;
target-i386/fpu_helper.c:        if (env->fptags[i]) {
target-i386/fpu_helper.c:            tmp.d = env->fpregs[i].d;
target-i386/fpu_helper.c:        cpu_stl_data(env, ptr, env->fpuc);
target-i386/fpu_helper.c:        cpu_stw_data(env, ptr, env->fpuc);
target-i386/fpu_helper.c:        env->fpuc = cpu_lduw_data(env, ptr);
target-i386/fpu_helper.c:        env->fpuc = cpu_lduw_data(env, ptr);
target-i386/fpu_helper.c:    env->fpstt = (fpus >> 11) & 7;
target-i386/fpu_helper.c:    env->fpus = fpus & ~0x3800;
target-i386/fpu_helper.c:        env->fptags[i] = ((fptag & 3) == 3);
target-i386/fpu_helper.c:    env->fpus = 0;
target-i386/fpu_helper.c:    env->fpstt = 0;
target-i386/fpu_helper.c:    env->fpuc = 0x37f;
target-i386/fpu_helper.c:    env->fptags[0] = 1;
target-i386/fpu_helper.c:    env->fptags[1] = 1;
target-i386/fpu_helper.c:    env->fptags[2] = 1;
target-i386/fpu_helper.c:    env->fptags[3] = 1;
target-i386/fpu_helper.c:    env->fptags[4] = 1;
target-i386/fpu_helper.c:    env->fptags[5] = 1;
target-i386/fpu_helper.c:    env->fptags[6] = 1;
target-i386/fpu_helper.c:    env->fptags[7] = 1;
target-i386/fpu_helper.c:    fpus = (env->fpus & ~0x3800) | (env->fpstt & 0x7) << 11;
target-i386/fpu_helper.c:        fptag |= (env->fptags[i] << i);
target-i386/fpu_helper.c:    cpu_stw_data(env, ptr, env->fpuc);
target-i386/fpu_helper.c:    if (env->cr[4] & CR4_OSFXSR_MASK) {
target-i386/fpu_helper.c:        cpu_stl_data(env, ptr + 0x18, env->mxcsr); /* mxcsr */
target-i386/fpu_helper.c:        if (env->hflags & HF_CS64_MASK) {
target-i386/fpu_helper.c:        if (!(env->efer & MSR_EFER_FFXSR)
target-i386/fpu_helper.c:            || (env->hflags & HF_CPL_MASK)
target-i386/fpu_helper.c:            || !(env->hflags & HF_LMA_MASK)) {
target-i386/fpu_helper.c:                cpu_stq_data(env, addr, env->xmm_regs[i].XMM_Q(0));
target-i386/fpu_helper.c:                cpu_stq_data(env, addr + 8, env->xmm_regs[i].XMM_Q(1));
target-i386/fpu_helper.c:    env->fpuc = cpu_lduw_data(env, ptr);
target-i386/fpu_helper.c:    env->fpstt = (fpus >> 11) & 7;
target-i386/fpu_helper.c:    env->fpus = fpus & ~0x3800;
target-i386/fpu_helper.c:        env->fptags[i] = ((fptag >> i) & 1);
target-i386/fpu_helper.c:    if (env->cr[4] & CR4_OSFXSR_MASK) {
target-i386/fpu_helper.c:        if (env->hflags & HF_CS64_MASK) {
target-i386/fpu_helper.c:        if (!(env->efer & MSR_EFER_FFXSR)
target-i386/fpu_helper.c:            || (env->hflags & HF_CPL_MASK)
target-i386/fpu_helper.c:            || !(env->hflags & HF_LMA_MASK)) {
target-i386/fpu_helper.c:                env->xmm_regs[i].XMM_Q(0) = cpu_ldq_data(env, addr);
target-i386/fpu_helper.c:                env->xmm_regs[i].XMM_Q(1) = cpu_ldq_data(env, addr + 8);
target-i386/fpu_helper.c:    env->mxcsr = mxcsr;
target-i386/fpu_helper.c:    set_float_rounding_mode(rnd_type, &env->sse_status);
target-i386/fpu_helper.c:    set_flush_inputs_to_zero((mxcsr & SSE_DAZ) ? 1 : 0, &env->sse_status);
target-i386/fpu_helper.c:    set_flush_to_zero((mxcsr & SSE_FZ) ? 1 : 0, &env->fp_status);
target-i386/fpu_helper.c:    env->fpstt = 0;
target-i386/fpu_helper.c:    *(uint32_t *)(env->fptags) = 0;
target-i386/fpu_helper.c:    *(uint32_t *)(env->fptags + 4) = 0;
target-i386/fpu_helper.c:    *(uint32_t *)(env->fptags) = 0x01010101;
target-i386/fpu_helper.c:    *(uint32_t *)(env->fptags + 4) = 0x01010101;
target-i386/misc_helper.c:    env->dr[6] |= DR6_BS;
target-i386/misc_helper.c:    cpu_x86_cpuid(env, (uint32_t)env->regs[R_EAX], (uint32_t)env->regs[R_ECX],
target-i386/misc_helper.c:    env->regs[R_EAX] = eax;
target-i386/misc_helper.c:    env->regs[R_EBX] = ebx;
target-i386/misc_helper.c:    env->regs[R_ECX] = ecx;
target-i386/misc_helper.c:    env->regs[R_EDX] = edx;
target-i386/misc_helper.c:        val = env->cr[reg];
target-i386/misc_helper.c:        if (!(env->hflags2 & HF2_VINTR_MASK)) {
target-i386/misc_helper.c:            val = env->v_tpr;
target-i386/misc_helper.c:        if (!(env->hflags2 & HF2_VINTR_MASK)) {
target-i386/misc_helper.c:        env->v_tpr = t0 & 0x0f;
target-i386/misc_helper.c:        env->cr[reg] = t0;
target-i386/misc_helper.c:        env->dr[reg] = t0;
target-i386/misc_helper.c:        env->dr[7] = t0;
target-i386/misc_helper.c:        env->dr[reg] = t0;
target-i386/misc_helper.c:    t0 = (env->cr[0] & ~0xe) | (t0 & 0xf);
target-i386/misc_helper.c:    if ((env->cr[4] & CR4_TSD_MASK) && ((env->hflags & HF_CPL_MASK) != 0)) {
target-i386/misc_helper.c:    val = cpu_get_tsc(env) + env->tsc_offset;
target-i386/misc_helper.c:    env->regs[R_EAX] = (uint32_t)(val);
target-i386/misc_helper.c:    env->regs[R_EDX] = (uint32_t)(val >> 32);
target-i386/misc_helper.c:    env->regs[R_ECX] = (uint32_t)(env->tsc_aux);
target-i386/misc_helper.c:    if ((env->cr[4] & CR4_PCE_MASK) && ((env->hflags & HF_CPL_MASK) != 0)) {
target-i386/misc_helper.c:    val = ((uint32_t)env->regs[R_EAX]) |
target-i386/misc_helper.c:        ((uint64_t)((uint32_t)env->regs[R_EDX]) << 32);
target-i386/misc_helper.c:    switch ((uint32_t)env->regs[R_ECX]) {
target-i386/misc_helper.c:        env->sysenter_cs = val & 0xffff;
target-i386/misc_helper.c:        env->sysenter_esp = val;
target-i386/misc_helper.c:        env->sysenter_eip = val;
target-i386/misc_helper.c:            if (env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_SYSCALL) {
target-i386/misc_helper.c:            if (env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM) {
target-i386/misc_helper.c:            if (env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_FFXSR) {
target-i386/misc_helper.c:            if (env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_NX) {
target-i386/misc_helper.c:            if (env->features[FEAT_8000_0001_ECX] & CPUID_EXT3_SVM) {
target-i386/misc_helper.c:            if (env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_FFXSR) {
target-i386/misc_helper.c:            cpu_load_efer(env, (env->efer & ~update_mask) |
target-i386/misc_helper.c:        env->star = val;
target-i386/misc_helper.c:        env->pat = val;
target-i386/misc_helper.c:        env->vm_hsave = val;
target-i386/misc_helper.c:        env->lstar = val;
target-i386/misc_helper.c:        env->cstar = val;
target-i386/misc_helper.c:        env->fmask = val;
target-i386/misc_helper.c:        env->segs[R_FS].base = val;
target-i386/misc_helper.c:        env->segs[R_GS].base = val;
target-i386/misc_helper.c:        env->kernelgsbase = val;
target-i386/misc_helper.c:        env->mtrr_var[((uint32_t)env->regs[R_ECX] -
target-i386/misc_helper.c:        env->mtrr_var[((uint32_t)env->regs[R_ECX] -
target-i386/misc_helper.c:        env->mtrr_fixed[(uint32_t)env->regs[R_ECX] -
target-i386/misc_helper.c:        env->mtrr_fixed[(uint32_t)env->regs[R_ECX] -
target-i386/misc_helper.c:        env->mtrr_fixed[(uint32_t)env->regs[R_ECX] -
target-i386/misc_helper.c:        env->mtrr_deftype = val;
target-i386/misc_helper.c:        env->mcg_status = val;
target-i386/misc_helper.c:        if ((env->mcg_cap & MCG_CTL_P)
target-i386/misc_helper.c:            env->mcg_ctl = val;
target-i386/misc_helper.c:        env->tsc_aux = val;
target-i386/misc_helper.c:        env->msr_ia32_misc_enable = val;
target-i386/misc_helper.c:        if ((uint32_t)env->regs[R_ECX] >= MSR_MC0_CTL
target-i386/misc_helper.c:            && (uint32_t)env->regs[R_ECX] < MSR_MC0_CTL +
target-i386/misc_helper.c:            (4 * env->mcg_cap & 0xff)) {
target-i386/misc_helper.c:            uint32_t offset = (uint32_t)env->regs[R_ECX] - MSR_MC0_CTL;
target-i386/misc_helper.c:                env->mce_banks[offset] = val;
target-i386/misc_helper.c:    switch ((uint32_t)env->regs[R_ECX]) {
target-i386/misc_helper.c:        val = env->sysenter_cs;
target-i386/misc_helper.c:        val = env->sysenter_esp;
target-i386/misc_helper.c:        val = env->sysenter_eip;
target-i386/misc_helper.c:        val = env->efer;
target-i386/misc_helper.c:        val = env->star;
target-i386/misc_helper.c:        val = env->pat;
target-i386/misc_helper.c:        val = env->vm_hsave;
target-i386/misc_helper.c:        val = env->lstar;
target-i386/misc_helper.c:        val = env->cstar;
target-i386/misc_helper.c:        val = env->fmask;
target-i386/misc_helper.c:        val = env->segs[R_FS].base;
target-i386/misc_helper.c:        val = env->segs[R_GS].base;
target-i386/misc_helper.c:        val = env->kernelgsbase;
target-i386/misc_helper.c:        val = env->tsc_aux;
target-i386/misc_helper.c:        val = env->mtrr_var[((uint32_t)env->regs[R_ECX] -
target-i386/misc_helper.c:        val = env->mtrr_var[((uint32_t)env->regs[R_ECX] -
target-i386/misc_helper.c:        val = env->mtrr_fixed[0];
target-i386/misc_helper.c:        val = env->mtrr_fixed[(uint32_t)env->regs[R_ECX] -
target-i386/misc_helper.c:        val = env->mtrr_fixed[(uint32_t)env->regs[R_ECX] -
target-i386/misc_helper.c:        val = env->mtrr_deftype;
target-i386/misc_helper.c:        if (env->features[FEAT_1_EDX] & CPUID_MTRR) {
target-i386/misc_helper.c:        val = env->mcg_cap;
target-i386/misc_helper.c:        if (env->mcg_cap & MCG_CTL_P) {
target-i386/misc_helper.c:            val = env->mcg_ctl;
target-i386/misc_helper.c:        val = env->mcg_status;
target-i386/misc_helper.c:        val = env->msr_ia32_misc_enable;
target-i386/misc_helper.c:        if ((uint32_t)env->regs[R_ECX] >= MSR_MC0_CTL
target-i386/misc_helper.c:            && (uint32_t)env->regs[R_ECX] < MSR_MC0_CTL +
target-i386/misc_helper.c:            (4 * env->mcg_cap & 0xff)) {
target-i386/misc_helper.c:            uint32_t offset = (uint32_t)env->regs[R_ECX] - MSR_MC0_CTL;
target-i386/misc_helper.c:            val = env->mce_banks[offset];
target-i386/misc_helper.c:    env->regs[R_EAX] = (uint32_t)(val);
target-i386/misc_helper.c:    env->regs[R_EDX] = (uint32_t)(val >> 32);
target-i386/misc_helper.c:    env->hflags &= ~HF_INHIBIT_IRQ_MASK; /* needed if sti is just before */
target-i386/misc_helper.c:    env->eip += next_eip_addend;
target-i386/misc_helper.c:    if ((uint32_t)env->regs[R_ECX] != 0) {
target-i386/misc_helper.c:    if ((uint32_t)env->regs[R_ECX] != 0) {
target-i386/misc_helper.c:    env->eip += next_eip_addend;
target-i386/misc_helper.c:    env->eip += next_eip_addend;
target-i386/misc_helper.c:   // env->regs[R_EAX] = eax;
target-i386/misc_helper.c:    env->regs[R_EBX] = ebx;
target-i386/misc_helper.c:    env->regs[R_ECX] = ecx;
target-i386/misc_helper.c://    env->regs[R_EDX] = edx;/
target-i386/misc_helper.c:	printf(" Reg Check : R_EAX = %u", env->regs[R_EAX]);
target-i386/misc_helper.c:	if(env->regs[R_EAX] == 0)
target-i386/cpu.c:    env->cpuid_level = kvm_arch_get_supported_cpuid(s, 0x0, 0, R_EAX);
target-i386/cpu.c:    env->cpuid_xlevel = kvm_arch_get_supported_cpuid(s, 0x80000000, 0, R_EAX);
target-i386/cpu.c:    env->cpuid_xlevel2 = kvm_arch_get_supported_cpuid(s, 0xC0000000, 0, R_EAX);
target-i386/cpu.c:    value = (env->cpuid_version >> 8) & 0xf;
target-i386/cpu.c:        value += (env->cpuid_version >> 20) & 0xff;
target-i386/cpu.c:    env->cpuid_version &= ~0xff00f00;
target-i386/cpu.c:        env->cpuid_version |= 0xf00 | ((value - 0x0f) << 20);
target-i386/cpu.c:        env->cpuid_version |= value << 8;
target-i386/cpu.c:    value = (env->cpuid_version >> 4) & 0xf;
target-i386/cpu.c:    value |= ((env->cpuid_version >> 16) & 0xf) << 4;
target-i386/cpu.c:    env->cpuid_version &= ~0xf00f0;
target-i386/cpu.c:    env->cpuid_version |= ((value & 0xf) << 4) | ((value >> 4) << 16);
target-i386/cpu.c:    value = env->cpuid_version & 0xf;
target-i386/cpu.c:    env->cpuid_version &= ~0xf;
target-i386/cpu.c:    env->cpuid_version |= value & 0xf;
target-i386/cpu.c:    x86_cpu_vendor_words2str(value, env->cpuid_vendor1, env->cpuid_vendor2,
target-i386/cpu.c:                             env->cpuid_vendor3);
target-i386/cpu.c:    env->cpuid_vendor1 = 0;
target-i386/cpu.c:    env->cpuid_vendor2 = 0;
target-i386/cpu.c:    env->cpuid_vendor3 = 0;
target-i386/cpu.c:        env->cpuid_vendor1 |= ((uint8_t)value[i    ]) << (8 * i);
target-i386/cpu.c:        env->cpuid_vendor2 |= ((uint8_t)value[i + 4]) << (8 * i);
target-i386/cpu.c:        env->cpuid_vendor3 |= ((uint8_t)value[i + 8]) << (8 * i);
target-i386/cpu.c:        value[i] = env->cpuid_model[i >> 2] >> (8 * (i & 3));
target-i386/cpu.c:    memset(env->cpuid_model, 0, 48);
target-i386/cpu.c:        env->cpuid_model[i >> 2] |= c << (8 * (i & 3));
target-i386/cpu.c:            env->features[w] =
target-i386/cpu.c:        env->features[w] |= plus_features[w];
target-i386/cpu.c:        env->features[w] &= ~minus_features[w];
target-i386/cpu.c:        uint32_t requested_features = env->features[w];
target-i386/cpu.c:        env->features[w] &= host_feat;
target-i386/cpu.c:        cpu->filtered_features[w] = requested_features & ~env->features[w];
target-i386/cpu.c:    env->cpuid_xlevel2 = def->xlevel2;
target-i386/cpu.c:        env->features[w] = def->features[w];
target-i386/cpu.c:            env->features[w] |= kvm_default_features[w];
target-i386/cpu.c:            env->features[w] &= ~kvm_default_unset_features[w];
target-i386/cpu.c:    env->features[FEAT_1_ECX] |= CPUID_EXT_HYPERVISOR;
target-i386/cpu.c:    env->features[FEAT_1_EDX] &= ~CPUID_APIC;
target-i386/cpu.c:    *ebx = env->cpuid_vendor1;
target-i386/cpu.c:    *edx = env->cpuid_vendor2;
target-i386/cpu.c:    *ecx = env->cpuid_vendor3;
target-i386/cpu.c:        if (index > env->cpuid_xlevel) {
target-i386/cpu.c:            if (env->cpuid_xlevel2 > 0) {
target-i386/cpu.c:                if (index > env->cpuid_xlevel2) {
target-i386/cpu.c:                    index = env->cpuid_xlevel2;
target-i386/cpu.c:                    index = env->cpuid_xlevel;
target-i386/cpu.c:                index =  env->cpuid_level;
target-i386/cpu.c:        if (index > env->cpuid_level)
target-i386/cpu.c:            index = env->cpuid_level;
target-i386/cpu.c:        *eax = env->cpuid_level;
target-i386/cpu.c:        *eax = env->cpuid_version;
target-i386/cpu.c:        *ebx = (env->cpuid_apic_id << 24) | 8 << 8; /* CLFLUSH size in quad words, Linux wants it. */
target-i386/cpu.c:        *ecx = env->features[FEAT_1_ECX];
target-i386/cpu.c:        *edx = env->features[FEAT_1_EDX];
target-i386/cpu.c:            *ebx = env->features[FEAT_7_0_EBX]; /* Feature flags */
target-i386/cpu.c:        if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE) || !kvm_enabled()) {
target-i386/cpu.c:                if ((env->features[esa->feature] & esa->bits) == esa->bits &&
target-i386/cpu.c:            if ((env->features[esa->feature] & esa->bits) == esa->bits &&
target-i386/cpu.c:        *eax = env->cpuid_xlevel;
target-i386/cpu.c:        *ebx = env->cpuid_vendor1;
target-i386/cpu.c:        *edx = env->cpuid_vendor2;
target-i386/cpu.c:        *ecx = env->cpuid_vendor3;
target-i386/cpu.c:        *eax = env->cpuid_version;
target-i386/cpu.c:        *ecx = env->features[FEAT_8000_0001_ECX];
target-i386/cpu.c:        *edx = env->features[FEAT_8000_0001_EDX];
target-i386/cpu.c:        *eax = env->cpuid_model[(index - 0x80000002) * 4 + 0];
target-i386/cpu.c:        *ebx = env->cpuid_model[(index - 0x80000002) * 4 + 1];
target-i386/cpu.c:        *ecx = env->cpuid_model[(index - 0x80000002) * 4 + 2];
target-i386/cpu.c:        *edx = env->cpuid_model[(index - 0x80000002) * 4 + 3];
target-i386/cpu.c:        *edx = env->features[FEAT_8000_0007_EDX];
target-i386/cpu.c:        if (env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM) {
target-i386/cpu.c:            if (env->features[FEAT_1_EDX] & CPUID_PSE36) {
target-i386/cpu.c:        if (env->features[FEAT_8000_0001_ECX] & CPUID_EXT3_SVM) {
target-i386/cpu.c:            *edx = env->features[FEAT_SVM]; /* optional features */
target-i386/cpu.c:        *eax = env->cpuid_xlevel2;
target-i386/cpu.c:        *eax = env->cpuid_version;
target-i386/cpu.c:        *edx = env->features[FEAT_C000_0001_EDX];
target-i386/cpu.c:    env->old_exception = -1;
target-i386/cpu.c:    env->hflags |= HF_SOFTMMU_MASK;
target-i386/cpu.c:    env->hflags2 |= HF2_GIF_MASK;
target-i386/cpu.c:    env->a20_mask = ~0x0;
target-i386/cpu.c:    env->smbase = 0x30000;
target-i386/cpu.c:    env->idt.limit = 0xffff;
target-i386/cpu.c:    env->gdt.limit = 0xffff;
target-i386/cpu.c:    env->ldt.limit = 0xffff;
target-i386/cpu.c:    env->ldt.flags = DESC_P_MASK | (2 << DESC_TYPE_SHIFT);
target-i386/cpu.c:    env->tr.limit = 0xffff;
target-i386/cpu.c:    env->tr.flags = DESC_P_MASK | (11 << DESC_TYPE_SHIFT);
target-i386/cpu.c:    env->eip = 0xfff0;
target-i386/cpu.c:    env->regs[R_EDX] = env->cpuid_version;
target-i386/cpu.c:    env->eflags = 0x2;
target-i386/cpu.c:        env->fptags[i] = 1;
target-i386/cpu.c:    env->fpuc = 0x37f;
target-i386/cpu.c:    env->mxcsr = 0x1f80;
target-i386/cpu.c:    env->xstate_bv = XSTATE_FP | XSTATE_SSE;
target-i386/cpu.c:    env->pat = 0x0007040600070406ULL;
target-i386/cpu.c:    env->msr_ia32_misc_enable = MSR_IA32_MISC_ENABLE_DEFAULT;
target-i386/cpu.c:    memset(env->dr, 0, sizeof(env->dr));
target-i386/cpu.c:    env->dr[6] = DR6_FIXED_1;
target-i386/cpu.c:    env->dr[7] = DR7_FIXED_1;
target-i386/cpu.c:    env->xcr0 = 1;
target-i386/cpu.c:    env->mtrr_deftype = 0;
target-i386/cpu.c:    memset(env->mtrr_var, 0, sizeof(env->mtrr_var));
target-i386/cpu.c:    memset(env->mtrr_fixed, 0, sizeof(env->mtrr_fixed));
target-i386/cpu.c:    if (((cenv->cpuid_version >> 8) & 0xf) >= 6
target-i386/cpu.c:        && (cenv->features[FEAT_1_EDX] & (CPUID_MCE | CPUID_MCA)) ==
target-i386/cpu.c:        cenv->mcg_cap = MCE_CAP_DEF | MCE_BANKS_DEF;
target-i386/cpu.c:        cenv->mcg_ctl = ~(uint64_t)0;
target-i386/cpu.c:            cenv->mce_banks[bank * 4] = ~(uint64_t)0;
target-i386/cpu.c:    qdev_prop_set_uint8(cpu->apic_state, "id", env->cpuid_apic_id);
target-i386/cpu.c:    if (env->features[FEAT_7_0_EBX] && env->cpuid_level < 7) {
target-i386/cpu.c:        env->cpuid_level = 7;
target-i386/cpu.c:    if (env->cpuid_vendor1 == CPUID_VENDOR_AMD_1 &&
target-i386/cpu.c:        env->cpuid_vendor2 == CPUID_VENDOR_AMD_2 &&
target-i386/cpu.c:        env->cpuid_vendor3 == CPUID_VENDOR_AMD_3) {
target-i386/cpu.c:        env->features[FEAT_8000_0001_EDX] &= ~CPUID_EXT2_AMD_ALIASES;
target-i386/cpu.c:        env->features[FEAT_8000_0001_EDX] |= (env->features[FEAT_1_EDX]
target-i386/cpu.c:                        NULL, NULL, (void *)env->features, NULL);
target-i386/cpu.c:    env->cpuid_apic_id = x86_cpu_apic_id_from_index(cs->cpu_index);
target-i386/cpu.c:    return env->cpuid_apic_id;
target-i386/cpu.c:            (env->eflags & IF_MASK)) ||
target-i386/smm_helper.c:    env->hflags |= HF_SMM_MASK;
target-i386/smm_helper.c:    sm_state = env->smbase + 0x8000;
target-i386/smm_helper.c:        dt = &env->segs[i];
target-i386/smm_helper.c:    stq_phys(cs->as, sm_state + 0x7e68, env->gdt.base);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7e64, env->gdt.limit);
target-i386/smm_helper.c:    stw_phys(cs->as, sm_state + 0x7e70, env->ldt.selector);
target-i386/smm_helper.c:    stq_phys(cs->as, sm_state + 0x7e78, env->ldt.base);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7e74, env->ldt.limit);
target-i386/smm_helper.c:    stw_phys(cs->as, sm_state + 0x7e72, (env->ldt.flags >> 8) & 0xf0ff);
target-i386/smm_helper.c:    stq_phys(cs->as, sm_state + 0x7e88, env->idt.base);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7e84, env->idt.limit);
target-i386/smm_helper.c:    stw_phys(cs->as, sm_state + 0x7e90, env->tr.selector);
target-i386/smm_helper.c:    stq_phys(cs->as, sm_state + 0x7e98, env->tr.base);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7e94, env->tr.limit);
target-i386/smm_helper.c:    stw_phys(cs->as, sm_state + 0x7e92, (env->tr.flags >> 8) & 0xf0ff);
target-i386/smm_helper.c:    stq_phys(cs->as, sm_state + 0x7ed0, env->efer);
target-i386/smm_helper.c:    stq_phys(cs->as, sm_state + 0x7ff8, env->regs[R_EAX]);
target-i386/smm_helper.c:    stq_phys(cs->as, sm_state + 0x7ff0, env->regs[R_ECX]);
target-i386/smm_helper.c:    stq_phys(cs->as, sm_state + 0x7fe8, env->regs[R_EDX]);
target-i386/smm_helper.c:    stq_phys(cs->as, sm_state + 0x7fe0, env->regs[R_EBX]);
target-i386/smm_helper.c:    stq_phys(cs->as, sm_state + 0x7fd8, env->regs[R_ESP]);
target-i386/smm_helper.c:    stq_phys(cs->as, sm_state + 0x7fd0, env->regs[R_EBP]);
target-i386/smm_helper.c:    stq_phys(cs->as, sm_state + 0x7fc8, env->regs[R_ESI]);
target-i386/smm_helper.c:    stq_phys(cs->as, sm_state + 0x7fc0, env->regs[R_EDI]);
target-i386/smm_helper.c:        stq_phys(cs->as, sm_state + 0x7ff8 - i * 8, env->regs[i]);
target-i386/smm_helper.c:    stq_phys(cs->as, sm_state + 0x7f78, env->eip);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7f68, env->dr[6]);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7f60, env->dr[7]);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7f48, env->cr[4]);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7f50, env->cr[3]);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7f58, env->cr[0]);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7f00, env->smbase);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7ffc, env->cr[0]);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7ff8, env->cr[3]);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7ff0, env->eip);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7fec, env->regs[R_EDI]);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7fe8, env->regs[R_ESI]);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7fe4, env->regs[R_EBP]);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7fe0, env->regs[R_ESP]);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7fdc, env->regs[R_EBX]);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7fd8, env->regs[R_EDX]);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7fd4, env->regs[R_ECX]);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7fd0, env->regs[R_EAX]);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7fcc, env->dr[6]);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7fc8, env->dr[7]);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7fc4, env->tr.selector);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7f64, env->tr.base);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7f60, env->tr.limit);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7f5c, (env->tr.flags >> 8) & 0xf0ff);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7fc0, env->ldt.selector);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7f80, env->ldt.base);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7f7c, env->ldt.limit);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7f78, (env->ldt.flags >> 8) & 0xf0ff);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7f74, env->gdt.base);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7f70, env->gdt.limit);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7f58, env->idt.base);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7f54, env->idt.limit);
target-i386/smm_helper.c:        dt = &env->segs[i];
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7f14, env->cr[4]);
target-i386/smm_helper.c:    stl_phys(cs->as, sm_state + 0x7ef8, env->smbase);
target-i386/smm_helper.c:    env->eip = 0x00008000;
target-i386/smm_helper.c:                       env->cr[0] & ~(CR0_PE_MASK | CR0_EM_MASK | CR0_TS_MASK |
target-i386/smm_helper.c:    env->dr[7] = 0x00000400;
target-i386/smm_helper.c:    cpu_x86_load_seg_cache(env, R_CS, (env->smbase >> 4) & 0xffff, env->smbase,
target-i386/smm_helper.c:    sm_state = env->smbase + 0x8000;
target-i386/smm_helper.c:    env->gdt.base = ldq_phys(cs->as, sm_state + 0x7e68);
target-i386/smm_helper.c:    env->gdt.limit = ldl_phys(cs->as, sm_state + 0x7e64);
target-i386/smm_helper.c:    env->ldt.selector = lduw_phys(cs->as, sm_state + 0x7e70);
target-i386/smm_helper.c:    env->ldt.base = ldq_phys(cs->as, sm_state + 0x7e78);
target-i386/smm_helper.c:    env->ldt.limit = ldl_phys(cs->as, sm_state + 0x7e74);
target-i386/smm_helper.c:    env->ldt.flags = (lduw_phys(cs->as, sm_state + 0x7e72) & 0xf0ff) << 8;
target-i386/smm_helper.c:    env->idt.base = ldq_phys(cs->as, sm_state + 0x7e88);
target-i386/smm_helper.c:    env->idt.limit = ldl_phys(cs->as, sm_state + 0x7e84);
target-i386/smm_helper.c:    env->tr.selector = lduw_phys(cs->as, sm_state + 0x7e90);
target-i386/smm_helper.c:    env->tr.base = ldq_phys(cs->as, sm_state + 0x7e98);
target-i386/smm_helper.c:    env->tr.limit = ldl_phys(cs->as, sm_state + 0x7e94);
target-i386/smm_helper.c:    env->tr.flags = (lduw_phys(cs->as, sm_state + 0x7e92) & 0xf0ff) << 8;
target-i386/smm_helper.c:    env->regs[R_EAX] = ldq_phys(cs->as, sm_state + 0x7ff8);
target-i386/smm_helper.c:    env->regs[R_ECX] = ldq_phys(cs->as, sm_state + 0x7ff0);
target-i386/smm_helper.c:    env->regs[R_EDX] = ldq_phys(cs->as, sm_state + 0x7fe8);
target-i386/smm_helper.c:    env->regs[R_EBX] = ldq_phys(cs->as, sm_state + 0x7fe0);
target-i386/smm_helper.c:    env->regs[R_ESP] = ldq_phys(cs->as, sm_state + 0x7fd8);
target-i386/smm_helper.c:    env->regs[R_EBP] = ldq_phys(cs->as, sm_state + 0x7fd0);
target-i386/smm_helper.c:    env->regs[R_ESI] = ldq_phys(cs->as, sm_state + 0x7fc8);
target-i386/smm_helper.c:    env->regs[R_EDI] = ldq_phys(cs->as, sm_state + 0x7fc0);
target-i386/smm_helper.c:        env->regs[i] = ldq_phys(cs->as, sm_state + 0x7ff8 - i * 8);
target-i386/smm_helper.c:    env->eip = ldq_phys(cs->as, sm_state + 0x7f78);
target-i386/smm_helper.c:    env->dr[6] = ldl_phys(cs->as, sm_state + 0x7f68);
target-i386/smm_helper.c:    env->dr[7] = ldl_phys(cs->as, sm_state + 0x7f60);
target-i386/smm_helper.c:        env->smbase = ldl_phys(cs->as, sm_state + 0x7f00) & ~0x7fff;
target-i386/smm_helper.c:    env->eip = ldl_phys(cs->as, sm_state + 0x7ff0);
target-i386/smm_helper.c:    env->regs[R_EDI] = ldl_phys(cs->as, sm_state + 0x7fec);
target-i386/smm_helper.c:    env->regs[R_ESI] = ldl_phys(cs->as, sm_state + 0x7fe8);
target-i386/smm_helper.c:    env->regs[R_EBP] = ldl_phys(cs->as, sm_state + 0x7fe4);
target-i386/smm_helper.c:    env->regs[R_ESP] = ldl_phys(cs->as, sm_state + 0x7fe0);
target-i386/smm_helper.c:    env->regs[R_EBX] = ldl_phys(cs->as, sm_state + 0x7fdc);
target-i386/smm_helper.c:    env->regs[R_EDX] = ldl_phys(cs->as, sm_state + 0x7fd8);
target-i386/smm_helper.c:    env->regs[R_ECX] = ldl_phys(cs->as, sm_state + 0x7fd4);
target-i386/smm_helper.c:    env->regs[R_EAX] = ldl_phys(cs->as, sm_state + 0x7fd0);
target-i386/smm_helper.c:    env->dr[6] = ldl_phys(cs->as, sm_state + 0x7fcc);
target-i386/smm_helper.c:    env->dr[7] = ldl_phys(cs->as, sm_state + 0x7fc8);
target-i386/smm_helper.c:    env->tr.selector = ldl_phys(cs->as, sm_state + 0x7fc4) & 0xffff;
target-i386/smm_helper.c:    env->tr.base = ldl_phys(cs->as, sm_state + 0x7f64);
target-i386/smm_helper.c:    env->tr.limit = ldl_phys(cs->as, sm_state + 0x7f60);
target-i386/smm_helper.c:    env->tr.flags = (ldl_phys(cs->as, sm_state + 0x7f5c) & 0xf0ff) << 8;
target-i386/smm_helper.c:    env->ldt.selector = ldl_phys(cs->as, sm_state + 0x7fc0) & 0xffff;
target-i386/smm_helper.c:    env->ldt.base = ldl_phys(cs->as, sm_state + 0x7f80);
target-i386/smm_helper.c:    env->ldt.limit = ldl_phys(cs->as, sm_state + 0x7f7c);
target-i386/smm_helper.c:    env->ldt.flags = (ldl_phys(cs->as, sm_state + 0x7f78) & 0xf0ff) << 8;
target-i386/smm_helper.c:    env->gdt.base = ldl_phys(cs->as, sm_state + 0x7f74);
target-i386/smm_helper.c:    env->gdt.limit = ldl_phys(cs->as, sm_state + 0x7f70);
target-i386/smm_helper.c:    env->idt.base = ldl_phys(cs->as, sm_state + 0x7f58);
target-i386/smm_helper.c:    env->idt.limit = ldl_phys(cs->as, sm_state + 0x7f54);
target-i386/smm_helper.c:        env->smbase = ldl_phys(cs->as, sm_state + 0x7ef8) & ~0x7fff;
target-i386/smm_helper.c:    env->hflags &= ~HF_SMM_MASK;
target-i386/arch_memory_mapping.c:    if (env->cr[4] & CR4_PAE_MASK) {
target-i386/arch_memory_mapping.c:        if (env->hflags & HF_LMA_MASK) {
target-i386/arch_memory_mapping.c:            pml4e_addr = (env->cr[3] & PLM4_ADDR_MASK) & env->a20_mask;
target-i386/arch_memory_mapping.c:            walk_pml4e(list, cs->as, pml4e_addr, env->a20_mask);
target-i386/arch_memory_mapping.c:            pdpe_addr = (env->cr[3] & ~0x1f) & env->a20_mask;
target-i386/arch_memory_mapping.c:            walk_pdpe2(list, cs->as, pdpe_addr, env->a20_mask);
target-i386/arch_memory_mapping.c:        pde_addr = (env->cr[3] & ~0xfff) & env->a20_mask;
target-i386/arch_memory_mapping.c:        pse = !!(env->cr[4] & CR4_PSE_MASK);
target-i386/arch_memory_mapping.c:        walk_pde2(list, cs->as, pde_addr, env->a20_mask, pse);
target-i386/ops_sse.h:#define FPU_ADD(size, a, b) float ## size ## _add(a, b, &env->sse_status)
target-i386/ops_sse.h:#define FPU_SUB(size, a, b) float ## size ## _sub(a, b, &env->sse_status)
target-i386/ops_sse.h:#define FPU_MUL(size, a, b) float ## size ## _mul(a, b, &env->sse_status)
target-i386/ops_sse.h:#define FPU_DIV(size, a, b) float ## size ## _div(a, b, &env->sse_status)
target-i386/ops_sse.h:#define FPU_SQRT(size, a, b) float ## size ## _sqrt(b, &env->sse_status)
target-i386/ops_sse.h:    (float ## size ## _lt(a, b, &env->sse_status) ? (a) : (b))
target-i386/ops_sse.h:    (float ## size ## _lt(b, a, &env->sse_status) ? (a) : (b))
target-i386/ops_sse.h:    d->XMM_D(0) = float32_to_float64(s0, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(1) = float32_to_float64(s1, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = float64_to_float32(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(1) = float64_to_float32(s->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(0) = float32_to_float64(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = float64_to_float32(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = int32_to_float32(s->XMM_L(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(1) = int32_to_float32(s->XMM_L(1), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(2) = int32_to_float32(s->XMM_L(2), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(3) = int32_to_float32(s->XMM_L(3), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(0) = int32_to_float64(l0, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(1) = int32_to_float64(l1, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = int32_to_float32(s->MMX_L(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(1) = int32_to_float32(s->MMX_L(1), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(0) = int32_to_float64(s->MMX_L(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(1) = int32_to_float64(s->MMX_L(1), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = int32_to_float32(val, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(0) = int32_to_float64(val, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = int64_to_float32(val, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(0) = int64_to_float64(val, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(0) = float32_to_int32(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(1) = float32_to_int32(s->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(2) = float32_to_int32(s->XMM_S(2), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(3) = float32_to_int32(s->XMM_S(3), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(0) = float64_to_int32(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(1) = float64_to_int32(s->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:    d->MMX_L(0) = float32_to_int32(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    d->MMX_L(1) = float32_to_int32(s->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    d->MMX_L(0) = float64_to_int32(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    d->MMX_L(1) = float64_to_int32(s->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:    return float32_to_int32(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    return float64_to_int32(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    return float32_to_int64(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    return float64_to_int64(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(0) = float32_to_int32_round_to_zero(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(1) = float32_to_int32_round_to_zero(s->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(2) = float32_to_int32_round_to_zero(s->XMM_S(2), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(3) = float32_to_int32_round_to_zero(s->XMM_S(3), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(0) = float64_to_int32_round_to_zero(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(1) = float64_to_int32_round_to_zero(s->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:    d->MMX_L(0) = float32_to_int32_round_to_zero(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    d->MMX_L(1) = float32_to_int32_round_to_zero(s->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    d->MMX_L(0) = float64_to_int32_round_to_zero(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    d->MMX_L(1) = float64_to_int32_round_to_zero(s->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:    return float32_to_int32_round_to_zero(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    return float64_to_int32_round_to_zero(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    return float32_to_int64_round_to_zero(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    return float64_to_int64_round_to_zero(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:                              float32_sqrt(s->XMM_S(0), &env->sse_status),
target-i386/ops_sse.h:                              &env->sse_status);
target-i386/ops_sse.h:                              float32_sqrt(s->XMM_S(1), &env->sse_status),
target-i386/ops_sse.h:                              &env->sse_status);
target-i386/ops_sse.h:                              float32_sqrt(s->XMM_S(2), &env->sse_status),
target-i386/ops_sse.h:                              &env->sse_status);
target-i386/ops_sse.h:                              float32_sqrt(s->XMM_S(3), &env->sse_status),
target-i386/ops_sse.h:                              &env->sse_status);
target-i386/ops_sse.h:                              float32_sqrt(s->XMM_S(0), &env->sse_status),
target-i386/ops_sse.h:                              &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = float32_div(float32_one, s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(1) = float32_div(float32_one, s->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(2) = float32_div(float32_one, s->XMM_S(2), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(3) = float32_div(float32_one, s->XMM_S(3), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = float32_div(float32_one, s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_S(0) = float32_add(d->XMM_S(0), d->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_S(1) = float32_add(d->XMM_S(2), d->XMM_S(3), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_S(2) = float32_add(s->XMM_S(0), s->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_S(3) = float32_add(s->XMM_S(2), s->XMM_S(3), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_D(0) = float64_add(d->XMM_D(0), d->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_D(1) = float64_add(s->XMM_D(0), s->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_S(0) = float32_sub(d->XMM_S(0), d->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_S(1) = float32_sub(d->XMM_S(2), d->XMM_S(3), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_S(2) = float32_sub(s->XMM_S(0), s->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_S(3) = float32_sub(s->XMM_S(2), s->XMM_S(3), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_D(0) = float64_sub(d->XMM_D(0), d->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_D(1) = float64_sub(s->XMM_D(0), s->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = float32_sub(d->XMM_S(0), s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(1) = float32_add(d->XMM_S(1), s->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(2) = float32_sub(d->XMM_S(2), s->XMM_S(2), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(3) = float32_add(d->XMM_S(3), s->XMM_S(3), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(0) = float64_sub(d->XMM_D(0), s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(1) = float64_add(d->XMM_D(1), s->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:    (float ## size ## _eq_quiet(a, b, &env->sse_status) ? -1 : 0)
target-i386/ops_sse.h:    (float ## size ## _lt(a, b, &env->sse_status) ? -1 : 0)
target-i386/ops_sse.h:    (float ## size ## _le(a, b, &env->sse_status) ? -1 : 0)
target-i386/ops_sse.h:    (float ## size ## _unordered_quiet(a, b, &env->sse_status) ? -1 : 0)
target-i386/ops_sse.h:    (float ## size ## _eq_quiet(a, b, &env->sse_status) ? 0 : -1)
target-i386/ops_sse.h:    (float ## size ## _lt(a, b, &env->sse_status) ? 0 : -1)
target-i386/ops_sse.h:    (float ## size ## _le(a, b, &env->sse_status) ? 0 : -1)
target-i386/ops_sse.h:    (float ## size ## _unordered_quiet(a, b, &env->sse_status) ? 0 : -1)
target-i386/ops_sse.h:    ret = float32_compare_quiet(s0, s1, &env->sse_status);
target-i386/ops_sse.h:    ret = float32_compare(s0, s1, &env->sse_status);
target-i386/ops_sse.h:    ret = float64_compare_quiet(d0, d1, &env->sse_status);
target-i386/ops_sse.h:    ret = float64_compare(d0, d1, &env->sse_status);
target-i386/ops_sse.h:    d->MMX_S(0) = int32_to_float32(s->MMX_L(0), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(1) = int32_to_float32(s->MMX_L(1), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(0) = int32_to_float32((int16_t)s->MMX_W(0), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(1) = int32_to_float32((int16_t)s->MMX_W(2), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_L(0) = float32_to_int32_round_to_zero(s->MMX_S(0), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_L(1) = float32_to_int32_round_to_zero(s->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:                                                       &env->mmx_status));
target-i386/ops_sse.h:                                                       &env->mmx_status));
target-i386/ops_sse.h:    r.MMX_S(0) = float32_add(d->MMX_S(0), d->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:    r.MMX_S(1) = float32_add(s->MMX_S(0), s->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(0) = float32_add(d->MMX_S(0), s->MMX_S(0), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(1) = float32_add(d->MMX_S(1), s->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:                                   &env->mmx_status) ? -1 : 0;
target-i386/ops_sse.h:                                   &env->mmx_status) ? -1 : 0;
target-i386/ops_sse.h:                             &env->mmx_status) ? -1 : 0;
target-i386/ops_sse.h:                             &env->mmx_status) ? -1 : 0;
target-i386/ops_sse.h:                             &env->mmx_status) ? -1 : 0;
target-i386/ops_sse.h:                             &env->mmx_status) ? -1 : 0;
target-i386/ops_sse.h:    if (float32_lt(d->MMX_S(0), s->MMX_S(0), &env->mmx_status)) {
target-i386/ops_sse.h:    if (float32_lt(d->MMX_S(1), s->MMX_S(1), &env->mmx_status)) {
target-i386/ops_sse.h:    if (float32_lt(s->MMX_S(0), d->MMX_S(0), &env->mmx_status)) {
target-i386/ops_sse.h:    if (float32_lt(s->MMX_S(1), d->MMX_S(1), &env->mmx_status)) {
target-i386/ops_sse.h:    d->MMX_S(0) = float32_mul(d->MMX_S(0), s->MMX_S(0), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(1) = float32_mul(d->MMX_S(1), s->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:    r.MMX_S(0) = float32_sub(d->MMX_S(0), d->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:    r.MMX_S(1) = float32_sub(s->MMX_S(0), s->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:    r.MMX_S(0) = float32_sub(d->MMX_S(0), d->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:    r.MMX_S(1) = float32_add(s->MMX_S(0), s->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(0) = float32_div(float32_one, s->MMX_S(0), &env->mmx_status);
target-i386/ops_sse.h:                              float32_sqrt(d->MMX_S(1), &env->mmx_status),
target-i386/ops_sse.h:                              &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(0) = float32_sub(d->MMX_S(0), s->MMX_S(0), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(1) = float32_sub(d->MMX_S(1), s->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(0) = float32_sub(s->MMX_S(0), d->MMX_S(0), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(1) = float32_sub(s->MMX_S(1), d->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:#define XMM0 (env->xmm_regs[0])
target-i386/ops_sse.h:    prev_rounding_mode = env->sse_status.float_rounding_mode;
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_nearest_even, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_down, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_up, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_to_zero, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = float32_round_to_int(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(1) = float32_round_to_int(s->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(2) = float32_round_to_int(s->XMM_S(2), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(3) = float32_round_to_int(s->XMM_S(3), &env->sse_status);
target-i386/ops_sse.h:        set_float_exception_flags(get_float_exception_flags(&env->sse_status) &
target-i386/ops_sse.h:                                  &env->sse_status);
target-i386/ops_sse.h:    env->sse_status.float_rounding_mode = prev_rounding_mode;
target-i386/ops_sse.h:    prev_rounding_mode = env->sse_status.float_rounding_mode;
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_nearest_even, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_down, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_up, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_to_zero, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(0) = float64_round_to_int(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(1) = float64_round_to_int(s->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:        set_float_exception_flags(get_float_exception_flags(&env->sse_status) &
target-i386/ops_sse.h:                                  &env->sse_status);
target-i386/ops_sse.h:    env->sse_status.float_rounding_mode = prev_rounding_mode;
target-i386/ops_sse.h:    prev_rounding_mode = env->sse_status.float_rounding_mode;
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_nearest_even, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_down, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_up, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_to_zero, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = float32_round_to_int(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:        set_float_exception_flags(get_float_exception_flags(&env->sse_status) &
target-i386/ops_sse.h:                                  &env->sse_status);
target-i386/ops_sse.h:    env->sse_status.float_rounding_mode = prev_rounding_mode;
target-i386/ops_sse.h:    prev_rounding_mode = env->sse_status.float_rounding_mode;
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_nearest_even, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_down, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_up, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_to_zero, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(0) = float64_round_to_int(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:        set_float_exception_flags(get_float_exception_flags(&env->sse_status) &
target-i386/ops_sse.h:                                  &env->sse_status);
target-i386/ops_sse.h:    env->sse_status.float_rounding_mode = prev_rounding_mode;
target-i386/ops_sse.h:                                          &env->sse_status),
target-i386/ops_sse.h:                              &env->sse_status);
target-i386/ops_sse.h:                                          &env->sse_status),
target-i386/ops_sse.h:                              &env->sse_status);
target-i386/ops_sse.h:                                          &env->sse_status),
target-i386/ops_sse.h:                              &env->sse_status);
target-i386/ops_sse.h:                                          &env->sse_status),
target-i386/ops_sse.h:                              &env->sse_status);
target-i386/ops_sse.h:                                          &env->sse_status),
target-i386/ops_sse.h:                              &env->sse_status);
target-i386/ops_sse.h:                                          &env->sse_status),
target-i386/ops_sse.h:                              &env->sse_status);
target-i386/ops_sse.h:        val = abs1((int64_t)env->regs[reg]);
target-i386/ops_sse.h:        val = abs1((int32_t)env->regs[reg]);
target-i386/ops_sse.h:        env->regs[R_ECX] = (ctrl & (1 << 6)) ? 31 - clz32(res) : ctz32(res);
target-i386/ops_sse.h:        env->regs[R_ECX] = 16 >> (ctrl & (1 << 0));
target-i386/ops_sse.h:                env->xmm_regs[0].W(i) = (res & 1) ? ~0 : 0;
target-i386/ops_sse.h:                env->xmm_regs[0].B(i) = (res & 1) ? ~0 : 0;
target-i386/ops_sse.h:        env->xmm_regs[0].Q(1) = 0;
target-i386/ops_sse.h:        env->xmm_regs[0].Q(0) = res;
target-i386/ops_sse.h:        env->regs[R_ECX] = (ctrl & (1 << 6)) ? 31 - clz32(res) : ctz32(res);
target-i386/ops_sse.h:        env->regs[R_ECX] = 16 >> (ctrl & (1 << 0));
target-i386/ops_sse.h:                env->xmm_regs[0].W(i) = (res & 1) ? ~0 : 0;
target-i386/ops_sse.h:                env->xmm_regs[0].B(i) = (res & 1) ? ~0 : 0;
target-i386/ops_sse.h:        env->xmm_regs[0].Q(1) = 0;
target-i386/ops_sse.h:        env->xmm_regs[0].Q(0) = res;
target-i386/seg_helper.c:        dt = &env->ldt;
target-i386/seg_helper.c:        dt = &env->gdt;
target-i386/seg_helper.c:        printf("TR: base=%p limit=%x\n", env->tr.base, env->tr.limit);
target-i386/seg_helper.c:        for (i = 0; i < env->tr.limit; i++) {
target-i386/seg_helper.c:            printf("%02x ", env->tr.base[i]);
target-i386/seg_helper.c:    if (!(env->tr.flags & DESC_P_MASK)) {
target-i386/seg_helper.c:    type = (env->tr.flags >> DESC_TYPE_SHIFT) & 0xf;
target-i386/seg_helper.c:    if (index + (4 << shift) - 1 > env->tr.limit) {
target-i386/seg_helper.c:        raise_exception_err(env, EXCP0A_TSS, env->tr.selector & 0xfffc);
target-i386/seg_helper.c:        *esp_ptr = cpu_lduw_kernel(env, env->tr.base + index);
target-i386/seg_helper.c:        *ss_ptr = cpu_lduw_kernel(env, env->tr.base + index + 2);
target-i386/seg_helper.c:        *esp_ptr = cpu_ldl_kernel(env, env->tr.base + index);
target-i386/seg_helper.c:        *ss_ptr = cpu_lduw_kernel(env, env->tr.base + index + 4);
target-i386/seg_helper.c:    old_type = (env->tr.flags >> DESC_TYPE_SHIFT) & 0xf;
target-i386/seg_helper.c:    v1 = cpu_ldub_kernel(env, env->tr.base);
target-i386/seg_helper.c:    v2 = cpu_ldub_kernel(env, env->tr.base + old_tss_limit_max);
target-i386/seg_helper.c:    cpu_stb_kernel(env, env->tr.base, v1);
target-i386/seg_helper.c:    cpu_stb_kernel(env, env->tr.base + old_tss_limit_max, v2);
target-i386/seg_helper.c:        ptr = env->gdt.base + (env->tr.selector & ~7);
target-i386/seg_helper.c:        cpu_stl_kernel(env, env->tr.base + 0x20, next_eip);
target-i386/seg_helper.c:        cpu_stl_kernel(env, env->tr.base + 0x24, old_eflags);
target-i386/seg_helper.c:        cpu_stl_kernel(env, env->tr.base + (0x28 + 0 * 4), env->regs[R_EAX]);
target-i386/seg_helper.c:        cpu_stl_kernel(env, env->tr.base + (0x28 + 1 * 4), env->regs[R_ECX]);
target-i386/seg_helper.c:        cpu_stl_kernel(env, env->tr.base + (0x28 + 2 * 4), env->regs[R_EDX]);
target-i386/seg_helper.c:        cpu_stl_kernel(env, env->tr.base + (0x28 + 3 * 4), env->regs[R_EBX]);
target-i386/seg_helper.c:        cpu_stl_kernel(env, env->tr.base + (0x28 + 4 * 4), env->regs[R_ESP]);
target-i386/seg_helper.c:        cpu_stl_kernel(env, env->tr.base + (0x28 + 5 * 4), env->regs[R_EBP]);
target-i386/seg_helper.c:        cpu_stl_kernel(env, env->tr.base + (0x28 + 6 * 4), env->regs[R_ESI]);
target-i386/seg_helper.c:        cpu_stl_kernel(env, env->tr.base + (0x28 + 7 * 4), env->regs[R_EDI]);
target-i386/seg_helper.c:            cpu_stw_kernel(env, env->tr.base + (0x48 + i * 4),
target-i386/seg_helper.c:                           env->segs[i].selector);
target-i386/seg_helper.c:        cpu_stw_kernel(env, env->tr.base + 0x0e, next_eip);
target-i386/seg_helper.c:        cpu_stw_kernel(env, env->tr.base + 0x10, old_eflags);
target-i386/seg_helper.c:        cpu_stw_kernel(env, env->tr.base + (0x12 + 0 * 2), env->regs[R_EAX]);
target-i386/seg_helper.c:        cpu_stw_kernel(env, env->tr.base + (0x12 + 1 * 2), env->regs[R_ECX]);
target-i386/seg_helper.c:        cpu_stw_kernel(env, env->tr.base + (0x12 + 2 * 2), env->regs[R_EDX]);
target-i386/seg_helper.c:        cpu_stw_kernel(env, env->tr.base + (0x12 + 3 * 2), env->regs[R_EBX]);
target-i386/seg_helper.c:        cpu_stw_kernel(env, env->tr.base + (0x12 + 4 * 2), env->regs[R_ESP]);
target-i386/seg_helper.c:        cpu_stw_kernel(env, env->tr.base + (0x12 + 5 * 2), env->regs[R_EBP]);
target-i386/seg_helper.c:        cpu_stw_kernel(env, env->tr.base + (0x12 + 6 * 2), env->regs[R_ESI]);
target-i386/seg_helper.c:        cpu_stw_kernel(env, env->tr.base + (0x12 + 7 * 2), env->regs[R_EDI]);
target-i386/seg_helper.c:            cpu_stw_kernel(env, env->tr.base + (0x22 + i * 4),
target-i386/seg_helper.c:                           env->segs[i].selector);
target-i386/seg_helper.c:        cpu_stw_kernel(env, tss_base, env->tr.selector);
target-i386/seg_helper.c:        ptr = env->gdt.base + (tss_selector & ~7);
target-i386/seg_helper.c:    env->cr[0] |= CR0_TS_MASK;
target-i386/seg_helper.c:    env->hflags |= HF_TS_MASK;
target-i386/seg_helper.c:    env->tr.selector = tss_selector;
target-i386/seg_helper.c:    env->tr.base = tss_base;
target-i386/seg_helper.c:    env->tr.limit = tss_limit;
target-i386/seg_helper.c:    env->tr.flags = e2 & ~DESC_TSS_BUSY_MASK;
target-i386/seg_helper.c:    if ((type & 8) && (env->cr[0] & CR0_PG_MASK)) {
target-i386/seg_helper.c:    env->eip = new_eip;
target-i386/seg_helper.c:    env->regs[R_EAX] = new_regs[0];
target-i386/seg_helper.c:    env->regs[R_ECX] = new_regs[1];
target-i386/seg_helper.c:    env->regs[R_EDX] = new_regs[2];
target-i386/seg_helper.c:    env->regs[R_EBX] = new_regs[3];
target-i386/seg_helper.c:    env->regs[R_ESP] = new_regs[4];
target-i386/seg_helper.c:    env->regs[R_EBP] = new_regs[5];
target-i386/seg_helper.c:    env->regs[R_ESI] = new_regs[6];
target-i386/seg_helper.c:    env->regs[R_EDI] = new_regs[7];
target-i386/seg_helper.c:    env->ldt.selector = new_ldt & ~4;
target-i386/seg_helper.c:    env->ldt.base = 0;
target-i386/seg_helper.c:    env->ldt.limit = 0;
target-i386/seg_helper.c:    env->ldt.flags = 0;
target-i386/seg_helper.c:        dt = &env->gdt;
target-i386/seg_helper.c:        load_seg_cache_raw_dt(&env->ldt, e1, e2);
target-i386/seg_helper.c:    /* check that env->eip is in the CS segment limits */
target-i386/seg_helper.c:    if (new_eip > env->segs[R_CS].limit) {
target-i386/seg_helper.c:    if (env->dr[7] & DR7_LOCAL_BP_MASK) {
target-i386/seg_helper.c:            if (hw_local_breakpoint_enabled(env->dr[7], i) &&
target-i386/seg_helper.c:                !hw_global_breakpoint_enabled(env->dr[7], i)) {
target-i386/seg_helper.c:        env->dr[7] &= ~DR7_LOCAL_BP_MASK;
target-i386/seg_helper.c:            env->regs[R_ESP] = (env->regs[R_ESP] & ~0xffff) |   \
target-i386/seg_helper.c:            env->regs[R_ESP] = (uint32_t)(val);                 \
target-i386/seg_helper.c:            env->regs[R_ESP] = (val);                           \
target-i386/seg_helper.c:        env->regs[R_ESP] = (env->regs[R_ESP] & ~(sp_mask)) |    \
target-i386/seg_helper.c:    int vm86 = env->eflags & VM_MASK;
target-i386/seg_helper.c:        old_eip = env->eip;
target-i386/seg_helper.c:    dt = &env->idt;
target-i386/seg_helper.c:            type = (env->tr.flags >> DESC_TYPE_SHIFT) & 0xf;
target-i386/seg_helper.c:            if (env->segs[R_SS].flags & DESC_B_MASK) {
target-i386/seg_helper.c:            esp = (env->regs[R_ESP] - (2 << shift)) & mask;
target-i386/seg_helper.c:            ssp = env->segs[R_SS].base + esp;
target-i386/seg_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/seg_helper.c:        sp_mask = get_sp_mask(env->segs[R_SS].flags);
target-i386/seg_helper.c:        ssp = env->segs[R_SS].base;
target-i386/seg_helper.c:        esp = env->regs[R_ESP];
target-i386/seg_helper.c:                PUSHL(ssp, esp, sp_mask, env->segs[R_GS].selector);
target-i386/seg_helper.c:                PUSHL(ssp, esp, sp_mask, env->segs[R_FS].selector);
target-i386/seg_helper.c:                PUSHL(ssp, esp, sp_mask, env->segs[R_DS].selector);
target-i386/seg_helper.c:                PUSHL(ssp, esp, sp_mask, env->segs[R_ES].selector);
target-i386/seg_helper.c:            PUSHL(ssp, esp, sp_mask, env->segs[R_SS].selector);
target-i386/seg_helper.c:            PUSHL(ssp, esp, sp_mask, env->regs[R_ESP]);
target-i386/seg_helper.c:        PUSHL(ssp, esp, sp_mask, env->segs[R_CS].selector);
target-i386/seg_helper.c:                PUSHW(ssp, esp, sp_mask, env->segs[R_GS].selector);
target-i386/seg_helper.c:                PUSHW(ssp, esp, sp_mask, env->segs[R_FS].selector);
target-i386/seg_helper.c:                PUSHW(ssp, esp, sp_mask, env->segs[R_DS].selector);
target-i386/seg_helper.c:                PUSHW(ssp, esp, sp_mask, env->segs[R_ES].selector);
target-i386/seg_helper.c:            PUSHW(ssp, esp, sp_mask, env->segs[R_SS].selector);
target-i386/seg_helper.c:            PUSHW(ssp, esp, sp_mask, env->regs[R_ESP]);
target-i386/seg_helper.c:        PUSHW(ssp, esp, sp_mask, env->segs[R_CS].selector);
target-i386/seg_helper.c:        env->eflags &= ~IF_MASK;
target-i386/seg_helper.c:    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);
target-i386/seg_helper.c:    env->eip = offset;
target-i386/seg_helper.c:           env->tr.base, env->tr.limit);
target-i386/seg_helper.c:    if (!(env->tr.flags & DESC_P_MASK)) {
target-i386/seg_helper.c:    if ((index + 7) > env->tr.limit) {
target-i386/seg_helper.c:        raise_exception_err(env, EXCP0A_TSS, env->tr.selector & 0xfffc);
target-i386/seg_helper.c:    return cpu_ldq_kernel(env, env->tr.base + index);
target-i386/seg_helper.c:        old_eip = env->eip;
target-i386/seg_helper.c:    dt = &env->idt;
target-i386/seg_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/seg_helper.c:        if (env->eflags & VM_MASK) {
target-i386/seg_helper.c:            esp = env->regs[R_ESP];
target-i386/seg_helper.c:    PUSHQ(esp, env->segs[R_SS].selector);
target-i386/seg_helper.c:    PUSHQ(esp, env->regs[R_ESP]);
target-i386/seg_helper.c:    PUSHQ(esp, env->segs[R_CS].selector);
target-i386/seg_helper.c:        env->eflags &= ~IF_MASK;
target-i386/seg_helper.c:    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);
target-i386/seg_helper.c:    env->regs[R_ESP] = esp;
target-i386/seg_helper.c:    env->eip = offset;
target-i386/seg_helper.c:    env->exception_next_eip = env->eip + next_eip_addend;
target-i386/seg_helper.c:    if (!(env->efer & MSR_EFER_SCE)) {
target-i386/seg_helper.c:    selector = (env->star >> 32) & 0xffff;
target-i386/seg_helper.c:    if (env->hflags & HF_LMA_MASK) {
target-i386/seg_helper.c:        env->regs[R_ECX] = env->eip + next_eip_addend;
target-i386/seg_helper.c:        env->regs[11] = cpu_compute_eflags(env);
target-i386/seg_helper.c:        code64 = env->hflags & HF_CS64_MASK;
target-i386/seg_helper.c:        env->eflags &= ~env->fmask;
target-i386/seg_helper.c:        cpu_load_eflags(env, env->eflags, 0);
target-i386/seg_helper.c:            env->eip = env->lstar;
target-i386/seg_helper.c:            env->eip = env->cstar;
target-i386/seg_helper.c:        env->regs[R_ECX] = (uint32_t)(env->eip + next_eip_addend);
target-i386/seg_helper.c:        env->eflags &= ~(IF_MASK | RF_MASK | VM_MASK);
target-i386/seg_helper.c:        env->eip = (uint32_t)env->star;
target-i386/seg_helper.c:    if (!(env->efer & MSR_EFER_SCE)) {
target-i386/seg_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/seg_helper.c:    if (!(env->cr[0] & CR0_PE_MASK) || cpl != 0) {
target-i386/seg_helper.c:    selector = (env->star >> 48) & 0xffff;
target-i386/seg_helper.c:    if (env->hflags & HF_LMA_MASK) {
target-i386/seg_helper.c:        cpu_load_eflags(env, (uint32_t)(env->regs[11]), TF_MASK | AC_MASK
target-i386/seg_helper.c:            env->eip = env->regs[R_ECX];
target-i386/seg_helper.c:            env->eip = (uint32_t)env->regs[R_ECX];
target-i386/seg_helper.c:        env->eflags |= IF_MASK;
target-i386/seg_helper.c:        env->eip = (uint32_t)env->regs[R_ECX];
target-i386/seg_helper.c:    dt = &env->idt;
target-i386/seg_helper.c:    esp = env->regs[R_ESP];
target-i386/seg_helper.c:    ssp = env->segs[R_SS].base;
target-i386/seg_helper.c:        old_eip = env->eip;
target-i386/seg_helper.c:    old_cs = env->segs[R_CS].selector;
target-i386/seg_helper.c:    env->regs[R_ESP] = (env->regs[R_ESP] & ~0xffff) | (esp & 0xffff);
target-i386/seg_helper.c:    env->eip = offset;
target-i386/seg_helper.c:    env->segs[R_CS].selector = selector;
target-i386/seg_helper.c:    env->segs[R_CS].base = (selector << 4);
target-i386/seg_helper.c:    env->eflags &= ~(IF_MASK | TF_MASK | AC_MASK | RF_MASK);
target-i386/seg_helper.c:    dt = &env->idt;
target-i386/seg_helper.c:    if (env->hflags & HF_LMA_MASK) {
target-i386/seg_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/seg_helper.c:        env->eip = next_eip;
target-i386/seg_helper.c:    uint32_t event_inj = ldl_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb,
target-i386/seg_helper.c:            stl_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb,
target-i386/seg_helper.c:                 env->vm_vmcb + offsetof(struct vmcb, control.event_inj),
target-i386/seg_helper.c: * the int instruction. next_eip is the env->eip value AFTER the interrupt
target-i386/seg_helper.c:        if ((env->cr[0] & CR0_PE_MASK)) {
target-i386/seg_helper.c:                     env->hflags & HF_CPL_MASK,
target-i386/seg_helper.c:                     env->segs[R_CS].selector, env->eip,
target-i386/seg_helper.c:                     (int)env->segs[R_CS].base + env->eip,
target-i386/seg_helper.c:                     env->segs[R_SS].selector, env->regs[R_ESP]);
target-i386/seg_helper.c:                qemu_log(" CR2=" TARGET_FMT_lx, env->cr[2]);
target-i386/seg_helper.c:                qemu_log(" env->regs[R_EAX]=" TARGET_FMT_lx, env->regs[R_EAX]);
target-i386/seg_helper.c:                ptr = env->segs[R_CS].base + env->eip;
target-i386/seg_helper.c:    if (env->cr[0] & CR0_PE_MASK) {
target-i386/seg_helper.c:        if (env->hflags & HF_SVMI_MASK) {
target-i386/seg_helper.c:        if (env->hflags & HF_LMA_MASK) {
target-i386/seg_helper.c:        if (env->hflags & HF_SVMI_MASK) {
target-i386/seg_helper.c:    if (env->hflags & HF_SVMI_MASK) {
target-i386/seg_helper.c:        uint32_t event_inj = ldl_phys(cs->as, env->vm_vmcb +
target-i386/seg_helper.c:                 env->vm_vmcb + offsetof(struct vmcb, control.event_inj),
target-i386/seg_helper.c:                      env->exception_is_int,
target-i386/seg_helper.c:                      env->error_code,
target-i386/seg_helper.c:                      env->exception_next_eip);
target-i386/seg_helper.c:    env->old_exception = -1;
target-i386/seg_helper.c:                     env->exception_is_int,
target-i386/seg_helper.c:                     env->error_code,
target-i386/seg_helper.c:                     env->exception_next_eip, 0);
target-i386/seg_helper.c:    env->old_exception = -1;
target-i386/seg_helper.c:    esp_mask = get_sp_mask(env->segs[R_SS].flags);
target-i386/seg_helper.c:    ssp = env->segs[R_SS].base;
target-i386/seg_helper.c:    ebp = env->regs[R_EBP];
target-i386/seg_helper.c:    esp = env->regs[R_ESP];
target-i386/seg_helper.c:    ebp = env->regs[R_EBP];
target-i386/seg_helper.c:    esp = env->regs[R_ESP];
target-i386/seg_helper.c:        env->ldt.base = 0;
target-i386/seg_helper.c:        env->ldt.limit = 0;
target-i386/seg_helper.c:        dt = &env->gdt;
target-i386/seg_helper.c:        if (env->hflags & HF_LMA_MASK) {
target-i386/seg_helper.c:        if (env->hflags & HF_LMA_MASK) {
target-i386/seg_helper.c:            load_seg_cache_raw_dt(&env->ldt, e1, e2);
target-i386/seg_helper.c:            env->ldt.base |= (target_ulong)e3 << 32;
target-i386/seg_helper.c:            load_seg_cache_raw_dt(&env->ldt, e1, e2);
target-i386/seg_helper.c:    env->ldt.selector = selector;
target-i386/seg_helper.c:        env->tr.base = 0;
target-i386/seg_helper.c:        env->tr.limit = 0;
target-i386/seg_helper.c:        env->tr.flags = 0;
target-i386/seg_helper.c:        dt = &env->gdt;
target-i386/seg_helper.c:        if (env->hflags & HF_LMA_MASK) {
target-i386/seg_helper.c:        if (env->hflags & HF_LMA_MASK) {
target-i386/seg_helper.c:            load_seg_cache_raw_dt(&env->tr, e1, e2);
target-i386/seg_helper.c:            env->tr.base |= (target_ulong)e3 << 32;
target-i386/seg_helper.c:            load_seg_cache_raw_dt(&env->tr, e1, e2);
target-i386/seg_helper.c:    env->tr.selector = selector;
target-i386/seg_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/seg_helper.c:            && (!(env->hflags & HF_CS64_MASK) || cpl == 3)
target-i386/seg_helper.c:            dt = &env->ldt;
target-i386/seg_helper.c:            dt = &env->gdt;
target-i386/seg_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/seg_helper.c:            !(env->hflags & HF_LMA_MASK) && !(e2 & DESC_L_MASK)) {
target-i386/seg_helper.c:        env->eip = new_eip;
target-i386/seg_helper.c:        cpl = env->hflags & HF_CPL_MASK;
target-i386/seg_helper.c:            next_eip = env->eip + next_eip_addend;
target-i386/seg_helper.c:            env->eip = new_eip;
target-i386/seg_helper.c:    esp = env->regs[R_ESP];
target-i386/seg_helper.c:    esp_mask = get_sp_mask(env->segs[R_SS].flags);
target-i386/seg_helper.c:    ssp = env->segs[R_SS].base;
target-i386/seg_helper.c:        PUSHL(ssp, esp, esp_mask, env->segs[R_CS].selector);
target-i386/seg_helper.c:        PUSHW(ssp, esp, esp_mask, env->segs[R_CS].selector);
target-i386/seg_helper.c:    env->eip = new_eip;
target-i386/seg_helper.c:    env->segs[R_CS].selector = new_cs;
target-i386/seg_helper.c:    env->segs[R_CS].base = (new_cs << 4);
target-i386/seg_helper.c:    next_eip = env->eip + next_eip_addend;
target-i386/seg_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/seg_helper.c:            rsp = env->regs[R_ESP];
target-i386/seg_helper.c:            PUSHQ(rsp, env->segs[R_CS].selector);
target-i386/seg_helper.c:            env->regs[R_ESP] = rsp;
target-i386/seg_helper.c:            env->eip = new_eip;
target-i386/seg_helper.c:            sp = env->regs[R_ESP];
target-i386/seg_helper.c:            sp_mask = get_sp_mask(env->segs[R_SS].flags);
target-i386/seg_helper.c:            ssp = env->segs[R_SS].base;
target-i386/seg_helper.c:                PUSHL(ssp, sp, sp_mask, env->segs[R_CS].selector);
target-i386/seg_helper.c:                PUSHW(ssp, sp, sp_mask, env->segs[R_CS].selector);
target-i386/seg_helper.c:            env->eip = new_eip;
target-i386/seg_helper.c:            LOG_PCALL("new ss:esp=%04x:%08x param_count=%d env->regs[R_ESP]="
target-i386/seg_helper.c:                      env->regs[R_ESP]);
target-i386/seg_helper.c:            old_sp_mask = get_sp_mask(env->segs[R_SS].flags);
target-i386/seg_helper.c:            old_ssp = env->segs[R_SS].base;
target-i386/seg_helper.c:                PUSHL(ssp, sp, sp_mask, env->segs[R_SS].selector);
target-i386/seg_helper.c:                PUSHL(ssp, sp, sp_mask, env->regs[R_ESP]);
target-i386/seg_helper.c:                                         ((env->regs[R_ESP] + i * 4) &
target-i386/seg_helper.c:                PUSHW(ssp, sp, sp_mask, env->segs[R_SS].selector);
target-i386/seg_helper.c:                PUSHW(ssp, sp, sp_mask, env->regs[R_ESP]);
target-i386/seg_helper.c:                                          ((env->regs[R_ESP] + i * 2) &
target-i386/seg_helper.c:            sp = env->regs[R_ESP];
target-i386/seg_helper.c:            sp_mask = get_sp_mask(env->segs[R_SS].flags);
target-i386/seg_helper.c:            ssp = env->segs[R_SS].base;
target-i386/seg_helper.c:            PUSHL(ssp, sp, sp_mask, env->segs[R_CS].selector);
target-i386/seg_helper.c:            PUSHW(ssp, sp, sp_mask, env->segs[R_CS].selector);
target-i386/seg_helper.c:        env->eip = offset;
target-i386/seg_helper.c:    sp = env->regs[R_ESP];
target-i386/seg_helper.c:    ssp = env->segs[R_SS].base;
target-i386/seg_helper.c:    env->regs[R_ESP] = (env->regs[R_ESP] & ~sp_mask) | (sp & sp_mask);
target-i386/seg_helper.c:    env->segs[R_CS].selector = new_cs;
target-i386/seg_helper.c:    env->segs[R_CS].base = (new_cs << 4);
target-i386/seg_helper.c:    env->eip = new_eip;
target-i386/seg_helper.c:    if (env->eflags & VM_MASK) {
target-i386/seg_helper.c:    env->hflags2 &= ~HF2_NMI_MASK;
target-i386/seg_helper.c:        (env->segs[seg_reg].selector & 0xfffc) == 0) {
target-i386/seg_helper.c:    e2 = env->segs[seg_reg].flags;
target-i386/seg_helper.c:        sp_mask = get_sp_mask(env->segs[R_SS].flags);
target-i386/seg_helper.c:    sp = env->regs[R_ESP];
target-i386/seg_helper.c:    ssp = env->segs[R_SS].base;
target-i386/seg_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/seg_helper.c:    if (rpl == cpl && (!(env->hflags & HF_CS64_MASK) ||
target-i386/seg_helper.c:                       ((env->hflags & HF_CS64_MASK) && !is_iret))) {
target-i386/seg_helper.c:            if ((env->hflags & HF_LMA_MASK) && rpl != 3) {
target-i386/seg_helper.c:        if (env->hflags & HF_CS64_MASK) {
target-i386/seg_helper.c:    env->eip = new_eip;
target-i386/seg_helper.c:        iopl = (env->eflags >> IOPL_SHIFT) & 3;
target-i386/seg_helper.c:    env->eip = new_eip & 0xffff;
target-i386/seg_helper.c:    env->regs[R_ESP] = new_esp;
target-i386/seg_helper.c:    if (env->eflags & NT_MASK) {
target-i386/seg_helper.c:        if (env->hflags & HF_LMA_MASK) {
target-i386/seg_helper.c:        tss_selector = cpu_lduw_kernel(env, env->tr.base + 0);
target-i386/seg_helper.c:    env->hflags2 &= ~HF2_NMI_MASK;
target-i386/seg_helper.c:    if (env->sysenter_cs == 0) {
target-i386/seg_helper.c:    env->eflags &= ~(VM_MASK | IF_MASK | RF_MASK);
target-i386/seg_helper.c:    if (env->hflags & HF_LMA_MASK) {
target-i386/seg_helper.c:        cpu_x86_load_seg_cache(env, R_CS, env->sysenter_cs & 0xfffc,
target-i386/seg_helper.c:        cpu_x86_load_seg_cache(env, R_CS, env->sysenter_cs & 0xfffc,
target-i386/seg_helper.c:    cpu_x86_load_seg_cache(env, R_SS, (env->sysenter_cs + 8) & 0xfffc,
target-i386/seg_helper.c:    env->regs[R_ESP] = env->sysenter_esp;
target-i386/seg_helper.c:    env->eip = env->sysenter_eip;
target-i386/seg_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/seg_helper.c:    if (env->sysenter_cs == 0 || cpl != 0) {
target-i386/seg_helper.c:        cpu_x86_load_seg_cache(env, R_CS, ((env->sysenter_cs + 32) & 0xfffc) |
target-i386/seg_helper.c:        cpu_x86_load_seg_cache(env, R_SS, ((env->sysenter_cs + 40) & 0xfffc) |
target-i386/seg_helper.c:        cpu_x86_load_seg_cache(env, R_CS, ((env->sysenter_cs + 16) & 0xfffc) |
target-i386/seg_helper.c:        cpu_x86_load_seg_cache(env, R_SS, ((env->sysenter_cs + 24) & 0xfffc) |
target-i386/seg_helper.c:    env->regs[R_ESP] = env->regs[R_ECX];
target-i386/seg_helper.c:    env->eip = env->regs[R_EDX];
target-i386/seg_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/seg_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/seg_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/seg_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/seg_helper.c:    if (!(env->cr[0] & CR0_PE_MASK) || (env->eflags & VM_MASK)) {
target-i386/seg_helper.c:        int dpl = (env->eflags & VM_MASK) ? 3 : 0;
target-i386/seg_helper.c:    if (!(env->tr.flags & DESC_P_MASK) ||
target-i386/seg_helper.c:        ((env->tr.flags >> DESC_TYPE_SHIFT) & 0xf) != 9 ||
target-i386/seg_helper.c:        env->tr.limit < 103) {
target-i386/seg_helper.c:    io_offset = cpu_lduw_kernel(env, env->tr.base + 0x66);
target-i386/seg_helper.c:    if ((io_offset + 1) > env->tr.limit) {
target-i386/seg_helper.c:    val = cpu_lduw_kernel(env, env->tr.base + io_offset);
target-i386/cc_helper.c:    eflags |= (env->df & DF_MASK);
target-i386/cc_helper.c:    eflags |= env->eflags & ~(VM_MASK | RF_MASK);
target-i386/cc_helper.c:    env->cr[0] &= ~CR0_TS_MASK;
target-i386/cc_helper.c:    env->hflags &= ~HF_TS_MASK;
target-i386/cc_helper.c:    env->eflags &= ~RF_MASK;
target-i386/cc_helper.c:    env->eflags &= ~IF_MASK;
target-i386/cc_helper.c:    env->eflags |= IF_MASK;
target-i386/cc_helper.c:    env->eflags &= ~AC_MASK;
target-i386/cc_helper.c:    env->eflags |= AC_MASK;
target-i386/cc_helper.c:    env->eflags &= ~VIF_MASK;
target-i386/cc_helper.c:    env->eflags |= VIF_MASK;
target-i386/cc_helper.c:    if (env->eflags & VIP_MASK) {
target-i386/cc_helper.c:    env->hflags |= HF_INHIBIT_IRQ_MASK;
target-i386/cc_helper.c:    env->hflags &= ~HF_INHIBIT_IRQ_MASK;
target-i386/svm_helper.c:        addr = env->regs[R_EAX];
target-i386/svm_helper.c:        addr = (uint32_t)env->regs[R_EAX];
target-i386/svm_helper.c:    env->vm_vmcb = addr;
target-i386/svm_helper.c:    stq_phys(cs->as, env->vm_hsave + offsetof(struct vmcb, save.gdtr.base),
target-i386/svm_helper.c:             env->gdt.base);
target-i386/svm_helper.c:    stl_phys(cs->as, env->vm_hsave + offsetof(struct vmcb, save.gdtr.limit),
target-i386/svm_helper.c:             env->gdt.limit);
target-i386/svm_helper.c:    stq_phys(cs->as, env->vm_hsave + offsetof(struct vmcb, save.idtr.base),
target-i386/svm_helper.c:             env->idt.base);
target-i386/svm_helper.c:    stl_phys(cs->as, env->vm_hsave + offsetof(struct vmcb, save.idtr.limit),
target-i386/svm_helper.c:             env->idt.limit);
target-i386/svm_helper.c:             env->vm_hsave + offsetof(struct vmcb, save.cr0), env->cr[0]);
target-i386/svm_helper.c:             env->vm_hsave + offsetof(struct vmcb, save.cr2), env->cr[2]);
target-i386/svm_helper.c:             env->vm_hsave + offsetof(struct vmcb, save.cr3), env->cr[3]);
target-i386/svm_helper.c:             env->vm_hsave + offsetof(struct vmcb, save.cr4), env->cr[4]);
target-i386/svm_helper.c:             env->vm_hsave + offsetof(struct vmcb, save.dr6), env->dr[6]);
target-i386/svm_helper.c:             env->vm_hsave + offsetof(struct vmcb, save.dr7), env->dr[7]);
target-i386/svm_helper.c:             env->vm_hsave + offsetof(struct vmcb, save.efer), env->efer);
target-i386/svm_helper.c:             env->vm_hsave + offsetof(struct vmcb, save.rflags),
target-i386/svm_helper.c:    svm_save_seg(env, env->vm_hsave + offsetof(struct vmcb, save.es),
target-i386/svm_helper.c:                 &env->segs[R_ES]);
target-i386/svm_helper.c:    svm_save_seg(env, env->vm_hsave + offsetof(struct vmcb, save.cs),
target-i386/svm_helper.c:                 &env->segs[R_CS]);
target-i386/svm_helper.c:    svm_save_seg(env, env->vm_hsave + offsetof(struct vmcb, save.ss),
target-i386/svm_helper.c:                 &env->segs[R_SS]);
target-i386/svm_helper.c:    svm_save_seg(env, env->vm_hsave + offsetof(struct vmcb, save.ds),
target-i386/svm_helper.c:                 &env->segs[R_DS]);
target-i386/svm_helper.c:    stq_phys(cs->as, env->vm_hsave + offsetof(struct vmcb, save.rip),
target-i386/svm_helper.c:             env->eip + next_eip_addend);
target-i386/svm_helper.c:             env->vm_hsave + offsetof(struct vmcb, save.rsp), env->regs[R_ESP]);
target-i386/svm_helper.c:             env->vm_hsave + offsetof(struct vmcb, save.rax), env->regs[R_EAX]);
target-i386/svm_helper.c:    env->intercept = ldq_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb,
target-i386/svm_helper.c:    env->intercept_cr_read = lduw_phys(cs->as, env->vm_vmcb +
target-i386/svm_helper.c:    env->intercept_cr_write = lduw_phys(cs->as, env->vm_vmcb +
target-i386/svm_helper.c:    env->intercept_dr_read = lduw_phys(cs->as, env->vm_vmcb +
target-i386/svm_helper.c:    env->intercept_dr_write = lduw_phys(cs->as, env->vm_vmcb +
target-i386/svm_helper.c:    env->intercept_exceptions = ldl_phys(cs->as, env->vm_vmcb +
target-i386/svm_helper.c:    env->hflags |= HF_SVMI_MASK;
target-i386/svm_helper.c:    env->tsc_offset = ldq_phys(cs->as, env->vm_vmcb +
target-i386/svm_helper.c:    env->gdt.base  = ldq_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb,
target-i386/svm_helper.c:    env->gdt.limit = ldl_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb,
target-i386/svm_helper.c:    env->idt.base  = ldq_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb,
target-i386/svm_helper.c:    env->idt.limit = ldl_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb,
target-i386/svm_helper.c:             env->vm_vmcb + offsetof(struct vmcb, control.exit_info_2), 0);
target-i386/svm_helper.c:                                     env->vm_vmcb + offsetof(struct vmcb,
target-i386/svm_helper.c:                                     env->vm_vmcb + offsetof(struct vmcb,
target-i386/svm_helper.c:                                     env->vm_vmcb + offsetof(struct vmcb,
target-i386/svm_helper.c:    env->cr[2] = ldq_phys(cs->as,
target-i386/svm_helper.c:                          env->vm_vmcb + offsetof(struct vmcb, save.cr2));
target-i386/svm_helper.c:                       env->vm_vmcb + offsetof(struct vmcb, control.int_ctl));
target-i386/svm_helper.c:    env->hflags2 &= ~(HF2_HIF_MASK | HF2_VINTR_MASK);
target-i386/svm_helper.c:        env->v_tpr = int_ctl & V_TPR_MASK;
target-i386/svm_helper.c:        env->hflags2 |= HF2_VINTR_MASK;
target-i386/svm_helper.c:        if (env->eflags & IF_MASK) {
target-i386/svm_helper.c:            env->hflags2 |= HF2_HIF_MASK;
target-i386/svm_helper.c:                           env->vm_vmcb + offsetof(struct vmcb, save.efer)));
target-i386/svm_helper.c:    env->eflags = 0;
target-i386/svm_helper.c:                                  env->vm_vmcb + offsetof(struct vmcb,
target-i386/svm_helper.c:    svm_load_seg_cache(env, env->vm_vmcb + offsetof(struct vmcb, save.es),
target-i386/svm_helper.c:    svm_load_seg_cache(env, env->vm_vmcb + offsetof(struct vmcb, save.cs),
target-i386/svm_helper.c:    svm_load_seg_cache(env, env->vm_vmcb + offsetof(struct vmcb, save.ss),
target-i386/svm_helper.c:    svm_load_seg_cache(env, env->vm_vmcb + offsetof(struct vmcb, save.ds),
target-i386/svm_helper.c:    env->eip = ldq_phys(cs->as,
target-i386/svm_helper.c:                        env->vm_vmcb + offsetof(struct vmcb, save.rip));
target-i386/svm_helper.c:    env->regs[R_ESP] = ldq_phys(cs->as,
target-i386/svm_helper.c:                                env->vm_vmcb + offsetof(struct vmcb, save.rsp));
target-i386/svm_helper.c:    env->regs[R_EAX] = ldq_phys(cs->as,
target-i386/svm_helper.c:                                env->vm_vmcb + offsetof(struct vmcb, save.rax));
target-i386/svm_helper.c:    env->dr[7] = ldq_phys(cs->as,
target-i386/svm_helper.c:                          env->vm_vmcb + offsetof(struct vmcb, save.dr7));
target-i386/svm_helper.c:    env->dr[6] = ldq_phys(cs->as,
target-i386/svm_helper.c:                          env->vm_vmcb + offsetof(struct vmcb, save.dr6));
target-i386/svm_helper.c:                      env->vm_vmcb + offsetof(struct vmcb, control.tlb_ctl))) {
target-i386/svm_helper.c:    env->hflags2 |= HF2_GIF_MASK;
target-i386/svm_helper.c:    event_inj = ldl_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb,
target-i386/svm_helper.c:        uint32_t event_inj_err = ldl_phys(cs->as, env->vm_vmcb +
target-i386/svm_helper.c:            env->error_code = event_inj_err;
target-i386/svm_helper.c:            env->exception_is_int = 0;
target-i386/svm_helper.c:            env->exception_next_eip = -1;
target-i386/svm_helper.c:            env->error_code = event_inj_err;
target-i386/svm_helper.c:            env->exception_is_int = 0;
target-i386/svm_helper.c:            env->exception_next_eip = env->eip;
target-i386/svm_helper.c:            env->error_code = event_inj_err;
target-i386/svm_helper.c:            env->exception_is_int = 0;
target-i386/svm_helper.c:            env->exception_next_eip = -1;
target-i386/svm_helper.c:            env->error_code = event_inj_err;
target-i386/svm_helper.c:            env->exception_is_int = 1;
target-i386/svm_helper.c:            env->exception_next_eip = env->eip;
target-i386/svm_helper.c:                      env->error_code);
target-i386/svm_helper.c:        addr = env->regs[R_EAX];
target-i386/svm_helper.c:        addr = (uint32_t)env->regs[R_EAX];
target-i386/svm_helper.c:                  env->segs[R_FS].base);
target-i386/svm_helper.c:    svm_load_seg(env, addr + offsetof(struct vmcb, save.tr), &env->tr);
target-i386/svm_helper.c:    svm_load_seg(env, addr + offsetof(struct vmcb, save.ldtr), &env->ldt);
target-i386/svm_helper.c:    env->kernelgsbase = ldq_phys(cs->as, addr + offsetof(struct vmcb,
target-i386/svm_helper.c:    env->lstar = ldq_phys(cs->as, addr + offsetof(struct vmcb, save.lstar));
target-i386/svm_helper.c:    env->cstar = ldq_phys(cs->as, addr + offsetof(struct vmcb, save.cstar));
target-i386/svm_helper.c:    env->fmask = ldq_phys(cs->as, addr + offsetof(struct vmcb, save.sfmask));
target-i386/svm_helper.c:    env->star = ldq_phys(cs->as, addr + offsetof(struct vmcb, save.star));
target-i386/svm_helper.c:    env->sysenter_cs = ldq_phys(cs->as,
target-i386/svm_helper.c:    env->sysenter_esp = ldq_phys(cs->as, addr + offsetof(struct vmcb,
target-i386/svm_helper.c:    env->sysenter_eip = ldq_phys(cs->as, addr + offsetof(struct vmcb,
target-i386/svm_helper.c:        addr = env->regs[R_EAX];
target-i386/svm_helper.c:        addr = (uint32_t)env->regs[R_EAX];
target-i386/svm_helper.c:                  env->segs[R_FS].base);
target-i386/svm_helper.c:                 &env->segs[R_FS]);
target-i386/svm_helper.c:                 &env->segs[R_GS]);
target-i386/svm_helper.c:                 &env->tr);
target-i386/svm_helper.c:                 &env->ldt);
target-i386/svm_helper.c:             env->kernelgsbase);
target-i386/svm_helper.c:    stq_phys(cs->as, addr + offsetof(struct vmcb, save.lstar), env->lstar);
target-i386/svm_helper.c:    stq_phys(cs->as, addr + offsetof(struct vmcb, save.cstar), env->cstar);
target-i386/svm_helper.c:    stq_phys(cs->as, addr + offsetof(struct vmcb, save.sfmask), env->fmask);
target-i386/svm_helper.c:    stq_phys(cs->as, addr + offsetof(struct vmcb, save.star), env->star);
target-i386/svm_helper.c:             addr + offsetof(struct vmcb, save.sysenter_cs), env->sysenter_cs);
target-i386/svm_helper.c:             env->sysenter_esp);
target-i386/svm_helper.c:             env->sysenter_eip);
target-i386/svm_helper.c:    env->hflags2 |= HF2_GIF_MASK;
target-i386/svm_helper.c:    env->hflags2 &= ~HF2_GIF_MASK;
target-i386/svm_helper.c:        addr = env->regs[R_EAX];
target-i386/svm_helper.c:        addr = (uint32_t)env->regs[R_EAX];
target-i386/svm_helper.c:    if (likely(!(env->hflags & HF_SVMI_MASK))) {
target-i386/svm_helper.c:        if (env->intercept_cr_read & (1 << (type - SVM_EXIT_READ_CR0))) {
target-i386/svm_helper.c:        if (env->intercept_cr_write & (1 << (type - SVM_EXIT_WRITE_CR0))) {
target-i386/svm_helper.c:        if (env->intercept_dr_read & (1 << (type - SVM_EXIT_READ_DR0))) {
target-i386/svm_helper.c:        if (env->intercept_dr_write & (1 << (type - SVM_EXIT_WRITE_DR0))) {
target-i386/svm_helper.c:        if (env->intercept_exceptions & (1 << (type - SVM_EXIT_EXCP_BASE))) {
target-i386/svm_helper.c:        if (env->intercept & (1ULL << (SVM_EXIT_MSR - SVM_EXIT_INTR))) {
target-i386/svm_helper.c:            uint64_t addr = ldq_phys(cs->as, env->vm_vmcb +
target-i386/svm_helper.c:            switch ((uint32_t)env->regs[R_ECX]) {
target-i386/svm_helper.c:                t0 = (env->regs[R_ECX] * 2) % 8;
target-i386/svm_helper.c:                t1 = (env->regs[R_ECX] * 2) / 8;
target-i386/svm_helper.c:                t0 = (8192 + env->regs[R_ECX] - 0xc0000000) * 2;
target-i386/svm_helper.c:                t0 = (16384 + env->regs[R_ECX] - 0xc0010000) * 2;
target-i386/svm_helper.c:        if (env->intercept & (1ULL << (type - SVM_EXIT_INTR))) {
target-i386/svm_helper.c:    if (env->intercept & (1ULL << (SVM_EXIT_IOIO - SVM_EXIT_INTR))) {
target-i386/svm_helper.c:        uint64_t addr = ldq_phys(cs->as, env->vm_vmcb +
target-i386/svm_helper.c:            /* next env->eip */
target-i386/svm_helper.c:                     env->vm_vmcb + offsetof(struct vmcb, control.exit_info_2),
target-i386/svm_helper.c:                     env->eip + next_eip_addend);
target-i386/svm_helper.c:                  ldq_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb,
target-i386/svm_helper.c:                  env->eip);
target-i386/svm_helper.c:    if (env->hflags & HF_INHIBIT_IRQ_MASK) {
target-i386/svm_helper.c:                 env->vm_vmcb + offsetof(struct vmcb, control.int_state),
target-i386/svm_helper.c:        env->hflags &= ~HF_INHIBIT_IRQ_MASK;
target-i386/svm_helper.c:                 env->vm_vmcb + offsetof(struct vmcb, control.int_state), 0);
target-i386/svm_helper.c:    svm_save_seg(env, env->vm_vmcb + offsetof(struct vmcb, save.es),
target-i386/svm_helper.c:                 &env->segs[R_ES]);
target-i386/svm_helper.c:    svm_save_seg(env, env->vm_vmcb + offsetof(struct vmcb, save.cs),
target-i386/svm_helper.c:                 &env->segs[R_CS]);
target-i386/svm_helper.c:    svm_save_seg(env, env->vm_vmcb + offsetof(struct vmcb, save.ss),
target-i386/svm_helper.c:                 &env->segs[R_SS]);
target-i386/svm_helper.c:    svm_save_seg(env, env->vm_vmcb + offsetof(struct vmcb, save.ds),
target-i386/svm_helper.c:                 &env->segs[R_DS]);
target-i386/svm_helper.c:    stq_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb, save.gdtr.base),
target-i386/svm_helper.c:             env->gdt.base);
target-i386/svm_helper.c:    stl_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb, save.gdtr.limit),
target-i386/svm_helper.c:             env->gdt.limit);
target-i386/svm_helper.c:    stq_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb, save.idtr.base),
target-i386/svm_helper.c:             env->idt.base);
target-i386/svm_helper.c:    stl_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb, save.idtr.limit),
target-i386/svm_helper.c:             env->idt.limit);
target-i386/svm_helper.c:             env->vm_vmcb + offsetof(struct vmcb, save.efer), env->efer);
target-i386/svm_helper.c:             env->vm_vmcb + offsetof(struct vmcb, save.cr0), env->cr[0]);
target-i386/svm_helper.c:             env->vm_vmcb + offsetof(struct vmcb, save.cr2), env->cr[2]);
target-i386/svm_helper.c:             env->vm_vmcb + offsetof(struct vmcb, save.cr3), env->cr[3]);
target-i386/svm_helper.c:             env->vm_vmcb + offsetof(struct vmcb, save.cr4), env->cr[4]);
target-i386/svm_helper.c:                       env->vm_vmcb + offsetof(struct vmcb, control.int_ctl));
target-i386/svm_helper.c:    int_ctl |= env->v_tpr & V_TPR_MASK;
target-i386/svm_helper.c:             env->vm_vmcb + offsetof(struct vmcb, control.int_ctl), int_ctl);
target-i386/svm_helper.c:    stq_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb, save.rflags),
target-i386/svm_helper.c:    stq_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb, save.rip),
target-i386/svm_helper.c:             env->eip);
target-i386/svm_helper.c:             env->vm_vmcb + offsetof(struct vmcb, save.rsp), env->regs[R_ESP]);
target-i386/svm_helper.c:             env->vm_vmcb + offsetof(struct vmcb, save.rax), env->regs[R_EAX]);
target-i386/svm_helper.c:             env->vm_vmcb + offsetof(struct vmcb, save.dr7), env->dr[7]);
target-i386/svm_helper.c:             env->vm_vmcb + offsetof(struct vmcb, save.dr6), env->dr[6]);
target-i386/svm_helper.c:    stb_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb, save.cpl),
target-i386/svm_helper.c:             env->hflags & HF_CPL_MASK);
target-i386/svm_helper.c:    env->hflags2 &= ~(HF2_HIF_MASK | HF2_VINTR_MASK);
target-i386/svm_helper.c:    env->hflags &= ~HF_SVMI_MASK;
target-i386/svm_helper.c:    env->intercept = 0;
target-i386/svm_helper.c:    env->intercept_exceptions = 0;
target-i386/svm_helper.c:    env->tsc_offset = 0;
target-i386/svm_helper.c:    env->gdt.base  = ldq_phys(cs->as, env->vm_hsave + offsetof(struct vmcb,
target-i386/svm_helper.c:    env->gdt.limit = ldl_phys(cs->as, env->vm_hsave + offsetof(struct vmcb,
target-i386/svm_helper.c:    env->idt.base  = ldq_phys(cs->as, env->vm_hsave + offsetof(struct vmcb,
target-i386/svm_helper.c:    env->idt.limit = ldl_phys(cs->as, env->vm_hsave + offsetof(struct vmcb,
target-i386/svm_helper.c:                                     env->vm_hsave + offsetof(struct vmcb,
target-i386/svm_helper.c:                                     env->vm_hsave + offsetof(struct vmcb,
target-i386/svm_helper.c:                                     env->vm_hsave + offsetof(struct vmcb,
target-i386/svm_helper.c:    cpu_load_efer(env, ldq_phys(cs->as, env->vm_hsave + offsetof(struct vmcb,
target-i386/svm_helper.c:    env->eflags = 0;
target-i386/svm_helper.c:                                  env->vm_hsave + offsetof(struct vmcb,
target-i386/svm_helper.c:    svm_load_seg_cache(env, env->vm_hsave + offsetof(struct vmcb, save.es),
target-i386/svm_helper.c:    svm_load_seg_cache(env, env->vm_hsave + offsetof(struct vmcb, save.cs),
target-i386/svm_helper.c:    svm_load_seg_cache(env, env->vm_hsave + offsetof(struct vmcb, save.ss),
target-i386/svm_helper.c:    svm_load_seg_cache(env, env->vm_hsave + offsetof(struct vmcb, save.ds),
target-i386/svm_helper.c:    env->eip = ldq_phys(cs->as,
target-i386/svm_helper.c:                        env->vm_hsave + offsetof(struct vmcb, save.rip));
target-i386/svm_helper.c:    env->regs[R_ESP] = ldq_phys(cs->as, env->vm_hsave +
target-i386/svm_helper.c:    env->regs[R_EAX] = ldq_phys(cs->as, env->vm_hsave +
target-i386/svm_helper.c:    env->dr[6] = ldq_phys(cs->as,
target-i386/svm_helper.c:                          env->vm_hsave + offsetof(struct vmcb, save.dr6));
target-i386/svm_helper.c:    env->dr[7] = ldq_phys(cs->as,
target-i386/svm_helper.c:                          env->vm_hsave + offsetof(struct vmcb, save.dr7));
target-i386/svm_helper.c:    stq_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb, control.exit_code),
target-i386/svm_helper.c:    stq_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb, control.exit_info_1),
target-i386/svm_helper.c:             env->vm_vmcb + offsetof(struct vmcb, control.exit_int_info),
target-i386/svm_helper.c:             ldl_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb,
target-i386/svm_helper.c:             env->vm_vmcb + offsetof(struct vmcb, control.exit_int_info_err),
target-i386/svm_helper.c:             ldl_phys(cs->as, env->vm_vmcb + offsetof(struct vmcb,
target-i386/svm_helper.c:             env->vm_vmcb + offsetof(struct vmcb, control.event_inj), 0);
target-i386/svm_helper.c:    env->hflags2 &= ~HF2_GIF_MASK;
target-i386/svm_helper.c:    env->error_code = 0;
target-i386/svm_helper.c:    env->old_exception = -1;
target-i386/int_helper.c:    num = (env->regs[R_EAX] & 0xffff);
target-i386/int_helper.c:    env->regs[R_EAX] = (env->regs[R_EAX] & ~0xffff) | (r << 8) | q;
target-i386/int_helper.c:    num = (int16_t)env->regs[R_EAX];
target-i386/int_helper.c:    env->regs[R_EAX] = (env->regs[R_EAX] & ~0xffff) | (r << 8) | q;
target-i386/int_helper.c:    num = (env->regs[R_EAX] & 0xffff) | ((env->regs[R_EDX] & 0xffff) << 16);
target-i386/int_helper.c:    env->regs[R_EAX] = (env->regs[R_EAX] & ~0xffff) | q;
target-i386/int_helper.c:    env->regs[R_EDX] = (env->regs[R_EDX] & ~0xffff) | r;
target-i386/int_helper.c:    num = (env->regs[R_EAX] & 0xffff) | ((env->regs[R_EDX] & 0xffff) << 16);
target-i386/int_helper.c:    env->regs[R_EAX] = (env->regs[R_EAX] & ~0xffff) | q;
target-i386/int_helper.c:    env->regs[R_EDX] = (env->regs[R_EDX] & ~0xffff) | r;
target-i386/int_helper.c:    num = ((uint32_t)env->regs[R_EAX]) | ((uint64_t)((uint32_t)env->regs[R_EDX]) << 32);
target-i386/int_helper.c:    env->regs[R_EAX] = (uint32_t)q;
target-i386/int_helper.c:    env->regs[R_EDX] = (uint32_t)r;
target-i386/int_helper.c:    num = ((uint32_t)env->regs[R_EAX]) | ((uint64_t)((uint32_t)env->regs[R_EDX]) << 32);
target-i386/int_helper.c:    env->regs[R_EAX] = (uint32_t)q;
target-i386/int_helper.c:    env->regs[R_EDX] = (uint32_t)r;
target-i386/int_helper.c:    al = env->regs[R_EAX] & 0xff;
target-i386/int_helper.c:    env->regs[R_EAX] = (env->regs[R_EAX] & ~0xffff) | al | (ah << 8);
target-i386/int_helper.c:    al = env->regs[R_EAX] & 0xff;
target-i386/int_helper.c:    ah = (env->regs[R_EAX] >> 8) & 0xff;
target-i386/int_helper.c:    env->regs[R_EAX] = (env->regs[R_EAX] & ~0xffff) | al;
target-i386/int_helper.c:    al = env->regs[R_EAX] & 0xff;
target-i386/int_helper.c:    ah = (env->regs[R_EAX] >> 8) & 0xff;
target-i386/int_helper.c:    env->regs[R_EAX] = (env->regs[R_EAX] & ~0xffff) | al | (ah << 8);
target-i386/int_helper.c:    al = env->regs[R_EAX] & 0xff;
target-i386/int_helper.c:    ah = (env->regs[R_EAX] >> 8) & 0xff;
target-i386/int_helper.c:    env->regs[R_EAX] = (env->regs[R_EAX] & ~0xffff) | al | (ah << 8);
target-i386/int_helper.c:    old_al = al = env->regs[R_EAX] & 0xff;
target-i386/int_helper.c:    env->regs[R_EAX] = (env->regs[R_EAX] & ~0xff) | al;
target-i386/int_helper.c:    al = env->regs[R_EAX] & 0xff;
target-i386/int_helper.c:    env->regs[R_EAX] = (env->regs[R_EAX] & ~0xff) | al;
target-i386/int_helper.c:    r0 = env->regs[R_EAX];
target-i386/int_helper.c:    r1 = env->regs[R_EDX];
target-i386/int_helper.c:    env->regs[R_EAX] = r0;
target-i386/int_helper.c:    env->regs[R_EDX] = r1;
target-i386/int_helper.c:    r0 = env->regs[R_EAX];
target-i386/int_helper.c:    r1 = env->regs[R_EDX];
target-i386/int_helper.c:    env->regs[R_EAX] = r0;
target-i386/int_helper.c:    env->regs[R_EDX] = r1;
target-unicore32/translate.c:    if ((env->uncached_asr & ASR_M) == ASR_MODE_USER) {
target-unicore32/translate.c:        d.d = env->ucf64.regs[i];
target-unicore32/translate.c:    cpu_fprintf(f, "FPSCR: %08x\n", (int)env->ucf64.xregs[UC32_UCF64_FPSCR]);
target-unicore32/translate.c:        cpu_fprintf(f, "R%02d=%08x", i, env->regs[i]);
target-unicore32/translate.c:    env->regs[31] = tcg_ctx.gen_opc_pc[pc_pos];
target-unicore32/ucf64_helper.c:    fpscr = (env->ucf64.xregs[UC32_UCF64_FPSCR] & UCF64_FPSCR_MASK);
target-unicore32/ucf64_helper.c:    i = get_float_exception_flags(&env->ucf64.fp_status);
target-unicore32/ucf64_helper.c:    changed = env->ucf64.xregs[UC32_UCF64_FPSCR];
target-unicore32/ucf64_helper.c:    env->ucf64.xregs[UC32_UCF64_FPSCR] = (val & UCF64_FPSCR_MASK);
target-unicore32/ucf64_helper.c:        set_float_rounding_mode(i, &env->ucf64.fp_status);
target-unicore32/ucf64_helper.c:    set_float_exception_flags(i, &env->ucf64.fp_status);
target-unicore32/ucf64_helper.c:    return float32_add(a, b, &env->ucf64.fp_status);
target-unicore32/ucf64_helper.c:    return float64_add(a, b, &env->ucf64.fp_status);
target-unicore32/ucf64_helper.c:    return float32_sub(a, b, &env->ucf64.fp_status);
target-unicore32/ucf64_helper.c:    return float64_sub(a, b, &env->ucf64.fp_status);
target-unicore32/ucf64_helper.c:    return float32_mul(a, b, &env->ucf64.fp_status);
target-unicore32/ucf64_helper.c:    return float64_mul(a, b, &env->ucf64.fp_status);
target-unicore32/ucf64_helper.c:    return float32_div(a, b, &env->ucf64.fp_status);
target-unicore32/ucf64_helper.c:    return float64_div(a, b, &env->ucf64.fp_status);
target-unicore32/ucf64_helper.c:    flag = float32_compare_quiet(a, b, &env->ucf64.fp_status);
target-unicore32/ucf64_helper.c:    env->CF = 0;
target-unicore32/ucf64_helper.c:            env->CF = 1;
target-unicore32/ucf64_helper.c:            env->CF = 1;
target-unicore32/ucf64_helper.c:            env->CF = 1;
target-unicore32/ucf64_helper.c:            env->CF = 1;
target-unicore32/ucf64_helper.c:            env->CF = 1;
target-unicore32/ucf64_helper.c:            env->CF = 1;
target-unicore32/ucf64_helper.c:            env->CF = 1;
target-unicore32/ucf64_helper.c:    env->ucf64.xregs[UC32_UCF64_FPSCR] = (env->CF << 29)
target-unicore32/ucf64_helper.c:                    | (env->ucf64.xregs[UC32_UCF64_FPSCR] & 0x0fffffff);
target-unicore32/ucf64_helper.c:    flag = float64_compare_quiet(a, b, &env->ucf64.fp_status);
target-unicore32/ucf64_helper.c:    env->CF = 0;
target-unicore32/ucf64_helper.c:            env->CF = 1;
target-unicore32/ucf64_helper.c:            env->CF = 1;
target-unicore32/ucf64_helper.c:            env->CF = 1;
target-unicore32/ucf64_helper.c:            env->CF = 1;
target-unicore32/ucf64_helper.c:            env->CF = 1;
target-unicore32/ucf64_helper.c:            env->CF = 1;
target-unicore32/ucf64_helper.c:            env->CF = 1;
target-unicore32/ucf64_helper.c:    env->ucf64.xregs[UC32_UCF64_FPSCR] = (env->CF << 29)
target-unicore32/ucf64_helper.c:                    | (env->ucf64.xregs[UC32_UCF64_FPSCR] & 0x0fffffff);
target-unicore32/ucf64_helper.c:    return int32_to_float32(ucf64_stoi(x), &env->ucf64.fp_status);
target-unicore32/ucf64_helper.c:    return int32_to_float64(ucf64_stoi(x), &env->ucf64.fp_status);
target-unicore32/ucf64_helper.c:    return ucf64_itos(float32_to_int32(x, &env->ucf64.fp_status));
target-unicore32/ucf64_helper.c:    return ucf64_itos(float64_to_int32(x, &env->ucf64.fp_status));
target-unicore32/ucf64_helper.c:    return float32_to_float64(x, &env->ucf64.fp_status);
target-unicore32/ucf64_helper.c:    return float64_to_float32(x, &env->ucf64.fp_status);
target-unicore32/helper.c:        env->cp0.c1_sys = val;
target-unicore32/helper.c:        env->cp0.c2_base = val;
target-unicore32/helper.c:        env->cp0.c3_faultstatus = val;
target-unicore32/helper.c:        env->cp0.c4_faultaddr = val;
target-unicore32/helper.c:            return env->cp0.c0_cpuid;
target-unicore32/helper.c:            return env->cp0.c0_cachetype;
target-unicore32/helper.c:            return env->cp0.c1_sys;
target-unicore32/helper.c:            return env->cp0.c2_base;
target-unicore32/helper.c:            return env->cp0.c3_faultstatus;
target-unicore32/helper.c:            return env->cp0.c4_faultaddr;
target-unicore32/softmmu.c:    old_mode = env->uncached_asr & ASR_M;
target-unicore32/softmmu.c:    env->banked_r29[i] = env->regs[29];
target-unicore32/softmmu.c:    env->banked_r30[i] = env->regs[30];
target-unicore32/softmmu.c:    env->banked_bsr[i] = env->bsr;
target-unicore32/softmmu.c:    env->regs[29] = env->banked_r29[i];
target-unicore32/softmmu.c:    env->regs[30] = env->banked_r30[i];
target-unicore32/softmmu.c:    env->bsr = env->banked_bsr[i];
target-unicore32/softmmu.c:        DPRINTF("itrap happened at %x\n", env->regs[31]);
target-unicore32/softmmu.c:        DPRINTF("dtrap happened at %x\n", env->regs[31]);
target-unicore32/softmmu.c:    if (env->cp0.c1_sys & (1 << 13)) {
target-unicore32/softmmu.c:    env->bsr = cpu_asr_read(env);
target-unicore32/softmmu.c:    env->uncached_asr = (env->uncached_asr & ~ASR_M) | new_mode;
target-unicore32/softmmu.c:    env->uncached_asr |= ASR_I;
target-unicore32/softmmu.c:    env->regs[30] = env->regs[31];
target-unicore32/softmmu.c:    env->regs[31] = addr;
target-unicore32/softmmu.c:    table = env->cp0.c2_base & 0xfffff000;
target-unicore32/softmmu.c:    if ((env->cp0.c1_sys & 1) == 0) {
target-unicore32/softmmu.c:    env->cp0.c3_faultstatus = ret;
target-unicore32/softmmu.c:    env->cp0.c4_faultaddr = address;
target-unicore32/cpu.h:    return (env->uncached_asr & ASR_M) == ASR_MODE_USER ? 1 : 0;
target-unicore32/cpu.h:    *pc = env->regs[31];
target-unicore32/cpu.h:    if ((env->uncached_asr & ASR_M) != ASR_MODE_USER) {
target-unicore32/cpu.c:    env->features |= feature;
target-unicore32/cpu.c:    env->cp0.c0_cpuid = 0x4d000863;
target-unicore32/cpu.c:    env->cp0.c0_cachetype = 0x0d152152;
target-unicore32/cpu.c:    env->cp0.c1_sys = 0x2000;
target-unicore32/cpu.c:    env->cp0.c2_base = 0x0;
target-unicore32/cpu.c:    env->cp0.c3_faultstatus = 0x0;
target-unicore32/cpu.c:    env->cp0.c4_faultaddr = 0x0;
target-unicore32/cpu.c:    env->ucf64.xregs[UC32_UCF64_FPSCR] = 0;
target-unicore32/cpu.c:    env->cp0.c0_cpuid = 0xffffffff;
target-unicore32/cpu.c:    env->ucf64.xregs[UC32_UCF64_FPSCR] = 0;
target-unicore32/cpu.c:    env->uncached_asr = ASR_MODE_USER;
target-unicore32/cpu.c:    env->regs[31] = 0;
target-unicore32/cpu.c:    env->uncached_asr = ASR_MODE_PRIV;
target-unicore32/cpu.c:    env->regs[31] = 0x03000000;
target-unicore32/op_helper.c:    ZF = (env->ZF == 0);
target-unicore32/op_helper.c:    return env->uncached_asr | (env->NF & 0x80000000) | (ZF << 30) |
target-unicore32/op_helper.c:        (env->CF << 29) | ((env->VF & 0x80000000) >> 3);
target-unicore32/op_helper.c:        env->ZF = (~val) & ASR_Z;
target-unicore32/op_helper.c:        env->NF = val;
target-unicore32/op_helper.c:        env->CF = (val >> 29) & 1;
target-unicore32/op_helper.c:        env->VF = (val << 3) & 0x80000000;
target-unicore32/op_helper.c:    if ((env->uncached_asr ^ val) & mask & ASR_M) {
target-unicore32/op_helper.c:    env->uncached_asr = (env->uncached_asr & ~mask) | (val & mask);
target-unicore32/op_helper.c:        val = env->banked_r29[0];
target-unicore32/op_helper.c:        val = env->banked_r30[0];
target-unicore32/op_helper.c:        val = env->regs[regno];
target-unicore32/op_helper.c:        env->banked_r29[0] = val;
target-unicore32/op_helper.c:        env->banked_r30[0] = val;
target-unicore32/op_helper.c:        env->regs[regno] = val;
target-unicore32/op_helper.c:    env->NF = env->ZF = result;
target-unicore32/op_helper.c:    env->CF = result < a;
target-unicore32/op_helper.c:    env->VF = (a ^ b ^ -1) & (a ^ result);
target-unicore32/op_helper.c:    if (!env->CF) {
target-unicore32/op_helper.c:        env->CF = result < a;
target-unicore32/op_helper.c:        env->CF = result <= a;
target-unicore32/op_helper.c:    env->VF = (a ^ b ^ -1) & (a ^ result);
target-unicore32/op_helper.c:    env->NF = env->ZF = result;
target-unicore32/op_helper.c:    env->NF = env->ZF = result;
target-unicore32/op_helper.c:    env->CF = a >= b;
target-unicore32/op_helper.c:    env->VF = (a ^ b) & (a ^ result);
target-unicore32/op_helper.c:    if (!env->CF) {
target-unicore32/op_helper.c:        env->CF = a > b;
target-unicore32/op_helper.c:        env->CF = a >= b;
target-unicore32/op_helper.c:    env->VF = (a ^ b) & (a ^ result);
target-unicore32/op_helper.c:    env->NF = env->ZF = result;
target-unicore32/op_helper.c:            env->CF = x & 1;
target-unicore32/op_helper.c:            env->CF = 0;
target-unicore32/op_helper.c:        env->CF = (x >> (32 - shift)) & 1;
target-unicore32/op_helper.c:            env->CF = (x >> 31) & 1;
target-unicore32/op_helper.c:            env->CF = 0;
target-unicore32/op_helper.c:        env->CF = (x >> (shift - 1)) & 1;
target-unicore32/op_helper.c:        env->CF = (x >> 31) & 1;
target-unicore32/op_helper.c:        env->CF = (x >> (shift - 1)) & 1;
target-unicore32/op_helper.c:            env->CF = (x >> 31) & 1;
target-unicore32/op_helper.c:        env->CF = (x >> (shift - 1)) & 1;
target-microblaze/gdbstub.c:        return gdb_get_reg32(mem_buf, env->regs[n]);
target-microblaze/gdbstub.c:        return gdb_get_reg32(mem_buf, env->sregs[n - 32]);
target-microblaze/gdbstub.c:        env->regs[n] = tmp;
target-microblaze/gdbstub.c:        env->sregs[n - 32] = tmp;
target-microblaze/mmu.c:    struct microblaze_mmu *mmu = &env->mmu;
target-microblaze/mmu.c:    struct microblaze_mmu *mmu = &env->mmu;
target-microblaze/mmu.c:    if (env->mmu.c_mmu < 2 || !env->mmu.c_mmu_tlb_access) {
target-microblaze/mmu.c:            if (!(env->mmu.c_mmu_tlb_access & 1)) {
target-microblaze/mmu.c:            i = env->mmu.regs[MMU_R_TLBX] & 0xff;
target-microblaze/mmu.c:            r = env->mmu.rams[rn & 1][i];
target-microblaze/mmu.c:                env->mmu.regs[MMU_R_PID] = env->mmu.tids[i];
target-microblaze/mmu.c:            if (!(env->mmu.c_mmu_tlb_access & 1)) {
target-microblaze/mmu.c:            r = env->mmu.regs[rn];
target-microblaze/mmu.c:            r = env->mmu.regs[rn];
target-microblaze/mmu.c:    D(qemu_log("%s rn=%d=%x old=%x\n", __func__, rn, v, env->mmu.regs[rn]));
target-microblaze/mmu.c:    if (env->mmu.c_mmu < 2 || !env->mmu.c_mmu_tlb_access) {
target-microblaze/mmu.c:            i = env->mmu.regs[MMU_R_TLBX] & 0xff;
target-microblaze/mmu.c:                             i, env->sregs[SR_PC]);
target-microblaze/mmu.c:                env->mmu.tids[i] = env->mmu.regs[MMU_R_PID] & 0xff;
target-microblaze/mmu.c:            env->mmu.rams[rn & 1][i] = v;
target-microblaze/mmu.c:            if (env->mmu.c_mmu_tlb_access <= 1) {
target-microblaze/mmu.c:            if (v != env->mmu.regs[rn]) {
target-microblaze/mmu.c:            env->mmu.regs[rn] = v;
target-microblaze/mmu.c:            if (env->mmu.c_mmu_tlb_access <= 1) {
target-microblaze/mmu.c:            if (v != env->mmu.regs[rn]) {
target-microblaze/mmu.c:                env->mmu.regs[rn] = v;
target-microblaze/mmu.c:            if (env->mmu.c_mmu_tlb_access <= 1) {
target-microblaze/mmu.c:            hit = mmu_translate(&env->mmu, &lu,
target-microblaze/mmu.c:                env->mmu.regs[MMU_R_TLBX] = lu.idx;
target-microblaze/mmu.c:                env->mmu.regs[MMU_R_TLBX] |= 0x80000000;
target-microblaze/mmu.c:            env->mmu.regs[rn] = v;
target-microblaze/translate.c:                env->sregs[SR_PC], lookup_symbol(env->sregs[SR_PC]));
target-microblaze/translate.c:             env->sregs[SR_MSR], env->sregs[SR_ESR], env->sregs[SR_EAR],
target-microblaze/translate.c:             env->debug, env->imm, env->iflags, env->sregs[SR_FSR]);
target-microblaze/translate.c:             env->btaken, env->btarget,
target-microblaze/translate.c:             (env->sregs[SR_MSR] & MSR_UM) ? "user" : "kernel",
target-microblaze/translate.c:             (env->sregs[SR_MSR] & MSR_UMS) ? "user" : "kernel",
target-microblaze/translate.c:             (env->sregs[SR_MSR] & MSR_EIP),
target-microblaze/translate.c:             (env->sregs[SR_MSR] & MSR_IE));
target-microblaze/translate.c:        cpu_fprintf(f, "r%2.2d=%8.8x ", i, env->regs[i]);
target-microblaze/translate.c:    env->sregs[SR_PC] = tcg_ctx.gen_opc_pc[pc_pos];
target-microblaze/helper.c:    env->res_addr = RES_ADDR_NONE;
target-microblaze/helper.c:    env->regs[14] = env->sregs[SR_PC];
target-microblaze/helper.c:    if (env->pvr.regs[0] & PVR0_USE_MMU) {
target-microblaze/helper.c:        if ((env->pvr.regs[0] & PVR0_PVR_FULL_MASK)
target-microblaze/helper.c:            && (env->pvr.regs[11] & PVR11_USE_MMU) != PVR11_USE_MMU) {
target-microblaze/helper.c:    if (mmu_available && (env->sregs[SR_MSR] & MSR_VM)) {
target-microblaze/helper.c:        hit = mmu_translate(&env->mmu, &lu, address, rw, mmu_idx);
target-microblaze/helper.c:            env->sregs[SR_EAR] = address;
target-microblaze/helper.c:                    env->sregs[SR_ESR] = rw == 2 ? 17 : 16;
target-microblaze/helper.c:                    env->sregs[SR_ESR] |= (rw == 1) << 10;
target-microblaze/helper.c:                    env->sregs[SR_ESR] = rw == 2 ? 19 : 18;
target-microblaze/helper.c:                    env->sregs[SR_ESR] |= (rw == 1) << 10;
target-microblaze/helper.c:    assert(!((env->iflags & D_FLAG) && (env->iflags & IMM_FLAG)));
target-microblaze/helper.c:    assert(!(env->iflags & (DRTI_FLAG | DRTE_FLAG | DRTB_FLAG)));
target-microblaze/helper.c:/*    assert(env->sregs[SR_MSR] & (MSR_EE)); Only for HW exceptions.  */
target-microblaze/helper.c:    env->res_addr = RES_ADDR_NONE;
target-microblaze/helper.c:            if (!(env->pvr.regs[0] & PVR0_USE_EXC_MASK)) {
target-microblaze/helper.c:            env->regs[17] = env->sregs[SR_PC] + 4;
target-microblaze/helper.c:            env->sregs[SR_ESR] &= ~(1 << 12);
target-microblaze/helper.c:            if (env->iflags & D_FLAG) {
target-microblaze/helper.c:                env->sregs[SR_ESR] |= 1 << 12 ;
target-microblaze/helper.c:                env->sregs[SR_BTR] = env->btarget;
target-microblaze/helper.c:            t = (env->sregs[SR_MSR] & (MSR_VM | MSR_UM)) << 1;
target-microblaze/helper.c:            env->sregs[SR_MSR] &= ~(MSR_VMS | MSR_UMS | MSR_VM | MSR_UM);
target-microblaze/helper.c:            env->sregs[SR_MSR] |= t;
target-microblaze/helper.c:            env->sregs[SR_MSR] |= MSR_EIP;
target-microblaze/helper.c:                          env->sregs[SR_PC], env->sregs[SR_EAR],
target-microblaze/helper.c:                          env->sregs[SR_ESR], env->iflags);
target-microblaze/helper.c:            env->iflags &= ~(IMM_FLAG | D_FLAG);
target-microblaze/helper.c:            env->sregs[SR_PC] = cpu->base_vectors + 0x20;
target-microblaze/helper.c:            env->regs[17] = env->sregs[SR_PC];
target-microblaze/helper.c:            env->sregs[SR_ESR] &= ~(1 << 12);
target-microblaze/helper.c:            if (env->iflags & D_FLAG) {
target-microblaze/helper.c:                D(qemu_log("D_FLAG set at exception bimm=%d\n", env->bimm));
target-microblaze/helper.c:                env->sregs[SR_ESR] |= 1 << 12 ;
target-microblaze/helper.c:                env->sregs[SR_BTR] = env->btarget;
target-microblaze/helper.c:                env->regs[17] -= 4;
target-microblaze/helper.c:                if (env->bimm) {
target-microblaze/helper.c:                                  env->sregs[SR_PC], env->iflags);
target-microblaze/helper.c:                    env->regs[17] -= 4;
target-microblaze/helper.c:            } else if (env->iflags & IMM_FLAG) {
target-microblaze/helper.c:                env->regs[17] -= 4;
target-microblaze/helper.c:            t = (env->sregs[SR_MSR] & (MSR_VM | MSR_UM)) << 1;
target-microblaze/helper.c:            env->sregs[SR_MSR] &= ~(MSR_VMS | MSR_UMS | MSR_VM | MSR_UM);
target-microblaze/helper.c:            env->sregs[SR_MSR] |= t;
target-microblaze/helper.c:            env->sregs[SR_MSR] |= MSR_EIP;
target-microblaze/helper.c:                          env->sregs[SR_PC], env->sregs[SR_EAR], env->iflags);
target-microblaze/helper.c:            env->iflags &= ~(IMM_FLAG | D_FLAG);
target-microblaze/helper.c:            env->sregs[SR_PC] = cpu->base_vectors + 0x20;
target-microblaze/helper.c:            assert(!(env->sregs[SR_MSR] & (MSR_EIP | MSR_BIP)));
target-microblaze/helper.c:            assert(env->sregs[SR_MSR] & MSR_IE);
target-microblaze/helper.c:            assert(!(env->iflags & D_FLAG));
target-microblaze/helper.c:            t = (env->sregs[SR_MSR] & (MSR_VM | MSR_UM)) << 1;
target-microblaze/helper.c:                sym = lookup_symbol(env->sregs[SR_PC]);
target-microblaze/helper.c:                         env->sregs[SR_PC], env->sregs[SR_MSR], t, env->iflags,
target-microblaze/helper.c:                         env->sregs[SR_PC], env->sregs[SR_MSR], t, env->iflags);
target-microblaze/helper.c:            env->sregs[SR_MSR] &= ~(MSR_VMS | MSR_UMS | MSR_VM \
target-microblaze/helper.c:            env->sregs[SR_MSR] |= t;
target-microblaze/helper.c:            env->regs[14] = env->sregs[SR_PC];
target-microblaze/helper.c:            env->sregs[SR_PC] = cpu->base_vectors + 0x10;
target-microblaze/helper.c:            assert(!(env->iflags & IMM_FLAG));
target-microblaze/helper.c:            assert(!(env->iflags & D_FLAG));
target-microblaze/helper.c:            t = (env->sregs[SR_MSR] & (MSR_VM | MSR_UM)) << 1;
target-microblaze/helper.c:                        env->sregs[SR_PC], env->sregs[SR_MSR], t, env->iflags);
target-microblaze/helper.c:            env->sregs[SR_MSR] &= ~(MSR_VMS | MSR_UMS | MSR_VM | MSR_UM);
target-microblaze/helper.c:            env->sregs[SR_MSR] |= t;
target-microblaze/helper.c:            env->sregs[SR_MSR] |= MSR_BIP;
target-microblaze/helper.c:                env->regs[16] = env->sregs[SR_PC];
target-microblaze/helper.c:                env->sregs[SR_MSR] |= MSR_BIP;
target-microblaze/helper.c:                env->sregs[SR_PC] = cpu->base_vectors + 0x18;
target-microblaze/helper.c:                env->sregs[SR_PC] = env->btarget;
target-microblaze/helper.c:    if (env->sregs[SR_MSR] & MSR_VM) {
target-microblaze/helper.c:        hit = mmu_translate(&env->mmu, &lu, addr, 0, 0);
target-microblaze/cpu.h:    CC_OP_DYNAMIC, /* Use env->cc_op  */
target-microblaze/cpu.h:        if (!(env->sregs[SR_MSR] & MSR_VM))
target-microblaze/cpu.h:	if (env->sregs[SR_MSR] & MSR_UM)
target-microblaze/cpu.h:    return env->sregs[SR_MSR] & MSR_IE;
target-microblaze/cpu.h:    return env->sregs[SR_PC];
target-microblaze/cpu.h:    *pc = env->sregs[SR_PC];
target-microblaze/cpu.h:    *flags = (env->iflags & IFLAGS_TB_MASK) |
target-microblaze/cpu.h:                 (env->sregs[SR_MSR] & (MSR_UM | MSR_VM | MSR_EE));
target-microblaze/cpu.c:    env->res_addr = RES_ADDR_NONE;
target-microblaze/cpu.c:    env->shr = ~0;
target-microblaze/cpu.c:    env->pvr.regs[0] = PVR0_PVR_FULL_MASK \
target-microblaze/cpu.c:    env->pvr.regs[2] = PVR2_D_OPB_MASK \
target-microblaze/cpu.c:    env->pvr.regs[10] = 0x0c000000; /* Default to spartan 3a dsp family.  */
target-microblaze/cpu.c:    env->pvr.regs[11] = PVR11_USE_MMU | (16 << 17);
target-microblaze/cpu.c:    env->sregs[SR_PC] = cpu->base_vectors;
target-microblaze/cpu.c:    env->sregs[SR_MSR] = MSR_EE | MSR_IE | MSR_VM | MSR_UM;
target-microblaze/cpu.c:    env->pvr.regs[10] = 0x0c000000; /* Spartan 3a dsp.  */
target-microblaze/cpu.c:    env->sregs[SR_MSR] = 0;
target-microblaze/cpu.c:    mmu_init(&env->mmu);
target-microblaze/cpu.c:    env->mmu.c_mmu = 3;
target-microblaze/cpu.c:    env->mmu.c_mmu_tlb_access = 3;
target-microblaze/cpu.c:    env->mmu.c_mmu_zones = 16;
target-microblaze/cpu.c:    set_float_rounding_mode(float_round_nearest_even, &env->fp_status);
target-microblaze/op_helper.c:    qemu_log("PC=%8.8x\n", env->sregs[SR_PC]);
target-microblaze/op_helper.c:             env->sregs[SR_MSR], env->sregs[SR_ESR], env->sregs[SR_EAR],
target-microblaze/op_helper.c:             env->debug, env->imm, env->iflags);
target-microblaze/op_helper.c:             env->btaken, env->btarget,
target-microblaze/op_helper.c:             (env->sregs[SR_MSR] & MSR_UM) ? "user" : "kernel",
target-microblaze/op_helper.c:             (env->sregs[SR_MSR] & MSR_UMS) ? "user" : "kernel",
target-microblaze/op_helper.c:             (env->sregs[SR_MSR] & MSR_EIP),
target-microblaze/op_helper.c:             (env->sregs[SR_MSR] & MSR_IE));
target-microblaze/op_helper.c:        qemu_log("r%2.2d=%8.8x ", i, env->regs[i]);
target-microblaze/op_helper.c:        env->sregs[SR_MSR] |= MSR_DZ;
target-microblaze/op_helper.c:        if ((env->sregs[SR_MSR] & MSR_EE)
target-microblaze/op_helper.c:            && !(env->pvr.regs[2] & PVR2_DIV_ZERO_EXC_MASK)) {
target-microblaze/op_helper.c:            env->sregs[SR_ESR] = ESR_EC_DIVZERO;
target-microblaze/op_helper.c:    env->sregs[SR_MSR] &= ~MSR_DZ;
target-microblaze/op_helper.c:    env->sregs[SR_ESR] = ESR_EC_FPU;
target-microblaze/op_helper.c:        env->sregs[SR_FSR] |= FSR_IO;
target-microblaze/op_helper.c:        env->sregs[SR_FSR] |= FSR_DZ;
target-microblaze/op_helper.c:        env->sregs[SR_FSR] |= FSR_OF;
target-microblaze/op_helper.c:        env->sregs[SR_FSR] |= FSR_UF;
target-microblaze/op_helper.c:        && (env->pvr.regs[2] & PVR2_FPU_EXC_MASK)
target-microblaze/op_helper.c:        && (env->sregs[SR_MSR] & MSR_EE)) {
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    fd.f = float32_add(fa.f, fb.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    fd.f = float32_sub(fb.f, fa.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    fd.f = float32_mul(fa.f, fb.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    fd.f = float32_div(fb.f, fa.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    r = float32_lt(fb.f, fa.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    r = float32_eq_quiet(fa.f, fb.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    r = float32_le(fa.f, fb.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    r = float32_lt(fa.f, fb.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    r = !float32_eq_quiet(fa.f, fb.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    r = !float32_lt(fa.f, fb.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    fd.f = int32_to_float32(fa.l, &env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    r = float32_to_int32(fa.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    fd.l = float32_sqrt(fa.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:            env->sregs[SR_EAR] = addr;
target-microblaze/op_helper.c:            env->sregs[SR_ESR] = ESR_EC_UNALIGNED_DATA | (wr << 10) \
target-microblaze/op_helper.c:                env->sregs[SR_ESR] |= 1 << 11;
target-microblaze/op_helper.c:            if (!(env->sregs[SR_MSR] & MSR_EE)) {
target-microblaze/op_helper.c:    if (addr < env->slr || addr > env->shr) {
target-microblaze/op_helper.c:                     addr, env->slr, env->shr);
target-microblaze/op_helper.c:            env->sregs[SR_EAR] = addr;
target-microblaze/op_helper.c:            env->sregs[SR_ESR] = ESR_EC_STACKPROT;
target-microblaze/op_helper.c:    if (!(env->sregs[SR_MSR] & MSR_EE)) {
target-microblaze/op_helper.c:    env->sregs[SR_EAR] = addr;
target-microblaze/op_helper.c:        if ((env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {
target-microblaze/op_helper.c:            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;
target-microblaze/op_helper.c:        if ((env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {
target-microblaze/op_helper.c:            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;
target-m68k/gdbstub.c:        return gdb_get_reg32(mem_buf, env->dregs[n]);
target-m68k/gdbstub.c:        return gdb_get_reg32(mem_buf, env->aregs[n - 8]);
target-m68k/gdbstub.c:            return gdb_get_reg32(mem_buf, env->sr);
target-m68k/gdbstub.c:            return gdb_get_reg32(mem_buf, env->pc);
target-m68k/gdbstub.c:        env->dregs[n] = tmp;
target-m68k/gdbstub.c:        env->aregs[n - 8] = tmp;
target-m68k/gdbstub.c:            env->sr = tmp;
target-m68k/gdbstub.c:            env->pc = tmp;
target-m68k/translate.c:    if (s->env->macsr & MACSR_FI) {
target-m68k/translate.c:    } else if (s->env->macsr & MACSR_SU) {
target-m68k/translate.c:    if ((s->env->macsr & MACSR_OMC) != 0 && !dual) {
target-m68k/translate.c:    if (s->env->macsr & MACSR_FI) {
target-m68k/translate.c:        if (s->env->macsr & MACSR_SU)
target-m68k/translate.c:    if ((s->env->macsr & MACSR_OMC) != 0 && dual) {
target-m68k/translate.c:    if (s->env->macsr & MACSR_FI)
target-m68k/translate.c:    else if (s->env->macsr & MACSR_SU)
target-m68k/translate.c:        if ((s->env->macsr & MACSR_OMC) != 0) {
target-m68k/translate.c:        if (s->env->macsr & MACSR_FI)
target-m68k/translate.c:        else if (s->env->macsr & MACSR_SU)
target-m68k/translate.c:    if (s->env->macsr & MACSR_FI) {
target-m68k/translate.c:    } else if ((s->env->macsr & MACSR_OMC) == 0) {
target-m68k/translate.c:    } else if (s->env->macsr & MACSR_SU) {
target-m68k/translate.c:    if (s->env->macsr & MACSR_FI)
target-m68k/translate.c:    if (s->env->macsr & MACSR_FI) {
target-m68k/translate.c:    } else if (s->env->macsr & MACSR_SU) {
target-m68k/translate.c:    if (s->env->macsr & MACSR_FI)
target-m68k/translate.c:    else if (s->env->macsr & MACSR_SU)
target-m68k/translate.c:    dc->fpcr = env->fpcr;
target-m68k/translate.c:    dc->user = (env->sr & SR_S) == 0;
target-m68k/translate.c:        u.d = env->fregs[i];
target-m68k/translate.c:                     i, env->dregs[i], i, env->aregs[i],
target-m68k/translate.c:    cpu_fprintf (f, "PC = %08x   ", env->pc);
target-m68k/translate.c:    sr = env->sr;
target-m68k/translate.c:    cpu_fprintf (f, "FPRESULT = %12g\n", *(double *)&env->fp_result);
target-m68k/translate.c:    env->pc = tcg_ctx.gen_opc_pc[pc_pos];
target-m68k/helper.c:        stfq_p(mem_buf, env->fregs[n]);
target-m68k/helper.c:        env->fregs[n] = ldfq_p(mem_buf);
target-m68k/helper.c:    src = env->cc_src;
target-m68k/helper.c:    dest = env->cc_dest;
target-m68k/helper.c:    env->cc_op = CC_OP_FLAGS;
target-m68k/helper.c:    env->cc_dest = flags;
target-m68k/helper.c:        env->cacr = val;
target-m68k/helper.c:        env->vbr = val;
target-m68k/helper.c:    if ((env->macsr ^ val) & (MACSR_FI | MACSR_SU)) {
target-m68k/helper.c:            regval = env->macc[i];
target-m68k/helper.c:            if (env->macsr & MACSR_FI) {
target-m68k/helper.c:            if (env->macsr & MACSR_FI) {
target-m68k/helper.c:            } else if (env->macsr & MACSR_SU) {
target-m68k/helper.c:            env->macc[i] = regval;
target-m68k/helper.c:    env->macsr = val;
target-m68k/helper.c:    env->sp[env->current_sp] = env->aregs[7];
target-m68k/helper.c:    new_sp = (env->sr & SR_S && env->cacr & M68K_CACR_EUSP)
target-m68k/helper.c:    env->aregs[7] = env->sp[new_sp];
target-m68k/helper.c:    env->current_sp = new_sp;
target-m68k/helper.c:    env->pending_level = level;
target-m68k/helper.c:    env->pending_vector = vector;
target-m68k/helper.c:    old_flags = env->cc_dest;
target-m68k/helper.c:    if (env->cc_x) {
target-m68k/helper.c:        env->cc_x = (op1 <= op2);
target-m68k/helper.c:        env->cc_op = CC_OP_SUBX;
target-m68k/helper.c:        env->cc_x = (op1 < op2);
target-m68k/helper.c:        env->cc_op = CC_OP_SUB;
target-m68k/helper.c:    env->cc_dest = res;
target-m68k/helper.c:    env->cc_src = op2;
target-m68k/helper.c:    cpu_m68k_flush_flags(env, env->cc_op);
target-m68k/helper.c:    env->cc_dest &= (old_flags | ~CCF_Z);
target-m68k/helper.c:    old_flags = env->cc_dest;
target-m68k/helper.c:    if (env->cc_x) {
target-m68k/helper.c:        env->cc_x = (res <= op2);
target-m68k/helper.c:        env->cc_op = CC_OP_ADDX;
target-m68k/helper.c:        env->cc_x = (res < op2);
target-m68k/helper.c:        env->cc_op = CC_OP_ADD;
target-m68k/helper.c:    env->cc_dest = res;
target-m68k/helper.c:    env->cc_src = op2;
target-m68k/helper.c:    cpu_m68k_flush_flags(env, env->cc_op);
target-m68k/helper.c:    env->cc_dest &= (old_flags | ~CCF_Z);
target-m68k/helper.c:    env->sr = val & 0xffff;
target-m68k/helper.c:        cf = env->cc_src & CCF_C;
target-m68k/helper.c:    env->cc_src = cf;
target-m68k/helper.c:    env->cc_x = (cf != 0);
target-m68k/helper.c:    env->cc_dest = result;
target-m68k/helper.c:        cf = env->cc_src & CCF_C;
target-m68k/helper.c:    env->cc_src = cf;
target-m68k/helper.c:    env->cc_x = (cf != 0);
target-m68k/helper.c:    env->cc_dest = result;
target-m68k/helper.c:        cf = (env->cc_src & CCF_C) != 0;
target-m68k/helper.c:    env->cc_src = cf;
target-m68k/helper.c:    env->cc_x = cf;
target-m68k/helper.c:    env->cc_dest = result;
target-m68k/helper.c:    return float64_to_int32(val, &env->fp_status);
target-m68k/helper.c:    return float64_to_float32(val, &env->fp_status);
target-m68k/helper.c:    return int32_to_float64(val, &env->fp_status);
target-m68k/helper.c:    return float32_to_float64(val, &env->fp_status);
target-m68k/helper.c:    return float64_round_to_int(val, &env->fp_status);
target-m68k/helper.c:    return float64_trunc_to_int(val, &env->fp_status);
target-m68k/helper.c:    return float64_sqrt(val, &env->fp_status);
target-m68k/helper.c:    return float64_add(a, b, &env->fp_status);
target-m68k/helper.c:    return float64_sub(a, b, &env->fp_status);
target-m68k/helper.c:    return float64_mul(a, b, &env->fp_status);
target-m68k/helper.c:    return float64_div(a, b, &env->fp_status);
target-m68k/helper.c:    res = float64_sub(a, b, &env->fp_status);
target-m68k/helper.c:            if (float64_lt_quiet(a, res, &env->fp_status))
target-m68k/helper.c:    return float64_compare_quiet(val, float64_zero, &env->fp_status);
target-m68k/helper.c:    env->macc[dest] = env->macc[src];
target-m68k/helper.c:    if (env->macsr & (MACSR_PAV0 << src))
target-m68k/helper.c:        env->macsr |= mask;
target-m68k/helper.c:        env->macsr &= ~mask;
target-m68k/helper.c:        env->macsr |= MACSR_V;
target-m68k/helper.c:        if (env->macsr & MACSR_OMC) {
target-m68k/helper.c:        env->macsr |= MACSR_V;
target-m68k/helper.c:        if (env->macsr & MACSR_OMC) {
target-m68k/helper.c:    if (env->macsr & MACSR_RT) {
target-m68k/helper.c:    tmp = env->macc[acc];
target-m68k/helper.c:        env->macsr |= MACSR_V;
target-m68k/helper.c:    if (env->macsr & MACSR_V) {
target-m68k/helper.c:        env->macsr |= MACSR_PAV0 << acc;
target-m68k/helper.c:        if (env->macsr & MACSR_OMC) {
target-m68k/helper.c:    env->macc[acc] = result;
target-m68k/helper.c:    val = env->macc[acc];
target-m68k/helper.c:        env->macsr |= MACSR_V;
target-m68k/helper.c:    if (env->macsr & MACSR_V) {
target-m68k/helper.c:        env->macsr |= MACSR_PAV0 << acc;
target-m68k/helper.c:        if (env->macsr & MACSR_OMC) {
target-m68k/helper.c:    env->macc[acc] = val;
target-m68k/helper.c:    sum = env->macc[acc];
target-m68k/helper.c:        env->macsr |= MACSR_V;
target-m68k/helper.c:    if (env->macsr & MACSR_V) {
target-m68k/helper.c:        env->macsr |= MACSR_PAV0 << acc;
target-m68k/helper.c:        if (env->macsr & MACSR_OMC) {
target-m68k/helper.c:    env->macc[acc] = result;
target-m68k/helper.c:    val = env->macc[acc];
target-m68k/helper.c:        env->macsr |= MACSR_Z;
target-m68k/helper.c:        env->macsr |= MACSR_N;
target-m68k/helper.c:    if (env->macsr & (MACSR_PAV0 << acc)) {
target-m68k/helper.c:        env->macsr |= MACSR_V;
target-m68k/helper.c:    if (env->macsr & MACSR_FI) {
target-m68k/helper.c:            env->macsr |= MACSR_EV;
target-m68k/helper.c:    } else if (env->macsr & MACSR_SU) {
target-m68k/helper.c:            env->macsr |= MACSR_EV;
target-m68k/helper.c:            env->macsr |= MACSR_EV;
target-m68k/helper.c:    if (env->macsr & MACSR_SU) {
target-m68k/helper.c:    } else if (env->macsr & MACSR_RT) {
target-m68k/helper.c:    if (env->macsr & MACSR_OMC) {
target-m68k/helper.c:        if (env->macsr & MACSR_SU) {
target-m68k/helper.c:        if (env->macsr & MACSR_SU) {
target-m68k/helper.c:    val = env->macc[acc] & 0x00ff;
target-m68k/helper.c:    val = (env->macc[acc] >> 32) & 0xff00;
target-m68k/helper.c:    val |= (env->macc[acc + 1] << 16) & 0x00ff0000;
target-m68k/helper.c:    val |= (env->macc[acc + 1] >> 16) & 0xff000000;
target-m68k/helper.c:    val = (env->macc[acc] >> 32) & 0xffff;
target-m68k/helper.c:    val |= (env->macc[acc + 1] >> 16) & 0xffff0000;
target-m68k/helper.c:    res = env->macc[acc] & 0xffffffff00ull;
target-m68k/helper.c:    env->macc[acc] = res;
target-m68k/helper.c:    res = env->macc[acc + 1] & 0xffffffff00ull;
target-m68k/helper.c:    env->macc[acc + 1] = res;
target-m68k/helper.c:    res = (uint32_t)env->macc[acc];
target-m68k/helper.c:    env->macc[acc] = res;
target-m68k/helper.c:    res = (uint32_t)env->macc[acc + 1];
target-m68k/helper.c:    env->macc[acc + 1] = res;
target-m68k/helper.c:    res = (uint32_t)env->macc[acc];
target-m68k/helper.c:    env->macc[acc] = res;
target-m68k/helper.c:    res = (uint32_t)env->macc[acc + 1];
target-m68k/helper.c:    env->macc[acc + 1] = res;
target-m68k/m68k-semi.c:    target_ulong args = env->dregs[1];
target-m68k/m68k-semi.c:    target_ulong args = env->dregs[1];
target-m68k/m68k-semi.c:    args = env->dregs[1];
target-m68k/m68k-semi.c:        gdb_exit(env, env->dregs[0]);
target-m68k/m68k-semi.c:        exit(env->dregs[0]);
target-m68k/m68k-semi.c:        env->dregs[1] = ts->heap_limit;
target-m68k/m68k-semi.c:        env->aregs[7] = ts->stack_base;
target-m68k/m68k-semi.c:        env->dregs[1] = ram_size;
target-m68k/m68k-semi.c:        env->aregs[7] = ram_size;
target-m68k/cpu.h:    CC_OP_DYNAMIC, /* Use env->cc_op  */
target-m68k/cpu.h:    return (env->features & (1u << feature)) != 0;
target-m68k/cpu.h:    return (env->sr & SR_S) == 0 ? 1 : 0;
target-m68k/cpu.h:    *pc = env->pc;
target-m68k/cpu.h:    *flags = (env->fpcr & M68K_FPCR_PREC)       /* Bit  6 */
target-m68k/cpu.h:            | (env->sr & SR_S)                  /* Bit  13 */
target-m68k/cpu.h:            | ((env->macsr >> 4) & 0xf);        /* Bits 0-3 */
target-m68k/cpu.c:    env->features |= (1u << feature);
target-m68k/cpu.c:    env->sr = 0x2700;
target-m68k/cpu.c:    env->cc_op = CC_OP_FLAGS;
target-m68k/cpu.c:    env->pc = 0;
target-m68k/op_helper.c:    sp = env->aregs[7];
target-m68k/op_helper.c:    env->pc = cpu_ldl_kernel(env, sp + 4);
target-m68k/op_helper.c:    env->sr = fmt & 0xffff;
target-m68k/op_helper.c:    env->aregs[7] = sp + 8;
target-m68k/op_helper.c:    retaddr = env->pc;
target-m68k/op_helper.c:                    && (env->sr & SR_S) != 0
target-m68k/op_helper.c:                    && (env->pc & 3) == 0
target-m68k/op_helper.c:                    && cpu_lduw_code(env, env->pc - 4) == 0x4e71
target-m68k/op_helper.c:                    && cpu_ldl_code(env, env->pc) == 0x4e7bf000) {
target-m68k/op_helper.c:                env->pc += 4;
target-m68k/op_helper.c:                do_m68k_semihosting(env, env->dregs[0]);
target-m68k/op_helper.c:    sp = env->aregs[7];
target-m68k/op_helper.c:    fmt |= env->sr;
target-m68k/op_helper.c:    env->sr |= SR_S;
target-m68k/op_helper.c:        env->sr = (env->sr & ~SR_I) | (env->pending_level << SR_I_SHIFT);
target-m68k/op_helper.c:        env->sr &= ~SR_M;
target-m68k/op_helper.c:    env->aregs[7] = sp;
target-m68k/op_helper.c:    env->pc = cpu_ldl_kernel(env, env->vbr + vector);
target-m68k/op_helper.c:    num = env->div1;
target-m68k/op_helper.c:    den = env->div2;
target-m68k/op_helper.c:    env->div1 = quot;
target-m68k/op_helper.c:    env->div2 = rem;
target-m68k/op_helper.c:    env->cc_dest = flags;
target-m68k/op_helper.c:    num = env->div1;
target-m68k/op_helper.c:    den = env->div2;
target-m68k/op_helper.c:    env->div1 = quot;
target-m68k/op_helper.c:    env->div2 = rem;
target-m68k/op_helper.c:    env->cc_dest = flags;
cpu-exec.c:        cpu_m68k_flush_flags(env, env->cc_op);
cpu-exec.c:        env->cc_op = CC_OP_FLAGS;
cpu-exec.c:        env->sr = (env->sr & 0xffe0) | env->cc_dest | (env->cc_x << 4);
cpu-exec.c:    CC_SRC = env->eflags & (CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);
cpu-exec.c:    env->df = 1 - (2 * ((env->eflags >> 10) & 1));
cpu-exec.c:    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);
cpu-exec.c:    env->cc_op = CC_OP_FLAGS;
cpu-exec.c:    env->cc_dest = env->sr & 0xf;
cpu-exec.c:    env->cc_x = (env->sr >> 4) & 1;
cpu-exec.c:    env->reserve_addr = -1;
cpu-exec.c:                    } else if (env->hflags2 & HF2_GIF_MASK) {
cpu-exec.c:                            !(env->hflags & HF_SMM_MASK)) {
cpu-exec.c:                                   !(env->hflags2 & HF2_NMI_MASK)) {
cpu-exec.c:                            env->hflags2 |= HF2_NMI_MASK;
cpu-exec.c:                                   (((env->hflags2 & HF2_VINTR_MASK) && 
cpu-exec.c:                                     (env->hflags2 & HF2_HIF_MASK)) ||
cpu-exec.c:                                    (!(env->hflags2 & HF2_VINTR_MASK) && 
cpu-exec.c:                                     (env->eflags & IF_MASK && 
cpu-exec.c:                                      !(env->hflags & HF_INHIBIT_IRQ_MASK))))) {
cpu-exec.c:                                   (env->eflags & IF_MASK) && 
cpu-exec.c:                                   !(env->hflags & HF_INHIBIT_IRQ_MASK)) {
cpu-exec.c:                                             env->vm_vmcb
cpu-exec.c:                        if (env->pending_interrupts == 0) {
cpu-exec.c:                        && (env->ie & IE_IE)) {
cpu-exec.c:                        && (env->sregs[SR_MSR] & MSR_IE)
cpu-exec.c:                        && !(env->sregs[SR_MSR] & (MSR_EIP | MSR_BIP))
cpu-exec.c:                        && !(env->iflags & (D_FLAG | IMM_FLAG))) {
cpu-exec.c:                        env->error_code = 0;
cpu-exec.c:                            && (env->sr & SR_IEE)) {
cpu-exec.c:                            && (env->sr & SR_TEE)) {
cpu-exec.c:                            env->interrupt_index > 0) {
cpu-exec.c:                            int pil = env->interrupt_index & 0xf;
cpu-exec.c:                            int type = env->interrupt_index & 0xf0;
cpu-exec.c:                                cpu->exception_index = env->interrupt_index;
cpu-exec.c:                        && !(env->daif & PSTATE_F)) {
cpu-exec.c:                        && ((IS_M(env) && env->regs[15] < 0xfffffff0)
cpu-exec.c:                            || !(env->daif & PSTATE_I))) {
cpu-exec.c:                        && !(env->uncached_asr & ASR_I)) {
cpu-exec.c:                        switch (env->pal_mode ? 7 : env->ps & PS_INT_MASK) {
cpu-exec.c:                            env->error_code = 0;
cpu-exec.c:                        && (env->pregs[PR_CCS] & I_FLAG)
cpu-exec.c:                        && !env->locked_irq) {
cpu-exec.c:                        if (env->pregs[PR_VR] < 32) {
cpu-exec.c:                        if ((env->pregs[PR_CCS] & m_flag_archval)) {
cpu-exec.c:                        && ((env->sr & SR_I) >> SR_I_SHIFT)
cpu-exec.c:                            < env->pending_level) {
cpu-exec.c:                        cpu->exception_index = env->pending_vector;
cpu-exec.c:                        (env->psw.mask & PSW_MASK_EXT)) {
cpu-exec.c:                   infinite loop and becomes env->current_tb. Avoid
cpu-exec.c:    env->eflags = env->eflags | cpu_cc_compute_all(env, CC_OP)
cpu-exec.c:        | (env->df & DF_MASK);
cpu-exec.c:    cpu_m68k_flush_flags(env, env->cc_op);
cpu-exec.c:    env->cc_op = CC_OP_FLAGS;
cpu-exec.c:    env->sr = (env->sr & 0xffe0)
cpu-exec.c:              | env->cc_dest | (env->cc_x << 4);
bsd-user/main.c:                abi_ulong params = (abi_ulong) env->regs[R_ESP] +
bsd-user/main.c:                int32_t syscall_nr = env->regs[R_EAX];
bsd-user/main.c:                env->regs[R_EAX] = do_freebsd_syscall(env,
bsd-user/main.c:                env->regs[R_EAX] = do_openbsd_syscall(env,
bsd-user/main.c:                                                      env->regs[R_EAX],
bsd-user/main.c:                                                      env->regs[R_EBX],
bsd-user/main.c:                                                      env->regs[R_ECX],
bsd-user/main.c:                                                      env->regs[R_EDX],
bsd-user/main.c:                                                      env->regs[R_ESI],
bsd-user/main.c:                                                      env->regs[R_EDI],
bsd-user/main.c:                                                      env->regs[R_EBP]);
bsd-user/main.c:            if (((abi_ulong)env->regs[R_EAX]) >= (abi_ulong)(-515)) {
bsd-user/main.c:                env->regs[R_EAX] = -env->regs[R_EAX];
bsd-user/main.c:                env->eflags |= CC_C;
bsd-user/main.c:                env->eflags &= ~CC_C;
bsd-user/main.c:                env->regs[R_EAX] = do_freebsd_syscall(env,
bsd-user/main.c:                                                      env->regs[R_EAX],
bsd-user/main.c:                                                      env->regs[R_EDI],
bsd-user/main.c:                                                      env->regs[R_ESI],
bsd-user/main.c:                                                      env->regs[R_EDX],
bsd-user/main.c:                                                      env->regs[R_ECX],
bsd-user/main.c:                                                      env->regs[8],
bsd-user/main.c:                                                      env->regs[9], 0, 0);
bsd-user/main.c:                env->regs[R_EAX] = do_openbsd_syscall(env,
bsd-user/main.c:                                                      env->regs[R_EAX],
bsd-user/main.c:                                                      env->regs[R_EDI],
bsd-user/main.c:                                                      env->regs[R_ESI],
bsd-user/main.c:                                                      env->regs[R_EDX],
bsd-user/main.c:                                                      env->regs[10],
bsd-user/main.c:                                                      env->regs[8],
bsd-user/main.c:                                                      env->regs[9]);
bsd-user/main.c:            env->eip = env->exception_next_eip;
bsd-user/main.c:            if (((abi_ulong)env->regs[R_EAX]) >= (abi_ulong)(-515)) {
bsd-user/main.c:                env->regs[R_EAX] = -env->regs[R_EAX];
bsd-user/main.c:                env->eflags |= CC_C;
bsd-user/main.c:                env->eflags &= ~CC_C;
bsd-user/main.c:            if (env->eflags & VM_MASK) {
bsd-user/main.c:            if (!(env->error_code & 1))
bsd-user/main.c:            info._sifields._sigfault._addr = env->cr[2];
bsd-user/main.c:            if (env->eflags & VM_MASK) {
bsd-user/main.c:                info._sifields._sigfault._addr = env->eip;
bsd-user/main.c:            if (env->eflags & VM_MASK) {
bsd-user/main.c:                    info._sifields._sigfault._addr = env->eip;
bsd-user/main.c:            if (env->eflags & VM_MASK) {
bsd-user/main.c:            info._sifields._sigfault._addr = env->eip;
bsd-user/main.c:            pc = env->segs[R_CS].base + env->eip;
bsd-user/main.c:    index = (index + cwp * 16) % (16 * env->nwindows);
bsd-user/main.c:    if (index < 8 && env->cwp == env->nwindows - 1)
bsd-user/main.c:        index += 16 * env->nwindows;
bsd-user/main.c:    sp_ptr = env->regbase[get_reg_index(env, cwp1, 6)];
bsd-user/main.c:        put_user_ual(env->regbase[get_reg_index(env, cwp1, 8 + i)], sp_ptr);
bsd-user/main.c:    new_wim = ((env->wim >> 1) | (env->wim << (env->nwindows - 1))) &
bsd-user/main.c:        ((1LL << env->nwindows) - 1);
bsd-user/main.c:    save_window_offset(env, cpu_cwp_dec(env, env->cwp - 2));
bsd-user/main.c:    env->wim = new_wim;
bsd-user/main.c:    save_window_offset(env, cpu_cwp_dec(env, env->cwp - 2));
bsd-user/main.c:    env->cansave++;
bsd-user/main.c:    env->canrestore--;
bsd-user/main.c:    new_wim = ((env->wim << 1) | (env->wim >> (env->nwindows - 1))) &
bsd-user/main.c:        ((1LL << env->nwindows) - 1);
bsd-user/main.c:    cwp1 = cpu_cwp_inc(env, env->cwp + 1);
bsd-user/main.c:    sp_ptr = env->regbase[get_reg_index(env, cwp1, 6)];
bsd-user/main.c:        get_user_ual(env->regbase[get_reg_index(env, cwp1, 8 + i)], sp_ptr);
bsd-user/main.c:    env->canrestore++;
bsd-user/main.c:    if (env->cleanwin < env->nwindows - 1)
bsd-user/main.c:        env->cleanwin++;
bsd-user/main.c:    env->cansave--;
bsd-user/main.c:    env->wim = new_wim;
bsd-user/main.c:        cwp1 = cpu_cwp_inc(env, env->cwp + offset);
bsd-user/main.c:        if (env->wim & (1 << cwp1))
bsd-user/main.c:        if (env->canrestore == 0)
bsd-user/main.c:        env->cansave++;
bsd-user/main.c:        env->canrestore--;
bsd-user/main.c:    cwp1 = cpu_cwp_inc(env, env->cwp + 1);
bsd-user/main.c:    env->wim = 1 << cwp1;
bsd-user/main.c:            syscall_nr = env->gregs[1];
bsd-user/main.c:                                         env->regwptr[0], env->regwptr[1],
bsd-user/main.c:                                         env->regwptr[2], env->regwptr[3],
bsd-user/main.c:                                         env->regwptr[4], env->regwptr[5], 0, 0);
bsd-user/main.c:                                        env->regwptr[0], env->regwptr[1],
bsd-user/main.c:                                        env->regwptr[2], env->regwptr[3],
bsd-user/main.c:                                        env->regwptr[4], env->regwptr[5]);
bsd-user/main.c:                                         env->regwptr[0], env->regwptr[1],
bsd-user/main.c:                                         env->regwptr[2], env->regwptr[3],
bsd-user/main.c:                                         env->regwptr[4], env->regwptr[5]);
bsd-user/main.c:                env->xcc |= PSR_CARRY;
bsd-user/main.c:                env->psr |= PSR_CARRY;
bsd-user/main.c:                env->xcc &= ~PSR_CARRY;
bsd-user/main.c:                env->psr &= ~PSR_CARRY;
bsd-user/main.c:            env->regwptr[0] = ret;
bsd-user/main.c:                env->gregs[1] & TARGET_OPENBSD_SYSCALL_G2RFLAG) {
bsd-user/main.c:                env->pc = env->gregs[2];
bsd-user/main.c:                env->npc = env->pc + 4;
bsd-user/main.c:                       env->gregs[1] & TARGET_OPENBSD_SYSCALL_G7RFLAG) {
bsd-user/main.c:                env->pc = env->gregs[7];
bsd-user/main.c:                env->npc = env->pc + 4;
bsd-user/main.c:                env->pc = env->npc;
bsd-user/main.c:                env->npc = env->npc + 4;
bsd-user/main.c:            env->pc = env->npc;
bsd-user/main.c:            env->npc = env->npc + 4;
bsd-user/main.c:            env->pc = env->npc;
bsd-user/main.c:            env->npc = env->npc + 4;
bsd-user/main.c:                /* XXX: check env->error_code */
bsd-user/main.c:                info._sifields._sigfault._addr = env->mmuregs[4];
bsd-user/main.c:                /* XXX: check env->error_code */
bsd-user/main.c:                    info._sifields._sigfault._addr = env->dmmuregs[4];
bsd-user/main.c:                    info._sifields._sigfault._addr = env->tsptr->tpc;
bsd-user/main.c:    env->cr[0] = CR0_PG_MASK | CR0_WP_MASK | CR0_PE_MASK;
bsd-user/main.c:    env->hflags |= HF_PE_MASK | HF_CPL_MASK;
bsd-user/main.c:    if (env->features[FEAT_1_EDX] & CPUID_SSE) {
bsd-user/main.c:        env->cr[4] |= CR4_OSFXSR_MASK;
bsd-user/main.c:        env->hflags |= HF_OSFXSR_MASK;
bsd-user/main.c:    if (!(env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM)) {
bsd-user/main.c:    env->cr[4] |= CR4_PAE_MASK;
bsd-user/main.c:    env->efer |= MSR_EFER_LMA | MSR_EFER_LME;
bsd-user/main.c:    env->hflags |= HF_LMA_MASK;
bsd-user/main.c:    env->eflags |= IF_MASK;
bsd-user/main.c:    env->regs[R_EAX] = regs->rax;
bsd-user/main.c:    env->regs[R_EBX] = regs->rbx;
bsd-user/main.c:    env->regs[R_ECX] = regs->rcx;
bsd-user/main.c:    env->regs[R_EDX] = regs->rdx;
bsd-user/main.c:    env->regs[R_ESI] = regs->rsi;
bsd-user/main.c:    env->regs[R_EDI] = regs->rdi;
bsd-user/main.c:    env->regs[R_EBP] = regs->rbp;
bsd-user/main.c:    env->regs[R_ESP] = regs->rsp;
bsd-user/main.c:    env->eip = regs->rip;
bsd-user/main.c:    env->regs[R_EAX] = regs->eax;
bsd-user/main.c:    env->regs[R_EBX] = regs->ebx;
bsd-user/main.c:    env->regs[R_ECX] = regs->ecx;
bsd-user/main.c:    env->regs[R_EDX] = regs->edx;
bsd-user/main.c:    env->regs[R_ESI] = regs->esi;
bsd-user/main.c:    env->regs[R_EDI] = regs->edi;
bsd-user/main.c:    env->regs[R_EBP] = regs->ebp;
bsd-user/main.c:    env->regs[R_ESP] = regs->esp;
bsd-user/main.c:    env->eip = regs->eip;
bsd-user/main.c:    env->idt.limit = 511;
bsd-user/main.c:    env->idt.limit = 255;
bsd-user/main.c:    env->idt.base = target_mmap(0, sizeof(uint64_t) * (env->idt.limit + 1),
bsd-user/main.c:    idt_table = g2h(env->idt.base);
bsd-user/main.c:        env->gdt.base = target_mmap(0, sizeof(uint64_t) * TARGET_GDT_ENTRIES,
bsd-user/main.c:        env->gdt.limit = sizeof(uint64_t) * TARGET_GDT_ENTRIES - 1;
bsd-user/main.c:        gdt_table = g2h(env->gdt.base);
bsd-user/main.c:    env->segs[R_FS].selector = 0;
bsd-user/main.c:        env->pc = regs->pc;
bsd-user/main.c:        env->npc = regs->npc;
bsd-user/main.c:        env->y = regs->y;
bsd-user/main.c:            env->gregs[i] = regs->u_regs[i];
bsd-user/main.c:            env->regwptr[i] = regs->u_regs[i + 8];
bsd-user/syscall.c:        env->segs[idx].base = val;
bsd-user/syscall.c:        val = env->segs[idx].base;
target-sparc/gdbstub.c:        return gdb_get_rega(mem_buf, env->gregs[n]);
target-sparc/gdbstub.c:        return gdb_get_rega(mem_buf, env->regwptr[n - 8]);
target-sparc/gdbstub.c:            return gdb_get_reg32(mem_buf, env->fpr[(n - 32) / 2].l.lower);
target-sparc/gdbstub.c:            return gdb_get_reg32(mem_buf, env->fpr[(n - 32) / 2].l.upper);
target-sparc/gdbstub.c:        return gdb_get_rega(mem_buf, env->y);
target-sparc/gdbstub.c:        return gdb_get_rega(mem_buf, env->wim);
target-sparc/gdbstub.c:        return gdb_get_rega(mem_buf, env->tbr);
target-sparc/gdbstub.c:        return gdb_get_rega(mem_buf, env->pc);
target-sparc/gdbstub.c:        return gdb_get_rega(mem_buf, env->npc);
target-sparc/gdbstub.c:        return gdb_get_rega(mem_buf, env->fsr);
target-sparc/gdbstub.c:            return gdb_get_reg32(mem_buf, env->fpr[(n - 32) / 2].l.lower);
target-sparc/gdbstub.c:            return gdb_get_reg32(mem_buf, env->fpr[(n - 32) / 2].l.upper);
target-sparc/gdbstub.c:        return gdb_get_reg64(mem_buf, env->fpr[(n - 32) / 2].ll);
target-sparc/gdbstub.c:        return gdb_get_regl(mem_buf, env->pc);
target-sparc/gdbstub.c:        return gdb_get_regl(mem_buf, env->npc);
target-sparc/gdbstub.c:                                     ((env->asi & 0xff) << 24) |
target-sparc/gdbstub.c:                                     ((env->pstate & 0xfff) << 8) |
target-sparc/gdbstub.c:        return gdb_get_regl(mem_buf, env->fsr);
target-sparc/gdbstub.c:        return gdb_get_regl(mem_buf, env->fprs);
target-sparc/gdbstub.c:        return gdb_get_regl(mem_buf, env->y);
target-sparc/gdbstub.c:        env->gregs[n] = tmp;
target-sparc/gdbstub.c:        env->regwptr[n - 8] = tmp;
target-sparc/gdbstub.c:            env->fpr[(n - 32) / 2].l.lower = tmp;
target-sparc/gdbstub.c:            env->fpr[(n - 32) / 2].l.upper = tmp;
target-sparc/gdbstub.c:            env->y = tmp;
target-sparc/gdbstub.c:            env->wim = tmp;
target-sparc/gdbstub.c:            env->tbr = tmp;
target-sparc/gdbstub.c:            env->pc = tmp;
target-sparc/gdbstub.c:            env->npc = tmp;
target-sparc/gdbstub.c:            env->fsr = tmp;
target-sparc/gdbstub.c:            env->fpr[(n - 32) / 2].l.lower = tmp;
target-sparc/gdbstub.c:            env->fpr[(n - 32) / 2].l.upper = tmp;
target-sparc/gdbstub.c:        env->fpr[(n - 32) / 2].ll = tmp;
target-sparc/gdbstub.c:            env->pc = tmp;
target-sparc/gdbstub.c:            env->npc = tmp;
target-sparc/gdbstub.c:            env->asi = (tmp >> 24) & 0xff;
target-sparc/gdbstub.c:            env->pstate = (tmp >> 8) & 0xfff;
target-sparc/gdbstub.c:            env->fsr = tmp;
target-sparc/gdbstub.c:            env->fprs = tmp;
target-sparc/gdbstub.c:            env->y = tmp;
target-sparc/fop_helper.c:#define QT0 (env->qt0)
target-sparc/fop_helper.c:#define QT1 (env->qt1)
target-sparc/fop_helper.c:    status = get_float_exception_flags(&env->fp_status);
target-sparc/fop_helper.c:            env->fsr |= FSR_NVC;
target-sparc/fop_helper.c:            env->fsr |= FSR_OFC;
target-sparc/fop_helper.c:            env->fsr |= FSR_UFC;
target-sparc/fop_helper.c:            env->fsr |= FSR_DZC;
target-sparc/fop_helper.c:            env->fsr |= FSR_NXC;
target-sparc/fop_helper.c:        if ((env->fsr & FSR_CEXC_MASK) & ((env->fsr & FSR_TEM_MASK) >> 23)) {
target-sparc/fop_helper.c:            env->fsr |= FSR_FTT_IEEE_EXCP;
target-sparc/fop_helper.c:            env->fsr |= (env->fsr & FSR_CEXC_MASK) << 5;
target-sparc/fop_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sparc/fop_helper.c:        ret = float32_ ## name (src1, src2, &env->fp_status);   \
target-sparc/fop_helper.c:        ret = float64_ ## name (src1, src2, &env->fp_status);   \
target-sparc/fop_helper.c:        QT0 = float128_ ## name (QT0, QT1, &env->fp_status);    \
target-sparc/fop_helper.c:    ret = float64_mul(float32_to_float64(src1, &env->fp_status),
target-sparc/fop_helper.c:                      float32_to_float64(src2, &env->fp_status),
target-sparc/fop_helper.c:                      &env->fp_status);
target-sparc/fop_helper.c:    QT0 = float128_mul(float64_to_float128(src1, &env->fp_status),
target-sparc/fop_helper.c:                       float64_to_float128(src2, &env->fp_status),
target-sparc/fop_helper.c:                       &env->fp_status);
target-sparc/fop_helper.c:    ret = int32_to_float32(src, &env->fp_status);
target-sparc/fop_helper.c:    return int32_to_float64(src, &env->fp_status);
target-sparc/fop_helper.c:    QT0 = int32_to_float128(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = int64_to_float32(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = int64_to_float64(src, &env->fp_status);
target-sparc/fop_helper.c:    QT0 = int64_to_float128(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = float64_to_float32(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = float32_to_float64(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = float128_to_float32(QT1, &env->fp_status);
target-sparc/fop_helper.c:    QT0 = float32_to_float128(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = float128_to_float64(QT1, &env->fp_status);
target-sparc/fop_helper.c:    QT0 = float64_to_float128(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = float32_to_int32_round_to_zero(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = float64_to_int32_round_to_zero(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = float128_to_int32_round_to_zero(QT1, &env->fp_status);
target-sparc/fop_helper.c:    ret = float32_to_int64_round_to_zero(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = float64_to_int64_round_to_zero(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = float128_to_int64_round_to_zero(QT1, &env->fp_status);
target-sparc/fop_helper.c:    ret = float32_sqrt(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = float64_sqrt(src, &env->fp_status);
target-sparc/fop_helper.c:    QT0 = float128_sqrt(QT1, &env->fp_status);
target-sparc/fop_helper.c:            ret = glue(size, _compare)(reg1, reg2, &env->fp_status);    \
target-sparc/fop_helper.c:                                             &env->fp_status);          \
target-sparc/fop_helper.c:            env->fsr |= (FSR_FCC1 | FSR_FCC0) << FS;                    \
target-sparc/fop_helper.c:            env->fsr |= FSR_NVA;                                        \
target-sparc/fop_helper.c:            env->fsr &= ~(FSR_FCC1) << FS;                              \
target-sparc/fop_helper.c:            env->fsr |= FSR_FCC0 << FS;                                 \
target-sparc/fop_helper.c:            env->fsr &= ~(FSR_FCC0) << FS;                              \
target-sparc/fop_helper.c:            env->fsr |= FSR_FCC1 << FS;                                 \
target-sparc/fop_helper.c:            env->fsr &= ~((FSR_FCC1 | FSR_FCC0) << FS);                 \
target-sparc/fop_helper.c:            ret = glue(size, _compare)(src1, src2, &env->fp_status);    \
target-sparc/fop_helper.c:                                             &env->fp_status);          \
target-sparc/fop_helper.c:            env->fsr |= (FSR_FCC1 | FSR_FCC0) << FS;                    \
target-sparc/fop_helper.c:            env->fsr &= ~(FSR_FCC1 << FS);                              \
target-sparc/fop_helper.c:            env->fsr |= FSR_FCC0 << FS;                                 \
target-sparc/fop_helper.c:            env->fsr &= ~(FSR_FCC0 << FS);                              \
target-sparc/fop_helper.c:            env->fsr |= FSR_FCC1 << FS;                                 \
target-sparc/fop_helper.c:            env->fsr &= ~((FSR_FCC1 | FSR_FCC0) << FS);                 \
target-sparc/fop_helper.c:    switch (env->fsr & FSR_RD_MASK) {
target-sparc/fop_helper.c:    set_float_rounding_mode(rnd_mode, &env->fp_status);
target-sparc/fop_helper.c:    env->fsr = (new_fsr & FSR_LDFSR_MASK) | (env->fsr & FSR_LDFSR_OLDMASK);
target-sparc/fop_helper.c:    env->fsr = (new_fsr & FSR_LDXFSR_MASK) | (env->fsr & FSR_LDXFSR_OLDMASK);
target-sparc/ldst_helper.c:#define QT0 (env->qt0)
target-sparc/ldst_helper.c:#define QT1 (env->qt1)
target-sparc/ldst_helper.c:               "\n", addr, env->pc);
target-sparc/ldst_helper.c:           env->mxccdata[0], env->mxccdata[1],
target-sparc/ldst_helper.c:           env->mxccdata[2], env->mxccdata[3]);
target-sparc/ldst_helper.c:           env->mxccregs[0], env->mxccregs[1],
target-sparc/ldst_helper.c:           env->mxccregs[2], env->mxccregs[3],
target-sparc/ldst_helper.c:           env->mxccregs[4], env->mxccregs[5],
target-sparc/ldst_helper.c:           env->mxccregs[6], env->mxccregs[7]);
target-sparc/ldst_helper.c:        env->cache_control = val;
target-sparc/ldst_helper.c:        ret = env->cache_control;
target-sparc/ldst_helper.c:            if (env->def->features & CPU_FEATURE_CACHE_CTRL) {
target-sparc/ldst_helper.c:                ret = env->mxccregs[3];
target-sparc/ldst_helper.c:                ret = env->mxccregs[3];
target-sparc/ldst_helper.c:                ret = env->mxccregs[5];
target-sparc/ldst_helper.c:                ret = env->mxccregs[7];
target-sparc/ldst_helper.c:            ret = env->mmuregs[reg];
target-sparc/ldst_helper.c:                env->mmuregs[3] = 0;
target-sparc/ldst_helper.c:                ret = env->mmuregs[3];
target-sparc/ldst_helper.c:                ret = env->mmuregs[4];
target-sparc/ldst_helper.c:                ret = env->mmubpregs[reg];
target-sparc/ldst_helper.c:                ret = env->mmubpregs[reg];
target-sparc/ldst_helper.c:                ret = env->mmubpregs[reg];
target-sparc/ldst_helper.c:                ret = env->mmubpregs[reg];
target-sparc/ldst_helper.c:                env->mmubpregs[reg] = 0ULL;
target-sparc/ldst_helper.c:        ret = env->mmubpctrv;
target-sparc/ldst_helper.c:        ret = env->mmubpctrc;
target-sparc/ldst_helper.c:        ret = env->mmubpctrs;
target-sparc/ldst_helper.c:        ret = env->mmubpaction;
target-sparc/ldst_helper.c:            if (env->def->features & CPU_FEATURE_CACHE_CTRL) {
target-sparc/ldst_helper.c:                env->mxccdata[0] = val;
target-sparc/ldst_helper.c:                env->mxccdata[1] = val;
target-sparc/ldst_helper.c:                env->mxccdata[2] = val;
target-sparc/ldst_helper.c:                env->mxccdata[3] = val;
target-sparc/ldst_helper.c:                env->mxccregs[0] = val;
target-sparc/ldst_helper.c:            env->mxccdata[0] = ldq_phys(cs->as,
target-sparc/ldst_helper.c:                                        (env->mxccregs[0] & 0xffffffffULL) +
target-sparc/ldst_helper.c:            env->mxccdata[1] = ldq_phys(cs->as,
target-sparc/ldst_helper.c:                                        (env->mxccregs[0] & 0xffffffffULL) +
target-sparc/ldst_helper.c:            env->mxccdata[2] = ldq_phys(cs->as,
target-sparc/ldst_helper.c:                                        (env->mxccregs[0] & 0xffffffffULL) +
target-sparc/ldst_helper.c:            env->mxccdata[3] = ldq_phys(cs->as,
target-sparc/ldst_helper.c:                                        (env->mxccregs[0] & 0xffffffffULL) +
target-sparc/ldst_helper.c:                env->mxccregs[1] = val;
target-sparc/ldst_helper.c:            stq_phys(cs->as, (env->mxccregs[1] & 0xffffffffULL) +  0,
target-sparc/ldst_helper.c:                     env->mxccdata[0]);
target-sparc/ldst_helper.c:            stq_phys(cs->as, (env->mxccregs[1] & 0xffffffffULL) +  8,
target-sparc/ldst_helper.c:                     env->mxccdata[1]);
target-sparc/ldst_helper.c:            stq_phys(cs->as, (env->mxccregs[1] & 0xffffffffULL) + 16,
target-sparc/ldst_helper.c:                     env->mxccdata[2]);
target-sparc/ldst_helper.c:            stq_phys(cs->as, (env->mxccregs[1] & 0xffffffffULL) + 24,
target-sparc/ldst_helper.c:                     env->mxccdata[3]);
target-sparc/ldst_helper.c:                env->mxccregs[3] = val;
target-sparc/ldst_helper.c:                env->mxccregs[3] = (env->mxccregs[3] & 0xffffffff00000000ULL)
target-sparc/ldst_helper.c:                env->mxccregs[6] &= ~val;
target-sparc/ldst_helper.c:                env->mxccregs[7] = val;
target-sparc/ldst_helper.c:            oldreg = env->mmuregs[reg];
target-sparc/ldst_helper.c:                env->mmuregs[reg] = (env->mmuregs[reg] & 0xff000000) |
target-sparc/ldst_helper.c:                if ((oldreg & (MMU_E | MMU_NF | env->def->mmu_bm)) !=
target-sparc/ldst_helper.c:                    (env->mmuregs[reg] & (MMU_E | MMU_NF | env->def->mmu_bm))) {
target-sparc/ldst_helper.c:                env->mmuregs[reg] = val & env->def->mmu_ctpr_mask;
target-sparc/ldst_helper.c:                env->mmuregs[reg] = val & env->def->mmu_cxr_mask;
target-sparc/ldst_helper.c:                if (oldreg != env->mmuregs[reg]) {
target-sparc/ldst_helper.c:                env->mmuregs[reg] = val & env->def->mmu_trcr_mask;
target-sparc/ldst_helper.c:                env->mmuregs[3] = val & env->def->mmu_sfsr_mask;
target-sparc/ldst_helper.c:                env->mmuregs[4] = val;
target-sparc/ldst_helper.c:                env->mmuregs[reg] = val;
target-sparc/ldst_helper.c:            if (oldreg != env->mmuregs[reg]) {
target-sparc/ldst_helper.c:                            reg, oldreg, env->mmuregs[reg]);
target-sparc/ldst_helper.c:                env->mmubpregs[reg] = (val & 0xfffffffffULL);
target-sparc/ldst_helper.c:                env->mmubpregs[reg] = (val & 0xfffffffffULL);
target-sparc/ldst_helper.c:                env->mmubpregs[reg] = (val & 0x7fULL);
target-sparc/ldst_helper.c:                env->mmubpregs[reg] = (val & 0xfULL);
target-sparc/ldst_helper.c:                        env->mmuregs[reg]);
target-sparc/ldst_helper.c:        env->mmubpctrv = val & 0xffffffff;
target-sparc/ldst_helper.c:        env->mmubpctrc = val & 0x3;
target-sparc/ldst_helper.c:        env->mmubpctrs = val & 0x3;
target-sparc/ldst_helper.c:        env->mmubpaction = val & 0x1fff;
target-sparc/ldst_helper.c:    if ((asi < 0x80 && (env->pstate & PS_PRIV) == 0)
target-sparc/ldst_helper.c:            && !(env->hpstate & HS_PRIV))) {
target-sparc/ldst_helper.c:        if (env->pstate & PS_PRIV) {
target-sparc/ldst_helper.c:            /* env->exception_index is set in get_physical_address_data(). */
target-sparc/ldst_helper.c:        if ((asi & 0x80) && (env->pstate & PS_PRIV)) {
target-sparc/ldst_helper.c:        ret = env->lsu;
target-sparc/ldst_helper.c:                ret = ultrasparc_tag_target(env->immu.tag_access);
target-sparc/ldst_helper.c:                ret = env->immuregs[reg];
target-sparc/ldst_helper.c:            /* env->immuregs[5] holds I-MMU TSB register value
target-sparc/ldst_helper.c:               env->immuregs[6] holds I-MMU Tag Access register value */
target-sparc/ldst_helper.c:            ret = ultrasparc_tsb_pointer(env->immu.tsb, env->immu.tag_access,
target-sparc/ldst_helper.c:            /* env->immuregs[5] holds I-MMU TSB register value
target-sparc/ldst_helper.c:               env->immuregs[6] holds I-MMU Tag Access register value */
target-sparc/ldst_helper.c:            ret = ultrasparc_tsb_pointer(env->immu.tsb, env->immu.tag_access,
target-sparc/ldst_helper.c:            ret = env->itlb[reg].tte;
target-sparc/ldst_helper.c:            ret = env->itlb[reg].tag;
target-sparc/ldst_helper.c:                ret = ultrasparc_tag_target(env->dmmu.tag_access);
target-sparc/ldst_helper.c:                ret = env->dmmuregs[reg];
target-sparc/ldst_helper.c:            /* env->dmmuregs[5] holds D-MMU TSB register value
target-sparc/ldst_helper.c:               env->dmmuregs[6] holds D-MMU Tag Access register value */
target-sparc/ldst_helper.c:            ret = ultrasparc_tsb_pointer(env->dmmu.tsb, env->dmmu.tag_access,
target-sparc/ldst_helper.c:            /* env->dmmuregs[5] holds D-MMU TSB register value
target-sparc/ldst_helper.c:               env->dmmuregs[6] holds D-MMU Tag Access register value */
target-sparc/ldst_helper.c:            ret = ultrasparc_tsb_pointer(env->dmmu.tsb, env->dmmu.tag_access,
target-sparc/ldst_helper.c:            ret = env->dtlb[reg].tte;
target-sparc/ldst_helper.c:            ret = env->dtlb[reg].tag;
target-sparc/ldst_helper.c:        ret = env->ivec_status;
target-sparc/ldst_helper.c:                ret = env->ivec_data[reg];
target-sparc/ldst_helper.c:    if ((asi < 0x80 && (env->pstate & PS_PRIV) == 0)
target-sparc/ldst_helper.c:            && !(env->hpstate & HS_PRIV))) {
target-sparc/ldst_helper.c:        if ((asi & 0x80) && (env->pstate & PS_PRIV)) {
target-sparc/ldst_helper.c:            oldreg = env->lsu;
target-sparc/ldst_helper.c:            env->lsu = val & (DMMU_E | IMMU_E);
target-sparc/ldst_helper.c:            if (oldreg != env->lsu) {
target-sparc/ldst_helper.c:                            oldreg, env->lsu);
target-sparc/ldst_helper.c:            oldreg = env->immuregs[reg];
target-sparc/ldst_helper.c:                env->immu.sfsr = val;
target-sparc/ldst_helper.c:                            PRIx64 "\n", env->immu.tsb, val);
target-sparc/ldst_helper.c:                env->immu.tsb = val;
target-sparc/ldst_helper.c:                env->immu.tag_access = val;
target-sparc/ldst_helper.c:            if (oldreg != env->immuregs[reg]) {
target-sparc/ldst_helper.c:                            PRIx64 "\n", reg, oldreg, env->immuregs[reg]);
target-sparc/ldst_helper.c:        replace_tlb_1bit_lru(env->itlb, env->immu.tag_access, val, "immu", env);
target-sparc/ldst_helper.c:            replace_tlb_entry(&env->itlb[i], env->immu.tag_access, val, env);
target-sparc/ldst_helper.c:        demap_tlb(env->itlb, addr, "immu", env);
target-sparc/ldst_helper.c:            oldreg = env->dmmuregs[reg];
target-sparc/ldst_helper.c:                    env->dmmu.sfar = 0;
target-sparc/ldst_helper.c:                env->dmmu.sfsr = val;
target-sparc/ldst_helper.c:                env->dmmu.mmu_primary_context = val;
target-sparc/ldst_helper.c:                env->dmmu.mmu_secondary_context = val;
target-sparc/ldst_helper.c:                            PRIx64 "\n", env->dmmu.tsb, val);
target-sparc/ldst_helper.c:                env->dmmu.tsb = val;
target-sparc/ldst_helper.c:                env->dmmu.tag_access = val;
target-sparc/ldst_helper.c:                env->dmmuregs[reg] = val;
target-sparc/ldst_helper.c:            if (oldreg != env->dmmuregs[reg]) {
target-sparc/ldst_helper.c:                            PRIx64 "\n", reg, oldreg, env->dmmuregs[reg]);
target-sparc/ldst_helper.c:        replace_tlb_1bit_lru(env->dtlb, env->dmmu.tag_access, val, "dmmu", env);
target-sparc/ldst_helper.c:            replace_tlb_entry(&env->dtlb[i], env->dmmu.tag_access, val, env);
target-sparc/ldst_helper.c:        demap_tlb(env->dtlb, addr, "dmmu", env);
target-sparc/ldst_helper.c:        env->ivec_status = val & 0x20;
target-sparc/ldst_helper.c:    if ((asi < 0x80 && (env->pstate & PS_PRIV) == 0)
target-sparc/ldst_helper.c:            && !(env->hpstate & HS_PRIV))) {
target-sparc/ldst_helper.c:            env->gregs[1] = cpu_ldq_nucleus(env, addr + 8);
target-sparc/ldst_helper.c:                bswap64s(&env->gregs[1]);
target-sparc/ldst_helper.c:            env->gregs[rd] = cpu_ldq_nucleus(env, addr);
target-sparc/ldst_helper.c:            env->gregs[rd + 1] = cpu_ldq_nucleus(env, addr + 8);
target-sparc/ldst_helper.c:                bswap64s(&env->gregs[rd]);
target-sparc/ldst_helper.c:                bswap64s(&env->gregs[rd + 1]);
target-sparc/ldst_helper.c:            env->regwptr[rd] = cpu_ldq_nucleus(env, addr);
target-sparc/ldst_helper.c:            env->regwptr[rd + 1] = cpu_ldq_nucleus(env, addr + 8);
target-sparc/ldst_helper.c:                bswap64s(&env->regwptr[rd]);
target-sparc/ldst_helper.c:                bswap64s(&env->regwptr[rd + 1]);
target-sparc/ldst_helper.c:            env->gregs[1] = helper_ld_asi(env, addr + 4, asi, 4, 0);
target-sparc/ldst_helper.c:            env->gregs[rd] = helper_ld_asi(env, addr, asi, 4, 0);
target-sparc/ldst_helper.c:            env->gregs[rd + 1] = helper_ld_asi(env, addr + 4, asi, 4, 0);
target-sparc/ldst_helper.c:            env->regwptr[rd] = helper_ld_asi(env, addr, asi, 4, 0);
target-sparc/ldst_helper.c:            env->regwptr[rd + 1] = helper_ld_asi(env, addr + 4, asi, 4, 0);
target-sparc/ldst_helper.c:            env->fpr[rd / 2].ll = helper_ld_asi(env, addr, asi & 0x8f, 8, 0);
target-sparc/ldst_helper.c:            env->fpr[rd / 2].ll = helper_ld_asi(env, addr, asi & 0x19, 8, 0);
target-sparc/ldst_helper.c:            env->fpr[rd / 2].l.lower = val;
target-sparc/ldst_helper.c:            env->fpr[rd / 2].l.upper = val;
target-sparc/ldst_helper.c:        env->fpr[rd / 2].ll = helper_ld_asi(env, addr, asi, size, 0);
target-sparc/ldst_helper.c:        env->fpr[rd / 2].ll = helper_ld_asi(env, addr, asi, 8, 0);
target-sparc/ldst_helper.c:        env->fpr[rd / 2 + 1].ll = helper_ld_asi(env, addr + 8, asi, 8, 0);
target-sparc/ldst_helper.c:            helper_st_asi(env, addr, env->fpr[rd / 2].ll, asi & 0x8f, 8);
target-sparc/ldst_helper.c:            helper_st_asi(env, addr, env->fpr[rd / 2].ll, asi & 0x19, 8);
target-sparc/ldst_helper.c:            val = env->fpr[rd / 2].l.lower;
target-sparc/ldst_helper.c:            val = env->fpr[rd / 2].l.upper;
target-sparc/ldst_helper.c:        helper_st_asi(env, addr, env->fpr[rd / 2].ll, asi, size);
target-sparc/ldst_helper.c:        helper_st_asi(env, addr, env->fpr[rd / 2].ll, asi, 8);
target-sparc/ldst_helper.c:        helper_st_asi(env, addr + 8, env->fpr[rd / 2 + 1].ll, asi, 8);
target-sparc/ldst_helper.c:               size == 1 ? "" : "s", addr, is_asi, env->pc);
target-sparc/ldst_helper.c:               size == 1 ? "" : "s", addr, env->pc);
target-sparc/ldst_helper.c:    fault_type = (env->mmuregs[3] & 0x1c) >> 2;
target-sparc/ldst_helper.c:        env->mmuregs[3] = 0; /* Fault status register */
target-sparc/ldst_helper.c:            env->mmuregs[3] |= 1 << 16;
target-sparc/ldst_helper.c:        if (env->psrs) {
target-sparc/ldst_helper.c:            env->mmuregs[3] |= 1 << 5;
target-sparc/ldst_helper.c:            env->mmuregs[3] |= 1 << 6;
target-sparc/ldst_helper.c:            env->mmuregs[3] |= 1 << 7;
target-sparc/ldst_helper.c:        env->mmuregs[3] |= (5 << 2) | 2;
target-sparc/ldst_helper.c:            env->mmuregs[4] = addr; /* Fault address register */
target-sparc/ldst_helper.c:    if (fault_type == ((env->mmuregs[3] & 0x1c)) >> 2) {
target-sparc/ldst_helper.c:        env->mmuregs[3] |= 1;
target-sparc/ldst_helper.c:    if ((env->mmuregs[0] & MMU_E) && !(env->mmuregs[0] & MMU_NF)) {
target-sparc/ldst_helper.c:    if (env->mmuregs[0] & MMU_NF) {
target-sparc/ldst_helper.c:           "\n", addr, env->pc);
target-sparc/ldst_helper.c:           "\n", addr, env->pc);
target-sparc/int64_helper.c:    if (env->cc_op != CC_OP_FLAGS) {
target-sparc/int64_helper.c:            ptr = (uint8_t *)env->pc;
target-sparc/int64_helper.c:    if (env->tl >= env->maxtl) {
target-sparc/int64_helper.c:                  " Error state", cs->exception_index, env->tl, env->maxtl);
target-sparc/int64_helper.c:    if (env->tl < env->maxtl - 1) {
target-sparc/int64_helper.c:        env->tl++;
target-sparc/int64_helper.c:        env->pstate |= PS_RED;
target-sparc/int64_helper.c:        if (env->tl < env->maxtl) {
target-sparc/int64_helper.c:            env->tl++;
target-sparc/int64_helper.c:        ((env->asi & 0xff) << 24) | ((env->pstate & 0xf3f) << 8) |
target-sparc/int64_helper.c:    tsptr->tpc = env->pc;
target-sparc/int64_helper.c:    tsptr->tnpc = env->npc;
target-sparc/int64_helper.c:        cpu_set_cwp(env, cpu_cwp_dec(env, env->cwp - 1));
target-sparc/int64_helper.c:        cpu_set_cwp(env, cpu_cwp_dec(env, env->cwp - env->cansave - 2));
target-sparc/int64_helper.c:        cpu_set_cwp(env, cpu_cwp_inc(env, env->cwp + 1));
target-sparc/int64_helper.c:    env->tbr &= ~0x7fffULL;
target-sparc/int64_helper.c:    env->tbr |= ((env->tl > 1) ? 1 << 14 : 0) | (intno << 5);
target-sparc/int64_helper.c:    env->pc = env->tbr;
target-sparc/int64_helper.c:    env->npc = env->pc + 4;
target-sparc/int64_helper.c:    return &env->ts[env->tl & MAXTL_MASK];
target-sparc/int64_helper.c:    if (env->softint != value) {
target-sparc/int64_helper.c:        env->softint = value;
target-sparc/int64_helper.c:    if (do_modify_softint(env, env->softint | (uint32_t)value)) {
target-sparc/int64_helper.c:        trace_int_helper_set_softint(env->softint);
target-sparc/int64_helper.c:    if (do_modify_softint(env, env->softint & (uint32_t)~value)) {
target-sparc/int64_helper.c:        trace_int_helper_clear_softint(env->softint);
target-sparc/int64_helper.c:        trace_int_helper_write_softint(env->softint);
target-sparc/translate.c:    if (!(env->y & 1))
target-sparc/translate.c:    // env->y = (b2 << 31) | (env->y >> 1);
target-sparc/translate.c:    /* load env->tl into r_tl */
target-sparc/translate.c:    /* calculate offset to current trap state from env->ts, reuse r_tl */
target-sparc/translate.c:    /* tsptr = env->ts[env->tl & MAXTL_MASK] */
target-sparc/translate.c:    dc->def = env->def;
target-sparc/translate.c:    env->pc = tcg_ctx.gen_opc_pc[pc_pos];
target-sparc/translate.c:        if (env->cond) {
target-sparc/translate.c:            env->npc = gen_opc_jump_pc[0];
target-sparc/translate.c:            env->npc = gen_opc_jump_pc[1];
target-sparc/translate.c:        env->npc = npc;
target-sparc/mmu_helper.c:    if ((env->mmuregs[0] & MMU_E) == 0) { /* MMU disabled */
target-sparc/mmu_helper.c:        if (rw == 2 && (env->mmuregs[0] & env->def->mmu_bm)) {
target-sparc/mmu_helper.c:            *physical = env->prom_addr | (address & 0x7ffffULL);
target-sparc/mmu_helper.c:    pde_ptr = (env->mmuregs[1] << 4) + (env->mmuregs[2] << 2);
target-sparc/mmu_helper.c:    if (error_code && !((env->mmuregs[0] & MMU_NF) && is_user)) {
target-sparc/mmu_helper.c:    if (env->mmuregs[3]) { /* Fault status register */
target-sparc/mmu_helper.c:        env->mmuregs[3] = 1; /* overflow (not read before another fault) */
target-sparc/mmu_helper.c:    env->mmuregs[3] |= (access_index << 5) | error_code | 2;
target-sparc/mmu_helper.c:    env->mmuregs[4] = address; /* Fault address register */
target-sparc/mmu_helper.c:    if ((env->mmuregs[0] & MMU_NF) || env->psret == 0)  {
target-sparc/mmu_helper.c:    pde_ptr = (hwaddr)(env->mmuregs[1] << 4) +
target-sparc/mmu_helper.c:        (env->mmuregs[2] << 2);
target-sparc/mmu_helper.c:    pde_ptr = (env->mmuregs[1] << 4) + (env->mmuregs[2] << 2);
target-sparc/mmu_helper.c:                   (hwaddr)env->mmuregs[1] << 4, env->mmuregs[2]);
target-sparc/mmu_helper.c:    int cwp = env->cwp;
target-sparc/mmu_helper.c:        for (i = 0; i < env->nwindows; i++) {
target-sparc/mmu_helper.c:            target_ulong fp = env->regbase[cwp * 16 + 22];
target-sparc/mmu_helper.c:            if (env->wim & (1 << cwp)) {
target-sparc/mmu_helper.c:                u.v = cpu_to_be32(env->regbase[reg]);
target-sparc/mmu_helper.c:    if ((env->lsu & DMMU_E) == 0) { /* DMMU disabled */
target-sparc/mmu_helper.c:        context = env->dmmu.mmu_primary_context & 0x1fff;
target-sparc/mmu_helper.c:        context = env->dmmu.mmu_secondary_context & 0x1fff;
target-sparc/mmu_helper.c:        if (ultrasparc_tag_match(&env->dtlb[i], address, context, physical)) {
target-sparc/mmu_helper.c:            if (TTE_IS_PRIV(env->dtlb[i].tte) && is_user) {
target-sparc/mmu_helper.c:                trace_mmu_helper_dfault(address, context, mmu_idx, env->tl);
target-sparc/mmu_helper.c:                if (TTE_IS_SIDEEFFECT(env->dtlb[i].tte)) {
target-sparc/mmu_helper.c:                if (TTE_IS_NFO(env->dtlb[i].tte)) {
target-sparc/mmu_helper.c:            } else if (!TTE_IS_W_OK(env->dtlb[i].tte) && (rw == 1)) {
target-sparc/mmu_helper.c:                trace_mmu_helper_dprot(address, context, mmu_idx, env->tl);
target-sparc/mmu_helper.c:                if (TTE_IS_W_OK(env->dtlb[i].tte)) {
target-sparc/mmu_helper.c:                TTE_SET_USED(env->dtlb[i].tte);
target-sparc/mmu_helper.c:            if (env->dmmu.sfsr & SFSR_VALID_BIT) { /* Fault status register */
target-sparc/mmu_helper.c:            if (env->pstate & PS_PRIV) {
target-sparc/mmu_helper.c:            env->dmmu.sfsr = sfsr | SFSR_VALID_BIT;
target-sparc/mmu_helper.c:            env->dmmu.sfar = address; /* Fault address register */
target-sparc/mmu_helper.c:            env->dmmu.tag_access = (address & ~0x1fffULL) | context;
target-sparc/mmu_helper.c:    env->dmmu.tag_access = (address & ~0x1fffULL) | context;
target-sparc/mmu_helper.c:    if ((env->lsu & IMMU_E) == 0 || (env->pstate & PS_RED) != 0) {
target-sparc/mmu_helper.c:    if (env->tl == 0) {
target-sparc/mmu_helper.c:        context = env->dmmu.mmu_primary_context & 0x1fff;
target-sparc/mmu_helper.c:        if (ultrasparc_tag_match(&env->itlb[i],
target-sparc/mmu_helper.c:            if (TTE_IS_PRIV(env->itlb[i].tte) && is_user) {
target-sparc/mmu_helper.c:                if (env->immu.sfsr & SFSR_VALID_BIT) {
target-sparc/mmu_helper.c:                    env->immu.sfsr = SFSR_OW_BIT; /* overflow (not read before
target-sparc/mmu_helper.c:                    env->immu.sfsr = 0;
target-sparc/mmu_helper.c:                if (env->pstate & PS_PRIV) {
target-sparc/mmu_helper.c:                    env->immu.sfsr |= SFSR_PR_BIT;
target-sparc/mmu_helper.c:                if (env->tl > 0) {
target-sparc/mmu_helper.c:                    env->immu.sfsr |= SFSR_CT_NUCLEUS;
target-sparc/mmu_helper.c:                env->immu.sfsr |= SFSR_FT_PRIV_BIT | SFSR_VALID_BIT;
target-sparc/mmu_helper.c:                env->immu.tag_access = (address & ~0x1fffULL) | context;
target-sparc/mmu_helper.c:            TTE_SET_USED(env->itlb[i].tte);
target-sparc/mmu_helper.c:    env->immu.tag_access = (address & ~0x1fffULL) | context;
target-sparc/mmu_helper.c:    if (env->tl > 0 && mmu_idx != MMU_NUCLEUS_IDX) {
target-sparc/mmu_helper.c:            trace_mmu_helper_get_phys_addr_code(env->tl, mmu_idx,
target-sparc/mmu_helper.c:                                                env->dmmu.mmu_primary_context,
target-sparc/mmu_helper.c:                                                env->dmmu.mmu_secondary_context,
target-sparc/mmu_helper.c:            trace_mmu_helper_get_phys_addr_data(env->tl, mmu_idx,
target-sparc/mmu_helper.c:                                                env->dmmu.mmu_primary_context,
target-sparc/mmu_helper.c:                                                env->dmmu.mmu_secondary_context,
target-sparc/mmu_helper.c:        trace_mmu_helper_mmu_fault(address, paddr, mmu_idx, env->tl,
target-sparc/mmu_helper.c:                                   env->dmmu.mmu_primary_context,
target-sparc/mmu_helper.c:                                   env->dmmu.mmu_secondary_context);
target-sparc/mmu_helper.c:                   env->dmmu.mmu_primary_context,
target-sparc/mmu_helper.c:                   env->dmmu.mmu_secondary_context);
target-sparc/mmu_helper.c:    if ((env->lsu & DMMU_E) == 0) {
target-sparc/mmu_helper.c:            switch (TTE_PGSIZE(env->dtlb[i].tte)) {
target-sparc/mmu_helper.c:            if (TTE_IS_VALID(env->dtlb[i].tte)) {
target-sparc/mmu_helper.c:                               env->dtlb[i].tag & (uint64_t)~0x1fffULL,
target-sparc/mmu_helper.c:                               TTE_PA(env->dtlb[i].tte),
target-sparc/mmu_helper.c:                               TTE_IS_PRIV(env->dtlb[i].tte) ? "priv" : "user",
target-sparc/mmu_helper.c:                               TTE_IS_W_OK(env->dtlb[i].tte) ? "RW" : "RO",
target-sparc/mmu_helper.c:                               TTE_IS_LOCKED(env->dtlb[i].tte) ?
target-sparc/mmu_helper.c:                               env->dtlb[i].tag & (uint64_t)0x1fffULL,
target-sparc/mmu_helper.c:                               TTE_IS_GLOBAL(env->dtlb[i].tte) ?
target-sparc/mmu_helper.c:    if ((env->lsu & IMMU_E) == 0) {
target-sparc/mmu_helper.c:            switch (TTE_PGSIZE(env->itlb[i].tte)) {
target-sparc/mmu_helper.c:            if (TTE_IS_VALID(env->itlb[i].tte)) {
target-sparc/mmu_helper.c:                               env->itlb[i].tag & (uint64_t)~0x1fffULL,
target-sparc/mmu_helper.c:                               TTE_PA(env->itlb[i].tte),
target-sparc/mmu_helper.c:                               TTE_IS_PRIV(env->itlb[i].tte) ? "priv" : "user",
target-sparc/mmu_helper.c:                               TTE_IS_LOCKED(env->itlb[i].tte) ?
target-sparc/mmu_helper.c:                               env->itlb[i].tag & (uint64_t)0x1fffULL,
target-sparc/mmu_helper.c:                               TTE_IS_GLOBAL(env->itlb[i].tte) ?
target-sparc/int32_helper.c:    if (env->cc_op != CC_OP_FLAGS) {
target-sparc/int32_helper.c:            ptr = (uint8_t *)env->pc;
target-sparc/int32_helper.c:    if (env->psret == 0) {
target-sparc/int32_helper.c:            env->def->features & CPU_FEATURE_TA0_SHUTDOWN) {
target-sparc/int32_helper.c:    env->psret = 0;
target-sparc/int32_helper.c:    cwp = cpu_cwp_dec(env, env->cwp - 1);
target-sparc/int32_helper.c:    env->regwptr[9] = env->pc;
target-sparc/int32_helper.c:    env->regwptr[10] = env->npc;
target-sparc/int32_helper.c:    env->psrps = env->psrs;
target-sparc/int32_helper.c:    env->psrs = 1;
target-sparc/int32_helper.c:    env->tbr = (env->tbr & TBR_BASE_MASK) | (intno << 4);
target-sparc/int32_helper.c:    env->pc = env->tbr;
target-sparc/int32_helper.c:    env->npc = env->pc + 4;
target-sparc/int32_helper.c:    if ((intno & ~15) == TT_EXTINT && env->qemu_irq_ack != NULL) {
target-sparc/int32_helper.c:        env->qemu_irq_ack(env, env->irq_manager, intno);
target-sparc/int32_helper.c:    if (env->cache_control & CACHE_CTRL_IF) {
target-sparc/int32_helper.c:        state = env->cache_control & CACHE_STATE_MASK;
target-sparc/int32_helper.c:        env->cache_control &= ~CACHE_STATE_MASK;
target-sparc/int32_helper.c:        env->cache_control |= state;
target-sparc/int32_helper.c:    if (env->cache_control & CACHE_CTRL_DF) {
target-sparc/int32_helper.c:        state = (env->cache_control >> 2) & CACHE_STATE_MASK;
target-sparc/int32_helper.c:        env->cache_control &= ~(CACHE_STATE_MASK << 2);
target-sparc/int32_helper.c:        env->cache_control |= (state << 2);
target-sparc/helper.c:    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);
target-sparc/helper.c:        env->cc_dst = x0;
target-sparc/helper.c:        env->cc_src2 = overflow;
target-sparc/helper.c:        env->cc_op = CC_OP_DIV;
target-sparc/helper.c:    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);
target-sparc/helper.c:        env->cc_dst = x0;
target-sparc/helper.c:        env->cc_src2 = overflow;
target-sparc/helper.c:        env->cc_op = CC_OP_DIV;
target-sparc/helper.c:    env->cc_op = CC_OP_TADDTV;
target-sparc/helper.c:    env->cc_src = src1;
target-sparc/helper.c:    env->cc_src2 = src2;
target-sparc/helper.c:    env->cc_dst = dst;
target-sparc/helper.c:    env->cc_op = CC_OP_TSUBTV;
target-sparc/helper.c:    env->cc_src = src1;
target-sparc/helper.c:    env->cc_src2 = src2;
target-sparc/helper.c:    env->cc_dst = dst;
target-sparc/helper.c:    env->pc = env->npc;
target-sparc/helper.c:    env->npc = env->pc + 4;
target-sparc/win_helper.c:    if (env->cwp == env->nwindows - 1) {
target-sparc/win_helper.c:        memcpy32(env->regbase, env->regbase + env->nwindows * 16);
target-sparc/win_helper.c:    env->cwp = new_cwp;
target-sparc/win_helper.c:    if (new_cwp == env->nwindows - 1) {
target-sparc/win_helper.c:        memcpy32(env->regbase + env->nwindows * 16, env->regbase);
target-sparc/win_helper.c:    env->regwptr = env->regbase + (new_cwp * 16);
target-sparc/win_helper.c:    return env->version | (env->psr & PSR_ICC) |
target-sparc/win_helper.c:        (env->psref ? PSR_EF : 0) |
target-sparc/win_helper.c:        (env->psrpil << 8) |
target-sparc/win_helper.c:        (env->psrs ? PSR_S : 0) |
target-sparc/win_helper.c:        (env->psrps ? PSR_PS : 0) |
target-sparc/win_helper.c:        (env->psret ? PSR_ET : 0) | env->cwp;
target-sparc/win_helper.c:    return env->psr & PSR_ICC;
target-sparc/win_helper.c:    env->psr = val & PSR_ICC;
target-sparc/win_helper.c:    env->psref = (val & PSR_EF) ? 1 : 0;
target-sparc/win_helper.c:    env->psrpil = (val & PSR_PIL) >> 8;
target-sparc/win_helper.c:    env->psrs = (val & PSR_S) ? 1 : 0;
target-sparc/win_helper.c:    env->psrps = (val & PSR_PS) ? 1 : 0;
target-sparc/win_helper.c:    env->psret = (val & PSR_ET) ? 1 : 0;
target-sparc/win_helper.c:    env->cc_op = CC_OP_FLAGS;
target-sparc/win_helper.c:    if (unlikely(cwp >= env->nwindows)) {
target-sparc/win_helper.c:        cwp -= env->nwindows;
target-sparc/win_helper.c:        cwp += env->nwindows;
target-sparc/win_helper.c:    if (env->psret == 1) {
target-sparc/win_helper.c:    env->psret = 1;
target-sparc/win_helper.c:    cwp = cpu_cwp_inc(env, env->cwp + 1) ;
target-sparc/win_helper.c:    if (env->wim & (1 << cwp)) {
target-sparc/win_helper.c:    env->psrs = env->psrps;
target-sparc/win_helper.c:    cwp = cpu_cwp_dec(env, env->cwp - 1);
target-sparc/win_helper.c:    if (env->wim & (1 << cwp)) {
target-sparc/win_helper.c:    cwp = cpu_cwp_inc(env, env->cwp + 1);
target-sparc/win_helper.c:    if (env->wim & (1 << cwp)) {
target-sparc/win_helper.c:    if ((new_psr & PSR_CWP) >= env->nwindows) {
target-sparc/win_helper.c:    cwp = cpu_cwp_dec(env, env->cwp - 1);
target-sparc/win_helper.c:    if (env->cansave == 0) {
target-sparc/win_helper.c:        helper_raise_exception(env, TT_SPILL | (env->otherwin != 0 ?
target-sparc/win_helper.c:                                                 ((env->wstate & 0x38) >> 1)) :
target-sparc/win_helper.c:                                                ((env->wstate & 0x7) << 2)));
target-sparc/win_helper.c:        if (env->cleanwin - env->canrestore == 0) {
target-sparc/win_helper.c:            env->cansave--;
target-sparc/win_helper.c:            env->canrestore++;
target-sparc/win_helper.c:    cwp = cpu_cwp_inc(env, env->cwp + 1);
target-sparc/win_helper.c:    if (env->canrestore == 0) {
target-sparc/win_helper.c:        helper_raise_exception(env, TT_FILL | (env->otherwin != 0 ?
target-sparc/win_helper.c:                                                ((env->wstate & 0x38) >> 1)) :
target-sparc/win_helper.c:                                               ((env->wstate & 0x7) << 2)));
target-sparc/win_helper.c:        env->cansave++;
target-sparc/win_helper.c:        env->canrestore--;
target-sparc/win_helper.c:    if (env->cansave != env->nwindows - 2) {
target-sparc/win_helper.c:        helper_raise_exception(env, TT_SPILL | (env->otherwin != 0 ?
target-sparc/win_helper.c:                                                 ((env->wstate & 0x38) >> 1)) :
target-sparc/win_helper.c:                                                ((env->wstate & 0x7) << 2)));
target-sparc/win_helper.c:    env->cansave++;
target-sparc/win_helper.c:    if (env->otherwin == 0) {
target-sparc/win_helper.c:        env->canrestore--;
target-sparc/win_helper.c:        env->otherwin--;
target-sparc/win_helper.c:    env->canrestore++;
target-sparc/win_helper.c:    if (env->cleanwin < env->nwindows - 1) {
target-sparc/win_helper.c:        env->cleanwin++;
target-sparc/win_helper.c:    if (env->otherwin == 0) {
target-sparc/win_helper.c:        env->cansave--;
target-sparc/win_helper.c:        env->otherwin--;
target-sparc/win_helper.c:    return ((env->xcc >> 20) << 4) | ((psr & PSR_ICC) >> 20);
target-sparc/win_helper.c:    env->xcc = (val >> 4) << 20;
target-sparc/win_helper.c:    env->psr = (val & 0xf) << 20;
target-sparc/win_helper.c:    return env->nwindows - 1 - env->cwp;
target-sparc/win_helper.c:    if (unlikely(cwp >= env->nwindows || cwp < 0)) {
target-sparc/win_helper.c:        cwp %= env->nwindows;
target-sparc/win_helper.c:    cpu_set_cwp(env, env->nwindows - 1 - cwp);
target-sparc/win_helper.c:        return env->bgregs;
target-sparc/win_helper.c:        return env->agregs;
target-sparc/win_helper.c:        return env->mgregs;
target-sparc/win_helper.c:        return env->igregs;
target-sparc/win_helper.c:    if (env->def->features & CPU_FEATURE_GL) {
target-sparc/win_helper.c:    pstate_regs = env->pstate & 0xc01;
target-sparc/win_helper.c:        memcpy32(dst, env->gregs);
target-sparc/win_helper.c:        memcpy32(env->gregs, src);
target-sparc/win_helper.c:    env->pstate = new_pstate;
target-sparc/win_helper.c:    trace_win_helper_wrpil(env->psrpil, (uint32_t)new_pil);
target-sparc/win_helper.c:    env->psrpil = new_pil;
target-sparc/win_helper.c:    env->pc = tsptr->tnpc;
target-sparc/win_helper.c:    env->npc = tsptr->tnpc + 4;
target-sparc/win_helper.c:    env->asi = (tsptr->tstate >> 24) & 0xff;
target-sparc/win_helper.c:    env->tl--;
target-sparc/win_helper.c:    trace_win_helper_done(env->tl);
target-sparc/win_helper.c:    env->pc = tsptr->tpc;
target-sparc/win_helper.c:    env->npc = tsptr->tnpc;
target-sparc/win_helper.c:    env->asi = (tsptr->tstate >> 24) & 0xff;
target-sparc/win_helper.c:    env->tl--;
target-sparc/win_helper.c:    trace_win_helper_retry(env->tl);
target-sparc/machine.c:    // if env->cwp == env->nwindows - 1, this will set the ins of the last
target-sparc/machine.c:    cpu_set_cwp(env, env->cwp);
target-sparc/machine.c:        qemu_put_betls(f, &env->gregs[i]);
target-sparc/machine.c:    qemu_put_be32s(f, &env->nwindows);
target-sparc/machine.c:    for(i = 0; i < env->nwindows * 16; i++)
target-sparc/machine.c:        qemu_put_betls(f, &env->regbase[i]);
target-sparc/machine.c:        qemu_put_be32(f, env->fpr[i].l.upper);
target-sparc/machine.c:        qemu_put_be32(f, env->fpr[i].l.lower);
target-sparc/machine.c:    qemu_put_betls(f, &env->pc);
target-sparc/machine.c:    qemu_put_betls(f, &env->npc);
target-sparc/machine.c:    qemu_put_betls(f, &env->y);
target-sparc/machine.c:    qemu_put_betls(f, &env->fsr);
target-sparc/machine.c:    qemu_put_betls(f, &env->tbr);
target-sparc/machine.c:    tmp = env->interrupt_index;
target-sparc/machine.c:    qemu_put_be32s(f, &env->pil_in);
target-sparc/machine.c:    qemu_put_be32s(f, &env->wim);
target-sparc/machine.c:        qemu_put_be32s(f, &env->mmuregs[i]);
target-sparc/machine.c:        qemu_put_be64s(f, &env->mxccdata[i]);
target-sparc/machine.c:        qemu_put_be64s(f, &env->mxccregs[i]);
target-sparc/machine.c:    qemu_put_be32s(f, &env->mmubpctrv);
target-sparc/machine.c:    qemu_put_be32s(f, &env->mmubpctrc);
target-sparc/machine.c:    qemu_put_be32s(f, &env->mmubpctrs);
target-sparc/machine.c:    qemu_put_be64s(f, &env->mmubpaction);
target-sparc/machine.c:        qemu_put_be64s(f, &env->mmubpregs[i]);
target-sparc/machine.c:    qemu_put_be64s(f, &env->lsu);
target-sparc/machine.c:        qemu_put_be64s(f, &env->immuregs[i]);
target-sparc/machine.c:        qemu_put_be64s(f, &env->dmmuregs[i]);
target-sparc/machine.c:        qemu_put_be64s(f, &env->itlb[i].tag);
target-sparc/machine.c:        qemu_put_be64s(f, &env->itlb[i].tte);
target-sparc/machine.c:        qemu_put_be64s(f, &env->dtlb[i].tag);
target-sparc/machine.c:        qemu_put_be64s(f, &env->dtlb[i].tte);
target-sparc/machine.c:    qemu_put_be32s(f, &env->mmu_version);
target-sparc/machine.c:        qemu_put_be64s(f, &env->ts[i].tpc);
target-sparc/machine.c:        qemu_put_be64s(f, &env->ts[i].tnpc);
target-sparc/machine.c:        qemu_put_be64s(f, &env->ts[i].tstate);
target-sparc/machine.c:        qemu_put_be32s(f, &env->ts[i].tt);
target-sparc/machine.c:    qemu_put_be32s(f, &env->xcc);
target-sparc/machine.c:    qemu_put_be32s(f, &env->asi);
target-sparc/machine.c:    qemu_put_be32s(f, &env->pstate);
target-sparc/machine.c:    qemu_put_be32s(f, &env->tl);
target-sparc/machine.c:    qemu_put_be32s(f, &env->cansave);
target-sparc/machine.c:    qemu_put_be32s(f, &env->canrestore);
target-sparc/machine.c:    qemu_put_be32s(f, &env->otherwin);
target-sparc/machine.c:    qemu_put_be32s(f, &env->wstate);
target-sparc/machine.c:    qemu_put_be32s(f, &env->cleanwin);
target-sparc/machine.c:        qemu_put_be64s(f, &env->agregs[i]);
target-sparc/machine.c:        qemu_put_be64s(f, &env->bgregs[i]);
target-sparc/machine.c:        qemu_put_be64s(f, &env->igregs[i]);
target-sparc/machine.c:        qemu_put_be64s(f, &env->mgregs[i]);
target-sparc/machine.c:    qemu_put_be64s(f, &env->fprs);
target-sparc/machine.c:    qemu_put_be64s(f, &env->tick_cmpr);
target-sparc/machine.c:    qemu_put_be64s(f, &env->stick_cmpr);
target-sparc/machine.c:    cpu_put_timer(f, env->tick);
target-sparc/machine.c:    cpu_put_timer(f, env->stick);
target-sparc/machine.c:    qemu_put_be64s(f, &env->gsr);
target-sparc/machine.c:    qemu_put_be32s(f, &env->gl);
target-sparc/machine.c:    qemu_put_be64s(f, &env->hpstate);
target-sparc/machine.c:        qemu_put_be64s(f, &env->htstate[i]);
target-sparc/machine.c:    qemu_put_be64s(f, &env->hintp);
target-sparc/machine.c:    qemu_put_be64s(f, &env->htba);
target-sparc/machine.c:    qemu_put_be64s(f, &env->hver);
target-sparc/machine.c:    qemu_put_be64s(f, &env->hstick_cmpr);
target-sparc/machine.c:    qemu_put_be64s(f, &env->ssr);
target-sparc/machine.c:    cpu_put_timer(f, env->hstick);
target-sparc/machine.c:        qemu_get_betls(f, &env->gregs[i]);
target-sparc/machine.c:    qemu_get_be32s(f, &env->nwindows);
target-sparc/machine.c:    for(i = 0; i < env->nwindows * 16; i++)
target-sparc/machine.c:        qemu_get_betls(f, &env->regbase[i]);
target-sparc/machine.c:        env->fpr[i].l.upper = qemu_get_be32(f);
target-sparc/machine.c:        env->fpr[i].l.lower = qemu_get_be32(f);
target-sparc/machine.c:    qemu_get_betls(f, &env->pc);
target-sparc/machine.c:    qemu_get_betls(f, &env->npc);
target-sparc/machine.c:    qemu_get_betls(f, &env->y);
target-sparc/machine.c:    env->cwp = 0; /* needed to ensure that the wrapping registers are
target-sparc/machine.c:    qemu_get_betls(f, &env->fsr);
target-sparc/machine.c:    qemu_get_betls(f, &env->tbr);
target-sparc/machine.c:    env->interrupt_index = tmp;
target-sparc/machine.c:    qemu_get_be32s(f, &env->pil_in);
target-sparc/machine.c:    qemu_get_be32s(f, &env->wim);
target-sparc/machine.c:        qemu_get_be32s(f, &env->mmuregs[i]);
target-sparc/machine.c:        qemu_get_be64s(f, &env->mxccdata[i]);
target-sparc/machine.c:        qemu_get_be64s(f, &env->mxccregs[i]);
target-sparc/machine.c:    qemu_get_be32s(f, &env->mmubpctrv);
target-sparc/machine.c:    qemu_get_be32s(f, &env->mmubpctrc);
target-sparc/machine.c:    qemu_get_be32s(f, &env->mmubpctrs);
target-sparc/machine.c:    qemu_get_be64s(f, &env->mmubpaction);
target-sparc/machine.c:        qemu_get_be64s(f, &env->mmubpregs[i]);
target-sparc/machine.c:    qemu_get_be64s(f, &env->lsu);
target-sparc/machine.c:        qemu_get_be64s(f, &env->immuregs[i]);
target-sparc/machine.c:        qemu_get_be64s(f, &env->dmmuregs[i]);
target-sparc/machine.c:        qemu_get_be64s(f, &env->itlb[i].tag);
target-sparc/machine.c:        qemu_get_be64s(f, &env->itlb[i].tte);
target-sparc/machine.c:        qemu_get_be64s(f, &env->dtlb[i].tag);
target-sparc/machine.c:        qemu_get_be64s(f, &env->dtlb[i].tte);
target-sparc/machine.c:    qemu_get_be32s(f, &env->mmu_version);
target-sparc/machine.c:        qemu_get_be64s(f, &env->ts[i].tpc);
target-sparc/machine.c:        qemu_get_be64s(f, &env->ts[i].tnpc);
target-sparc/machine.c:        qemu_get_be64s(f, &env->ts[i].tstate);
target-sparc/machine.c:        qemu_get_be32s(f, &env->ts[i].tt);
target-sparc/machine.c:    qemu_get_be32s(f, &env->xcc);
target-sparc/machine.c:    qemu_get_be32s(f, &env->asi);
target-sparc/machine.c:    qemu_get_be32s(f, &env->pstate);
target-sparc/machine.c:    qemu_get_be32s(f, &env->tl);
target-sparc/machine.c:    qemu_get_be32s(f, &env->cansave);
target-sparc/machine.c:    qemu_get_be32s(f, &env->canrestore);
target-sparc/machine.c:    qemu_get_be32s(f, &env->otherwin);
target-sparc/machine.c:    qemu_get_be32s(f, &env->wstate);
target-sparc/machine.c:    qemu_get_be32s(f, &env->cleanwin);
target-sparc/machine.c:        qemu_get_be64s(f, &env->agregs[i]);
target-sparc/machine.c:        qemu_get_be64s(f, &env->bgregs[i]);
target-sparc/machine.c:        qemu_get_be64s(f, &env->igregs[i]);
target-sparc/machine.c:        qemu_get_be64s(f, &env->mgregs[i]);
target-sparc/machine.c:    qemu_get_be64s(f, &env->fprs);
target-sparc/machine.c:    qemu_get_be64s(f, &env->tick_cmpr);
target-sparc/machine.c:    qemu_get_be64s(f, &env->stick_cmpr);
target-sparc/machine.c:    cpu_get_timer(f, env->tick);
target-sparc/machine.c:    cpu_get_timer(f, env->stick);
target-sparc/machine.c:    qemu_get_be64s(f, &env->gsr);
target-sparc/machine.c:    qemu_get_be32s(f, &env->gl);
target-sparc/machine.c:    qemu_get_be64s(f, &env->hpstate);
target-sparc/machine.c:        qemu_get_be64s(f, &env->htstate[i]);
target-sparc/machine.c:    qemu_get_be64s(f, &env->hintp);
target-sparc/machine.c:    qemu_get_be64s(f, &env->htba);
target-sparc/machine.c:    qemu_get_be64s(f, &env->hver);
target-sparc/machine.c:    qemu_get_be64s(f, &env->hstick_cmpr);
target-sparc/machine.c:    qemu_get_be64s(f, &env->ssr);
target-sparc/machine.c:    cpu_get_timer(f, env->hstick);
target-sparc/cpu.h:#define CC_SRC (env->cc_src)
target-sparc/cpu.h:#define CC_SRC2 (env->cc_src2)
target-sparc/cpu.h:#define CC_DST (env->cc_dst)
target-sparc/cpu.h:#define CC_OP  (env->cc_op)
target-sparc/cpu.h:    *pc = env->pc;
target-sparc/cpu.h:    *cs_base = env->npc;
target-sparc/cpu.h:    *flags = (env->pstate & PS_PRIV)               /* 2 */
target-sparc/cpu.h:        | ((env->lsu & (DMMU_E | IMMU_E)) >> 2)    /* 1, 0 */
target-sparc/cpu.h:        | ((env->tl & 0xff) << 8)
target-sparc/cpu.h:        | (env->dmmu.mmu_primary_context << 16);   /* 16... */
target-sparc/cpu.h:    if (env->pstate & PS_AM) {
target-sparc/cpu.h:    if ((env->def->features & CPU_FEATURE_FLOAT) && (env->pstate & PS_PEF)
target-sparc/cpu.h:        && (env->fprs & FPRS_FEF)) {
target-sparc/cpu.h:    *flags = env->psrs;
target-sparc/cpu.h:    if ((env->def->features & CPU_FEATURE_FLOAT) && env->psref) {
target-sparc/cpu.c:    env->cwp = 0;
target-sparc/cpu.c:    env->wim = 1;
target-sparc/cpu.c:    env->regwptr = env->regbase + (env->cwp * 16);
target-sparc/cpu.c:    env->cleanwin = env->nwindows - 2;
target-sparc/cpu.c:    env->cansave = env->nwindows - 2;
target-sparc/cpu.c:    env->pstate = PS_RMO | PS_PEF | PS_IE;
target-sparc/cpu.c:    env->asi = 0x82; /* Primary no-fault */
target-sparc/cpu.c:    env->psret = 0;
target-sparc/cpu.c:    env->psrs = 1;
target-sparc/cpu.c:    env->psrps = 1;
target-sparc/cpu.c:    env->pstate = PS_PRIV|PS_RED|PS_PEF|PS_AG;
target-sparc/cpu.c:    env->hpstate = cpu_has_hypervisor(env) ? HS_PRIV : 0;
target-sparc/cpu.c:    env->tl = env->maxtl;
target-sparc/cpu.c:    env->lsu = 0;
target-sparc/cpu.c:    env->mmuregs[0] &= ~(MMU_E | MMU_NF);
target-sparc/cpu.c:    env->mmuregs[0] |= env->def->mmu_bm;
target-sparc/cpu.c:    env->pc = 0;
target-sparc/cpu.c:    env->npc = env->pc + 4;
target-sparc/cpu.c:    env->cache_control = 0;
target-sparc/cpu.c:    env->def = g_new0(sparc_def_t, 1);
target-sparc/cpu.c:    memcpy(env->def, def, sizeof(*def));
target-sparc/cpu.c:    env->version = def->iu_version;
target-sparc/cpu.c:    env->fsr = def->fpu_version;
target-sparc/cpu.c:    env->nwindows = def->nwindows;
target-sparc/cpu.c:    env->mmuregs[0] |= def->mmu_version;
target-sparc/cpu.c:    env->mxccregs[7] |= def->mxcc_version;
target-sparc/cpu.c:    env->mmu_version = def->mmu_version;
target-sparc/cpu.c:    env->maxtl = def->maxtl;
target-sparc/cpu.c:    env->version |= def->maxtl << 8;
target-sparc/cpu.c:    env->version |= def->nwindows - 1;
target-sparc/cpu.c:    env->mxccregs[7] = ((cpu + 8) & 0xf) << 24;
target-sparc/cpu.c:    cpu_fprintf(f, "pc: " TARGET_FMT_lx "  npc: " TARGET_FMT_lx "\n", env->pc,
target-sparc/cpu.c:                env->npc);
target-sparc/cpu.c:        cpu_fprintf(f, " " TARGET_FMT_lx, env->gregs[i]);
target-sparc/cpu.c:            cpu_fprintf(f, TARGET_FMT_lx " ", env->regwptr[i + x * 8]);
target-sparc/cpu.c:        cpu_fprintf(f, " %016" PRIx64, env->fpr[i].ll);
target-sparc/cpu.c:    cpu_fprintf(f, "pstate: %08x ccr: %02x (icc: ", env->pstate,
target-sparc/cpu.c:    cpu_fprintf(f, ") asi: %02x tl: %d pil: %x\n", env->asi, env->tl,
target-sparc/cpu.c:                env->psrpil);
target-sparc/cpu.c:                env->cansave, env->canrestore, env->otherwin, env->wstate,
target-sparc/cpu.c:                env->cleanwin, env->nwindows - 1 - env->cwp);
target-sparc/cpu.c:                TARGET_FMT_lx "\n", env->fsr, env->y, env->fprs);
target-sparc/cpu.c:    cpu_fprintf(f, " SPE: %c%c%c) wim: %08x\n", env->psrs ? 'S' : '-',
target-sparc/cpu.c:                env->psrps ? 'P' : '-', env->psret ? 'E' : '-',
target-sparc/cpu.c:                env->wim);
target-sparc/cpu.c:                env->fsr, env->y);
target-sparc/cpu.c:    if ((env->def->features & CPU_FEATURE_FLOAT)) {
target-sparc/cpu.c:        env->def->features |= CPU_FEATURE_FLOAT128;
target-sparc/cpu.c:    g_free(env->def);
target-sparc/cc_helper.c:    return env->psr & PSR_ICC;
target-sparc/cc_helper.c:    return env->psr & PSR_CARRY;
target-sparc/cc_helper.c:    return env->xcc & PSR_ICC;
target-sparc/cc_helper.c:    return env->xcc & PSR_CARRY;
target-sparc/cc_helper.c:    env->psr = new_psr;
target-sparc/cc_helper.c:    env->xcc = new_psr;
linux-user/s390x/target_cpu.h:        env->regs[15] = newsp;
linux-user/s390x/target_cpu.h:    env->regs[2] = 0;
linux-user/s390x/target_cpu.h:    env->aregs[0] = newtls >> 32;
linux-user/s390x/target_cpu.h:    env->aregs[1] = newtls & 0xffffffffULL;
linux-user/vm86.c:    target_v86->regs.eax = tswap32(env->regs[R_EAX]);
linux-user/vm86.c:    target_v86->regs.ebx = tswap32(env->regs[R_EBX]);
linux-user/vm86.c:    target_v86->regs.ecx = tswap32(env->regs[R_ECX]);
linux-user/vm86.c:    target_v86->regs.edx = tswap32(env->regs[R_EDX]);
linux-user/vm86.c:    target_v86->regs.esi = tswap32(env->regs[R_ESI]);
linux-user/vm86.c:    target_v86->regs.edi = tswap32(env->regs[R_EDI]);
linux-user/vm86.c:    target_v86->regs.ebp = tswap32(env->regs[R_EBP]);
linux-user/vm86.c:    target_v86->regs.esp = tswap32(env->regs[R_ESP]);
linux-user/vm86.c:    target_v86->regs.eip = tswap32(env->eip);
linux-user/vm86.c:    target_v86->regs.cs = tswap16(env->segs[R_CS].selector);
linux-user/vm86.c:    target_v86->regs.ss = tswap16(env->segs[R_SS].selector);
linux-user/vm86.c:    target_v86->regs.ds = tswap16(env->segs[R_DS].selector);
linux-user/vm86.c:    target_v86->regs.es = tswap16(env->segs[R_ES].selector);
linux-user/vm86.c:    target_v86->regs.fs = tswap16(env->segs[R_FS].selector);
linux-user/vm86.c:    target_v86->regs.gs = tswap16(env->segs[R_GS].selector);
linux-user/vm86.c:    set_flags(env->eflags, ts->v86flags, VIF_MASK | ts->v86mask);
linux-user/vm86.c:    target_v86->regs.eflags = tswap32(env->eflags);
linux-user/vm86.c:             env->eflags, env->segs[R_CS].selector, env->eip);
linux-user/vm86.c:    env->regs[R_EAX] = ts->vm86_saved_regs.eax;
linux-user/vm86.c:    env->regs[R_EBX] = ts->vm86_saved_regs.ebx;
linux-user/vm86.c:    env->regs[R_ECX] = ts->vm86_saved_regs.ecx;
linux-user/vm86.c:    env->regs[R_EDX] = ts->vm86_saved_regs.edx;
linux-user/vm86.c:    env->regs[R_ESI] = ts->vm86_saved_regs.esi;
linux-user/vm86.c:    env->regs[R_EDI] = ts->vm86_saved_regs.edi;
linux-user/vm86.c:    env->regs[R_EBP] = ts->vm86_saved_regs.ebp;
linux-user/vm86.c:    env->regs[R_ESP] = ts->vm86_saved_regs.esp;
linux-user/vm86.c:    env->eflags = ts->vm86_saved_regs.eflags;
linux-user/vm86.c:    env->eip = ts->vm86_saved_regs.eip;
linux-user/vm86.c:    env->regs[R_EAX] = retval;
linux-user/vm86.c:    env->eflags &= ~TF_MASK;
linux-user/vm86.c:    env->eflags &= ~AC_MASK;
linux-user/vm86.c:    set_flags(env->eflags, eflags, SAFE_MASK);
linux-user/vm86.c:    set_flags(env->eflags, flags, SAFE_MASK);
linux-user/vm86.c:    flags = env->eflags & RETURN_MASK;
linux-user/vm86.c:    if (env->segs[R_CS].selector == TARGET_BIOSSEG)
linux-user/vm86.c:    if (intno == 0x21 && is_revectored((env->regs[R_EAX] >> 8) & 0xff,
linux-user/vm86.c:    ssp = env->segs[R_SS].selector << 4;
linux-user/vm86.c:    sp = env->regs[R_ESP] & 0xffff;
linux-user/vm86.c:    vm_putw(ssp, sp - 4, env->segs[R_CS].selector);
linux-user/vm86.c:    vm_putw(ssp, sp - 6, env->eip);
linux-user/vm86.c:    ADD16(env->regs[R_ESP], -6);
linux-user/vm86.c:    env->eip = segoffs & 0xffff;
linux-user/vm86.c:    csp = env->segs[R_CS].selector << 4;
linux-user/vm86.c:    ip = env->eip & 0xffff;
linux-user/vm86.c:    ssp = env->segs[R_SS].selector << 4;
linux-user/vm86.c:    sp = env->regs[R_ESP] & 0xffff;
linux-user/vm86.c:             env->segs[R_CS].selector, env->eip);
linux-user/vm86.c:            ADD16(env->regs[R_ESP], -4);
linux-user/vm86.c:            ADD16(env->regs[R_ESP], -2);
linux-user/vm86.c:        env->eip = ip;
linux-user/vm86.c:            ADD16(env->regs[R_ESP], 4);
linux-user/vm86.c:            ADD16(env->regs[R_ESP], 2);
linux-user/vm86.c:        env->eip = ip;
linux-user/vm86.c:        env->eip = ip;
linux-user/vm86.c:            ADD16(env->regs[R_ESP], 12);
linux-user/vm86.c:            ADD16(env->regs[R_ESP], 6);
linux-user/vm86.c:        env->eip = newip;
linux-user/vm86.c:        env->eip = ip;
linux-user/vm86.c:        env->eip = ip;
linux-user/vm86.c:    ts->vm86_saved_regs.ebx = env->regs[R_EBX];
linux-user/vm86.c:    ts->vm86_saved_regs.ecx = env->regs[R_ECX];
linux-user/vm86.c:    ts->vm86_saved_regs.edx = env->regs[R_EDX];
linux-user/vm86.c:    ts->vm86_saved_regs.esi = env->regs[R_ESI];
linux-user/vm86.c:    ts->vm86_saved_regs.edi = env->regs[R_EDI];
linux-user/vm86.c:    ts->vm86_saved_regs.ebp = env->regs[R_EBP];
linux-user/vm86.c:    ts->vm86_saved_regs.esp = env->regs[R_ESP];
linux-user/vm86.c:    ts->vm86_saved_regs.eflags = env->eflags;
linux-user/vm86.c:    ts->vm86_saved_regs.eip  = env->eip;
linux-user/vm86.c:    ts->vm86_saved_regs.cs = env->segs[R_CS].selector;
linux-user/vm86.c:    ts->vm86_saved_regs.ss = env->segs[R_SS].selector;
linux-user/vm86.c:    ts->vm86_saved_regs.ds = env->segs[R_DS].selector;
linux-user/vm86.c:    ts->vm86_saved_regs.es = env->segs[R_ES].selector;
linux-user/vm86.c:    ts->vm86_saved_regs.fs = env->segs[R_FS].selector;
linux-user/vm86.c:    ts->vm86_saved_regs.gs = env->segs[R_GS].selector;
linux-user/vm86.c:    env->eflags = (env->eflags & ~SAFE_MASK) |
linux-user/vm86.c:    env->regs[R_EBX] = tswap32(target_v86->regs.ebx);
linux-user/vm86.c:    env->regs[R_ECX] = tswap32(target_v86->regs.ecx);
linux-user/vm86.c:    env->regs[R_EDX] = tswap32(target_v86->regs.edx);
linux-user/vm86.c:    env->regs[R_ESI] = tswap32(target_v86->regs.esi);
linux-user/vm86.c:    env->regs[R_EDI] = tswap32(target_v86->regs.edi);
linux-user/vm86.c:    env->regs[R_EBP] = tswap32(target_v86->regs.ebp);
linux-user/vm86.c:    env->regs[R_ESP] = tswap32(target_v86->regs.esp);
linux-user/vm86.c:    env->eip = tswap32(target_v86->regs.eip);
linux-user/vm86.c:             env->segs[R_CS].selector, env->eip);
linux-user/microblaze/target_cpu.h:        env->regs[R_SP] = newsp;
linux-user/microblaze/target_cpu.h:    env->regs[3] = 0;
linux-user/microblaze/target_cpu.h:    env->regs[21] = newtls;
linux-user/i386/target_cpu.h:        env->regs[R_ESP] = newsp;
linux-user/i386/target_cpu.h:    env->regs[R_EAX] = 0;
linux-user/i386/target_cpu.h:    cpu_x86_load_seg(env, R_GS, env->segs[R_GS].selector);
linux-user/elfload.c:    (*regs)[0] = env->regs[15];
linux-user/elfload.c:    (*regs)[1] = env->regs[14];
linux-user/elfload.c:    (*regs)[2] = env->regs[13];
linux-user/elfload.c:    (*regs)[3] = env->regs[12];
linux-user/elfload.c:    (*regs)[4] = env->regs[R_EBP];
linux-user/elfload.c:    (*regs)[5] = env->regs[R_EBX];
linux-user/elfload.c:    (*regs)[6] = env->regs[11];
linux-user/elfload.c:    (*regs)[7] = env->regs[10];
linux-user/elfload.c:    (*regs)[8] = env->regs[9];
linux-user/elfload.c:    (*regs)[9] = env->regs[8];
linux-user/elfload.c:    (*regs)[10] = env->regs[R_EAX];
linux-user/elfload.c:    (*regs)[11] = env->regs[R_ECX];
linux-user/elfload.c:    (*regs)[12] = env->regs[R_EDX];
linux-user/elfload.c:    (*regs)[13] = env->regs[R_ESI];
linux-user/elfload.c:    (*regs)[14] = env->regs[R_EDI];
linux-user/elfload.c:    (*regs)[15] = env->regs[R_EAX]; /* XXX */
linux-user/elfload.c:    (*regs)[16] = env->eip;
linux-user/elfload.c:    (*regs)[17] = env->segs[R_CS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[18] = env->eflags;
linux-user/elfload.c:    (*regs)[19] = env->regs[R_ESP];
linux-user/elfload.c:    (*regs)[20] = env->segs[R_SS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[21] = env->segs[R_FS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[22] = env->segs[R_GS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[23] = env->segs[R_DS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[24] = env->segs[R_ES].selector & 0xffff;
linux-user/elfload.c:    (*regs)[25] = env->segs[R_FS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[26] = env->segs[R_GS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[0] = env->regs[R_EBX];
linux-user/elfload.c:    (*regs)[1] = env->regs[R_ECX];
linux-user/elfload.c:    (*regs)[2] = env->regs[R_EDX];
linux-user/elfload.c:    (*regs)[3] = env->regs[R_ESI];
linux-user/elfload.c:    (*regs)[4] = env->regs[R_EDI];
linux-user/elfload.c:    (*regs)[5] = env->regs[R_EBP];
linux-user/elfload.c:    (*regs)[6] = env->regs[R_EAX];
linux-user/elfload.c:    (*regs)[7] = env->segs[R_DS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[8] = env->segs[R_ES].selector & 0xffff;
linux-user/elfload.c:    (*regs)[9] = env->segs[R_FS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[10] = env->segs[R_GS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[11] = env->regs[R_EAX]; /* XXX */
linux-user/elfload.c:    (*regs)[12] = env->eip;
linux-user/elfload.c:    (*regs)[13] = env->segs[R_CS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[14] = env->eflags;
linux-user/elfload.c:    (*regs)[15] = env->regs[R_ESP];
linux-user/elfload.c:    (*regs)[16] = env->segs[R_SS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[0] = tswapreg(env->regs[0]);
linux-user/elfload.c:    (*regs)[1] = tswapreg(env->regs[1]);
linux-user/elfload.c:    (*regs)[2] = tswapreg(env->regs[2]);
linux-user/elfload.c:    (*regs)[3] = tswapreg(env->regs[3]);
linux-user/elfload.c:    (*regs)[4] = tswapreg(env->regs[4]);
linux-user/elfload.c:    (*regs)[5] = tswapreg(env->regs[5]);
linux-user/elfload.c:    (*regs)[6] = tswapreg(env->regs[6]);
linux-user/elfload.c:    (*regs)[7] = tswapreg(env->regs[7]);
linux-user/elfload.c:    (*regs)[8] = tswapreg(env->regs[8]);
linux-user/elfload.c:    (*regs)[9] = tswapreg(env->regs[9]);
linux-user/elfload.c:    (*regs)[10] = tswapreg(env->regs[10]);
linux-user/elfload.c:    (*regs)[11] = tswapreg(env->regs[11]);
linux-user/elfload.c:    (*regs)[12] = tswapreg(env->regs[12]);
linux-user/elfload.c:    (*regs)[13] = tswapreg(env->regs[13]);
linux-user/elfload.c:    (*regs)[14] = tswapreg(env->regs[14]);
linux-user/elfload.c:    (*regs)[15] = tswapreg(env->regs[15]);
linux-user/elfload.c:    (*regs)[17] = tswapreg(env->regs[0]); /* XXX */
linux-user/elfload.c:        (*regs)[i] = tswapreg(env->xregs[i]);
linux-user/elfload.c:    (*regs)[32] = tswapreg(env->pc);
linux-user/elfload.c:    (*regs)[0] = env->regs[0];
linux-user/elfload.c:    (*regs)[1] = env->regs[1];
linux-user/elfload.c:    (*regs)[2] = env->regs[2];
linux-user/elfload.c:    (*regs)[3] = env->regs[3];
linux-user/elfload.c:    (*regs)[4] = env->regs[4];
linux-user/elfload.c:    (*regs)[5] = env->regs[5];
linux-user/elfload.c:    (*regs)[6] = env->regs[6];
linux-user/elfload.c:    (*regs)[7] = env->regs[7];
linux-user/elfload.c:    (*regs)[8] = env->regs[8];
linux-user/elfload.c:    (*regs)[9] = env->regs[9];
linux-user/elfload.c:    (*regs)[10] = env->regs[10];
linux-user/elfload.c:    (*regs)[11] = env->regs[11];
linux-user/elfload.c:    (*regs)[12] = env->regs[12];
linux-user/elfload.c:    (*regs)[13] = env->regs[13];
linux-user/elfload.c:    (*regs)[14] = env->regs[14];
linux-user/elfload.c:    (*regs)[15] = env->regs[15];
linux-user/elfload.c:    (*regs)[16] = env->regs[16];
linux-user/elfload.c:    (*regs)[17] = env->regs[17];
linux-user/elfload.c:    (*regs)[18] = env->regs[18];
linux-user/elfload.c:    (*regs)[19] = env->regs[19];
linux-user/elfload.c:    (*regs)[20] = env->regs[20];
linux-user/elfload.c:    (*regs)[21] = env->regs[21];
linux-user/elfload.c:    (*regs)[22] = env->regs[22];
linux-user/elfload.c:    (*regs)[23] = env->regs[23];
linux-user/elfload.c:    (*regs)[24] = env->regs[24];
linux-user/elfload.c:    (*regs)[25] = env->regs[25];
linux-user/elfload.c:    (*regs)[26] = env->regs[26];
linux-user/elfload.c:    (*regs)[27] = env->regs[27];
linux-user/elfload.c:    (*regs)[28] = env->regs[28];
linux-user/elfload.c:    (*regs)[29] = env->regs[29];
linux-user/elfload.c:    (*regs)[30] = env->regs[30];
linux-user/elfload.c:    (*regs)[31] = env->regs[31];
linux-user/elfload.c:    (*regs)[33] = env->regs[0]; /* XXX */
linux-user/elfload.c:    for (i = 0; i < ARRAY_SIZE(env->gpr); i++) {
linux-user/elfload.c:        (*regs)[i] = tswapreg(env->gpr[i]);
linux-user/elfload.c:    (*regs)[32] = tswapreg(env->nip);
linux-user/elfload.c:    (*regs)[33] = tswapreg(env->msr);
linux-user/elfload.c:    (*regs)[35] = tswapreg(env->ctr);
linux-user/elfload.c:    (*regs)[36] = tswapreg(env->lr);
linux-user/elfload.c:    (*regs)[37] = tswapreg(env->xer);
linux-user/elfload.c:    for (i = 0; i < ARRAY_SIZE(env->crf); i++) {
linux-user/elfload.c:        ccr |= env->crf[i] << (32 - ((i + 1) * 4));
linux-user/elfload.c:    for (i = 1; i < ARRAY_SIZE(env->active_tc.gpr); i++) {
linux-user/elfload.c:        (*regs)[TARGET_EF_R0 + i] = tswapreg(env->active_tc.gpr[i]);
linux-user/elfload.c:    (*regs)[TARGET_EF_LO] = tswapreg(env->active_tc.LO[0]);
linux-user/elfload.c:    (*regs)[TARGET_EF_HI] = tswapreg(env->active_tc.HI[0]);
linux-user/elfload.c:    (*regs)[TARGET_EF_CP0_EPC] = tswapreg(env->active_tc.PC);
linux-user/elfload.c:    (*regs)[TARGET_EF_CP0_BADVADDR] = tswapreg(env->CP0_BadVAddr);
linux-user/elfload.c:    (*regs)[TARGET_EF_CP0_STATUS] = tswapreg(env->CP0_Status);
linux-user/elfload.c:    (*regs)[TARGET_EF_CP0_CAUSE] = tswapreg(env->CP0_Cause);
linux-user/elfload.c:        (*regs)[pos++] = tswapreg(env->regs[i]);
linux-user/elfload.c:        (*regs)[pos++] = tswapreg(env->sregs[i]);
linux-user/elfload.c:        (*regs)[i] = tswapreg(env->gpr[i]);
linux-user/elfload.c:    (*regs)[32] = tswapreg(env->pc);
linux-user/elfload.c:    (*regs)[33] = tswapreg(env->sr);
linux-user/elfload.c:        (*regs[i]) = tswapreg(env->gregs[i]);
linux-user/elfload.c:    (*regs)[TARGET_REG_PC] = tswapreg(env->pc);
linux-user/elfload.c:    (*regs)[TARGET_REG_PR] = tswapreg(env->pr);
linux-user/elfload.c:    (*regs)[TARGET_REG_SR] = tswapreg(env->sr);
linux-user/elfload.c:    (*regs)[TARGET_REG_GBR] = tswapreg(env->gbr);
linux-user/elfload.c:    (*regs)[TARGET_REG_MACH] = tswapreg(env->mach);
linux-user/elfload.c:    (*regs)[TARGET_REG_MACL] = tswapreg(env->macl);
linux-user/elfload.c:    (*regs)[0] = tswapreg(env->dregs[1]);
linux-user/elfload.c:    (*regs)[1] = tswapreg(env->dregs[2]);
linux-user/elfload.c:    (*regs)[2] = tswapreg(env->dregs[3]);
linux-user/elfload.c:    (*regs)[3] = tswapreg(env->dregs[4]);
linux-user/elfload.c:    (*regs)[4] = tswapreg(env->dregs[5]);
linux-user/elfload.c:    (*regs)[5] = tswapreg(env->dregs[6]);
linux-user/elfload.c:    (*regs)[6] = tswapreg(env->dregs[7]);
linux-user/elfload.c:    (*regs)[7] = tswapreg(env->aregs[0]);
linux-user/elfload.c:    (*regs)[8] = tswapreg(env->aregs[1]);
linux-user/elfload.c:    (*regs)[9] = tswapreg(env->aregs[2]);
linux-user/elfload.c:    (*regs)[10] = tswapreg(env->aregs[3]);
linux-user/elfload.c:    (*regs)[11] = tswapreg(env->aregs[4]);
linux-user/elfload.c:    (*regs)[12] = tswapreg(env->aregs[5]);
linux-user/elfload.c:    (*regs)[13] = tswapreg(env->aregs[6]);
linux-user/elfload.c:    (*regs)[14] = tswapreg(env->dregs[0]);
linux-user/elfload.c:    (*regs)[15] = tswapreg(env->aregs[7]);
linux-user/elfload.c:    (*regs)[16] = tswapreg(env->dregs[0]); /* FIXME: orig_d0 */
linux-user/elfload.c:    (*regs)[17] = tswapreg(env->sr);
linux-user/elfload.c:    (*regs)[18] = tswapreg(env->pc);
linux-user/m68k-sim.c:  env->dregs[0] = code;
linux-user/m68k-sim.c:      env->dregs[1] = errno;
linux-user/m68k-sim.c:      env->dregs[1] = 0;
linux-user/m68k-sim.c:    args = (uint32_t *)(unsigned long)(env->aregs[7] + 4);
linux-user/aarch64/target_cpu.h:        env->xregs[31] = newsp;
linux-user/aarch64/target_cpu.h:    env->xregs[0] = 0;
linux-user/aarch64/target_cpu.h:    env->cp15.tpidr_el0 = newtls;
linux-user/flatload.c: * create_flat_tables() parses the env- and arg-strings in new user
linux-user/unicore32/target_cpu.h:        env->regs[29] = newsp;
linux-user/unicore32/target_cpu.h:    env->regs[0] = 0;
linux-user/unicore32/target_cpu.h:    env->regs[16] = newtls;
linux-user/alpha/target_cpu.h:        env->ir[IR_SP] = newsp;
linux-user/alpha/target_cpu.h:    env->ir[IR_V0] = 0;
linux-user/alpha/target_cpu.h:    env->ir[IR_A3] = 0;
linux-user/alpha/target_cpu.h:    env->unique = newtls;
linux-user/signal.c:    __put_user(env->segs[R_GS].selector, (unsigned int *)&sc->gs);
linux-user/signal.c:    __put_user(env->segs[R_FS].selector, (unsigned int *)&sc->fs);
linux-user/signal.c:    __put_user(env->segs[R_ES].selector, (unsigned int *)&sc->es);
linux-user/signal.c:    __put_user(env->segs[R_DS].selector, (unsigned int *)&sc->ds);
linux-user/signal.c:    __put_user(env->regs[R_EDI], &sc->edi);
linux-user/signal.c:    __put_user(env->regs[R_ESI], &sc->esi);
linux-user/signal.c:    __put_user(env->regs[R_EBP], &sc->ebp);
linux-user/signal.c:    __put_user(env->regs[R_ESP], &sc->esp);
linux-user/signal.c:    __put_user(env->regs[R_EBX], &sc->ebx);
linux-user/signal.c:    __put_user(env->regs[R_EDX], &sc->edx);
linux-user/signal.c:    __put_user(env->regs[R_ECX], &sc->ecx);
linux-user/signal.c:    __put_user(env->regs[R_EAX], &sc->eax);
linux-user/signal.c:    __put_user(env->error_code, &sc->err);
linux-user/signal.c:    __put_user(env->eip, &sc->eip);
linux-user/signal.c:    __put_user(env->segs[R_CS].selector, (unsigned int *)&sc->cs);
linux-user/signal.c:    __put_user(env->eflags, &sc->eflags);
linux-user/signal.c:    __put_user(env->regs[R_ESP], &sc->esp_at_signal);
linux-user/signal.c:    __put_user(env->segs[R_SS].selector, (unsigned int *)&sc->ss);
linux-user/signal.c:    __put_user(env->cr[2], &sc->cr2);
linux-user/signal.c:	esp = env->regs[R_ESP];
linux-user/signal.c:        if ((env->segs[R_SS].selector & 0xffff) != __USER_DS &&
linux-user/signal.c:	env->regs[R_ESP] = frame_addr;
linux-user/signal.c:	env->eip = ka->_sa_handler;
linux-user/signal.c:	env->eflags &= ~TF_MASK;
linux-user/signal.c:	env->regs[R_ESP] = frame_addr;
linux-user/signal.c:	env->eip = ka->_sa_handler;
linux-user/signal.c:	env->eflags &= ~TF_MASK;
linux-user/signal.c:        env->regs[R_EDI] = tswapl(sc->edi);
linux-user/signal.c:        env->regs[R_ESI] = tswapl(sc->esi);
linux-user/signal.c:        env->regs[R_EBP] = tswapl(sc->ebp);
linux-user/signal.c:        env->regs[R_ESP] = tswapl(sc->esp);
linux-user/signal.c:        env->regs[R_EBX] = tswapl(sc->ebx);
linux-user/signal.c:        env->regs[R_EDX] = tswapl(sc->edx);
linux-user/signal.c:        env->regs[R_ECX] = tswapl(sc->ecx);
linux-user/signal.c:        env->eip = tswapl(sc->eip);
linux-user/signal.c:        env->eflags = (env->eflags & ~0x40DD5) | (tmpflags & 0x40DD5);
linux-user/signal.c:    abi_ulong frame_addr = env->regs[R_ESP] - 8;
linux-user/signal.c:        frame_addr = env->regs[R_ESP] - 4;
linux-user/signal.c:    __put_user(env->xregs[29], &sf->fp);
linux-user/signal.c:    __put_user(env->xregs[30], &sf->lr);
linux-user/signal.c:        __put_user(env->xregs[i], &sf->uc.tuc_mcontext.regs[i]);
linux-user/signal.c:    __put_user(env->xregs[31], &sf->uc.tuc_mcontext.sp);
linux-user/signal.c:    __put_user(env->pc, &sf->uc.tuc_mcontext.pc);
linux-user/signal.c:    __put_user(env->exception.vaddress, &sf->uc.tuc_mcontext.fault_address);
linux-user/signal.c:        __put_user(env->vfp.regs[i * 2], &aux->fpsimd.vregs[i * 2 + 1]);
linux-user/signal.c:        __put_user(env->vfp.regs[i * 2 + 1], &aux->fpsimd.vregs[i * 2]);
linux-user/signal.c:        __put_user(env->vfp.regs[i * 2], &aux->fpsimd.vregs[i * 2]);
linux-user/signal.c:        __put_user(env->vfp.regs[i * 2 + 1], &aux->fpsimd.vregs[i * 2 + 1]);
linux-user/signal.c:        __get_user(env->xregs[i], &sf->uc.tuc_mcontext.regs[i]);
linux-user/signal.c:    __get_user(env->xregs[31], &sf->uc.tuc_mcontext.sp);
linux-user/signal.c:    __get_user(env->pc, &sf->uc.tuc_mcontext.pc);
linux-user/signal.c:        __get_user(env->vfp.regs[i * 2], &aux->fpsimd.vregs[i * 2 + 1]);
linux-user/signal.c:        __get_user(env->vfp.regs[i * 2 + 1], &aux->fpsimd.vregs[i * 2]);
linux-user/signal.c:        __get_user(env->vfp.regs[i * 2], &aux->fpsimd.vregs[i * 2]);
linux-user/signal.c:        __get_user(env->vfp.regs[i * 2 + 1], &aux->fpsimd.vregs[i * 2 + 1]);
linux-user/signal.c:    sp = env->xregs[31];
linux-user/signal.c:    __put_user(sas_ss_flags(env->xregs[31]),
linux-user/signal.c:    env->xregs[0] = usig;
linux-user/signal.c:    env->xregs[31] = frame_addr;
linux-user/signal.c:    env->xregs[29] = env->xregs[31] + offsetof(struct target_rt_sigframe, fp);
linux-user/signal.c:    env->pc = ka->_sa_handler;
linux-user/signal.c:    env->xregs[30] = return_addr;
linux-user/signal.c:        env->xregs[1] = frame_addr + offsetof(struct target_rt_sigframe, info);
linux-user/signal.c:        env->xregs[2] = frame_addr + offsetof(struct target_rt_sigframe, uc);
linux-user/signal.c:    abi_ulong frame_addr = env->xregs[31];
linux-user/signal.c:    return env->xregs[0];
linux-user/signal.c:	__put_user(env->regs[0], &sc->arm_r0);
linux-user/signal.c:	__put_user(env->regs[1], &sc->arm_r1);
linux-user/signal.c:	__put_user(env->regs[2], &sc->arm_r2);
linux-user/signal.c:	__put_user(env->regs[3], &sc->arm_r3);
linux-user/signal.c:	__put_user(env->regs[4], &sc->arm_r4);
linux-user/signal.c:	__put_user(env->regs[5], &sc->arm_r5);
linux-user/signal.c:	__put_user(env->regs[6], &sc->arm_r6);
linux-user/signal.c:	__put_user(env->regs[7], &sc->arm_r7);
linux-user/signal.c:	__put_user(env->regs[8], &sc->arm_r8);
linux-user/signal.c:	__put_user(env->regs[9], &sc->arm_r9);
linux-user/signal.c:	__put_user(env->regs[10], &sc->arm_r10);
linux-user/signal.c:	__put_user(env->regs[11], &sc->arm_fp);
linux-user/signal.c:	__put_user(env->regs[12], &sc->arm_ip);
linux-user/signal.c:	__put_user(env->regs[13], &sc->arm_sp);
linux-user/signal.c:	__put_user(env->regs[14], &sc->arm_lr);
linux-user/signal.c:	__put_user(env->regs[15], &sc->arm_pc);
linux-user/signal.c:	env->regs[0] = usig;
linux-user/signal.c:	env->regs[13] = frame_addr;
linux-user/signal.c:	env->regs[14] = retcode;
linux-user/signal.c:	env->regs[15] = handler & (thumb ? ~1 : ~3);
linux-user/signal.c:        __put_user(float64_val(env->vfp.regs[i]), &vfpframe->ufp.fpregs[i]);
linux-user/signal.c:    __put_user(env->vfp.xregs[ARM_VFP_FPEXC], &vfpframe->ufp_exc.fpexc);
linux-user/signal.c:    __put_user(env->vfp.xregs[ARM_VFP_FPINST], &vfpframe->ufp_exc.fpinst);
linux-user/signal.c:    __put_user(env->vfp.xregs[ARM_VFP_FPINST2], &vfpframe->ufp_exc.fpinst2);
linux-user/signal.c:        __put_user(env->iwmmxt.regs[i], &iwmmxtframe->regs[i]);
linux-user/signal.c:    __put_user(env->vfp.xregs[ARM_IWMMXT_wCSSF], &iwmmxtframe->wcssf);
linux-user/signal.c:    __put_user(env->vfp.xregs[ARM_IWMMXT_wCASF], &iwmmxtframe->wcssf);
linux-user/signal.c:    __put_user(env->vfp.xregs[ARM_IWMMXT_wCGR0], &iwmmxtframe->wcgr0);
linux-user/signal.c:    __put_user(env->vfp.xregs[ARM_IWMMXT_wCGR1], &iwmmxtframe->wcgr1);
linux-user/signal.c:    __put_user(env->vfp.xregs[ARM_IWMMXT_wCGR2], &iwmmxtframe->wcgr2);
linux-user/signal.c:    __put_user(env->vfp.xregs[ARM_IWMMXT_wCGR3], &iwmmxtframe->wcgr3);
linux-user/signal.c:        env->regs[1] = info_addr;
linux-user/signal.c:        env->regs[2] = uc_addr;
linux-user/signal.c:        env->regs[1] = info_addr;
linux-user/signal.c:        env->regs[2] = uc_addr;
linux-user/signal.c:    __get_user(env->regs[0], &sc->arm_r0);
linux-user/signal.c:    __get_user(env->regs[1], &sc->arm_r1);
linux-user/signal.c:    __get_user(env->regs[2], &sc->arm_r2);
linux-user/signal.c:    __get_user(env->regs[3], &sc->arm_r3);
linux-user/signal.c:    __get_user(env->regs[4], &sc->arm_r4);
linux-user/signal.c:    __get_user(env->regs[5], &sc->arm_r5);
linux-user/signal.c:    __get_user(env->regs[6], &sc->arm_r6);
linux-user/signal.c:    __get_user(env->regs[7], &sc->arm_r7);
linux-user/signal.c:    __get_user(env->regs[8], &sc->arm_r8);
linux-user/signal.c:    __get_user(env->regs[9], &sc->arm_r9);
linux-user/signal.c:    __get_user(env->regs[10], &sc->arm_r10);
linux-user/signal.c:    __get_user(env->regs[11], &sc->arm_fp);
linux-user/signal.c:    __get_user(env->regs[12], &sc->arm_ip);
linux-user/signal.c:    __get_user(env->regs[13], &sc->arm_sp);
linux-user/signal.c:    __get_user(env->regs[14], &sc->arm_lr);
linux-user/signal.c:    __get_user(env->regs[15], &sc->arm_pc);
linux-user/signal.c:        frame_addr = env->regs[13];
linux-user/signal.c:        return env->regs[0];
linux-user/signal.c:        __get_user(float64_val(env->vfp.regs[i]), &vfpframe->ufp.fpregs[i]);
linux-user/signal.c:    env->vfp.xregs[ARM_VFP_FPEXC] = fpexc;
linux-user/signal.c:    __get_user(env->vfp.xregs[ARM_VFP_FPINST], &vfpframe->ufp_exc.fpinst);
linux-user/signal.c:    __get_user(env->vfp.xregs[ARM_VFP_FPINST2], &vfpframe->ufp_exc.fpinst2);
linux-user/signal.c:        __get_user(env->iwmmxt.regs[i], &iwmmxtframe->regs[i]);
linux-user/signal.c:    __get_user(env->vfp.xregs[ARM_IWMMXT_wCSSF], &iwmmxtframe->wcssf);
linux-user/signal.c:    __get_user(env->vfp.xregs[ARM_IWMMXT_wCASF], &iwmmxtframe->wcssf);
linux-user/signal.c:    __get_user(env->vfp.xregs[ARM_IWMMXT_wCGR0], &iwmmxtframe->wcgr0);
linux-user/signal.c:    __get_user(env->vfp.xregs[ARM_IWMMXT_wCGR1], &iwmmxtframe->wcgr1);
linux-user/signal.c:    __get_user(env->vfp.xregs[ARM_IWMMXT_wCGR2], &iwmmxtframe->wcgr2);
linux-user/signal.c:    __get_user(env->vfp.xregs[ARM_IWMMXT_wCGR3], &iwmmxtframe->wcgr3);
linux-user/signal.c:        frame_addr = env->regs[13];
linux-user/signal.c:	return env->regs[0];
linux-user/signal.c:        frame_addr = env->regs[13];
linux-user/signal.c:	return env->regs[0];
linux-user/signal.c:        frame_addr = env->regs[13];
linux-user/signal.c:	return env->regs[0];
linux-user/signal.c:	sp = env->regwptr[UREG_FP];
linux-user/signal.c:    __put_user(env->psr, &si->si_regs.psr);
linux-user/signal.c:    __put_user(env->pc, &si->si_regs.pc);
linux-user/signal.c:    __put_user(env->npc, &si->si_regs.npc);
linux-user/signal.c:    __put_user(env->y, &si->si_regs.y);
linux-user/signal.c:        __put_user(env->gregs[i], &si->si_regs.u_regs[i]);
linux-user/signal.c:        __put_user(env->regwptr[UREG_I0 + i], &si->si_regs.u_regs[i+8]);
linux-user/signal.c:    __put_user(env->regwptr[UREG_SP], &sc->sigc_sp);
linux-user/signal.c:    __put_user(env->pc, &sc->sigc_pc);
linux-user/signal.c:    __put_user(env->npc, &sc->sigc_npc);
linux-user/signal.c:    __put_user(env->psr, &sc->sigc_psr);
linux-user/signal.c:    __put_user(env->gregs[1], &sc->sigc_g1);
linux-user/signal.c:    __put_user(env->regwptr[UREG_O0], &sc->sigc_o0);
linux-user/signal.c:	//fprintf(stderr, "sf: %x pc %x fp %x sp %x\n", sf, env->pc, env->regwptr[UREG_FP], env->regwptr[UREG_SP]);
linux-user/signal.c:        __put_user(env->regwptr[i + UREG_L0], &sf->ss.locals[i]);
linux-user/signal.c:        __put_user(env->regwptr[i + UREG_I0], &sf->ss.ins[i]);
linux-user/signal.c:	env->regwptr[UREG_FP] = sf_addr;
linux-user/signal.c:	env->regwptr[UREG_I0] = sig;
linux-user/signal.c:	env->regwptr[UREG_I1] = sf_addr + 
linux-user/signal.c:	env->regwptr[UREG_I2] = sf_addr + 
linux-user/signal.c:	env->pc = ka->_sa_handler;
linux-user/signal.c:	env->npc = (env->pc + 4);
linux-user/signal.c:		env->regwptr[UREG_I7] = ka->sa_restorer;
linux-user/signal.c:		env->regwptr[UREG_I7] = sf_addr + 
linux-user/signal.c:        sf_addr = env->regwptr[UREG_FP];
linux-user/signal.c:	fprintf(stderr, "sf: %x pc %x fp %x sp %x\n", sf, env->pc, env->regwptr[UREG_FP], env->regwptr[UREG_SP]);
linux-user/signal.c:        env->psr = (up_psr & (PSR_ICC /* | PSR_EF */))
linux-user/signal.c:                  | (env->psr & ~(PSR_ICC /* | PSR_EF */));
linux-user/signal.c:	env->pc = pc;
linux-user/signal.c:	env->npc = npc;
linux-user/signal.c:        __get_user(env->y, &sf->info.si_regs.y);
linux-user/signal.c:		__get_user(env->gregs[i], &sf->info.si_regs.u_regs[i]);
linux-user/signal.c:		__get_user(env->regwptr[i + UREG_I0], &sf->info.si_regs.u_regs[i+8]);
linux-user/signal.c:        return env->regwptr[0];
linux-user/signal.c:    ucp_addr = env->regwptr[UREG_I0];
linux-user/signal.c:    if (env->regwptr[UREG_I1]) {
linux-user/signal.c:    env->pc = pc;
linux-user/signal.c:    env->npc = npc;
linux-user/signal.c:    __get_user(env->y, &((*grp)[MC_Y]));
linux-user/signal.c:    env->asi = (tstate >> 24) & 0xff;
linux-user/signal.c:    __get_user(env->gregs[1], (&(*grp)[MC_G1]));
linux-user/signal.c:    __get_user(env->gregs[2], (&(*grp)[MC_G2]));
linux-user/signal.c:    __get_user(env->gregs[3], (&(*grp)[MC_G3]));
linux-user/signal.c:    __get_user(env->gregs[4], (&(*grp)[MC_G4]));
linux-user/signal.c:    __get_user(env->gregs[5], (&(*grp)[MC_G5]));
linux-user/signal.c:    __get_user(env->gregs[6], (&(*grp)[MC_G6]));
linux-user/signal.c:    __get_user(env->gregs[7], (&(*grp)[MC_G7]));
linux-user/signal.c:    __get_user(env->regwptr[UREG_I0], (&(*grp)[MC_O0]));
linux-user/signal.c:    __get_user(env->regwptr[UREG_I1], (&(*grp)[MC_O1]));
linux-user/signal.c:    __get_user(env->regwptr[UREG_I2], (&(*grp)[MC_O2]));
linux-user/signal.c:    __get_user(env->regwptr[UREG_I3], (&(*grp)[MC_O3]));
linux-user/signal.c:    __get_user(env->regwptr[UREG_I4], (&(*grp)[MC_O4]));
linux-user/signal.c:    __get_user(env->regwptr[UREG_I5], (&(*grp)[MC_O5]));
linux-user/signal.c:    __get_user(env->regwptr[UREG_I6], (&(*grp)[MC_O6]));
linux-user/signal.c:    __get_user(env->regwptr[UREG_I7], (&(*grp)[MC_O7]));
linux-user/signal.c:    w_addr = TARGET_STACK_BIAS+env->regwptr[UREG_I6];
linux-user/signal.c:    __get_user(env->fprs, &(ucp->tuc_mcontext.mc_fpregs.mcfpu_fprs));
linux-user/signal.c:                __get_user(env->fpr[i/2].l.lower, src);
linux-user/signal.c:                __get_user(env->fpr[i/2].l.upper, src);
linux-user/signal.c:    __get_user(env->fsr,
linux-user/signal.c:    __get_user(env->gsr,
linux-user/signal.c:    ucp_addr = env->regwptr[UREG_I0];
linux-user/signal.c:    env->pc = env->npc;
linux-user/signal.c:    env->npc += 4;
linux-user/signal.c:    //    __put_user(env->tstate, &((*grp)[MC_TSTATE]));
linux-user/signal.c:    __put_user(env->pc, &((*grp)[MC_PC]));
linux-user/signal.c:    __put_user(env->npc, &((*grp)[MC_NPC]));
linux-user/signal.c:    __put_user(env->y, &((*grp)[MC_Y]));
linux-user/signal.c:    __put_user(env->gregs[1], &((*grp)[MC_G1]));
linux-user/signal.c:    __put_user(env->gregs[2], &((*grp)[MC_G2]));
linux-user/signal.c:    __put_user(env->gregs[3], &((*grp)[MC_G3]));
linux-user/signal.c:    __put_user(env->gregs[4], &((*grp)[MC_G4]));
linux-user/signal.c:    __put_user(env->gregs[5], &((*grp)[MC_G5]));
linux-user/signal.c:    __put_user(env->gregs[6], &((*grp)[MC_G6]));
linux-user/signal.c:    __put_user(env->gregs[7], &((*grp)[MC_G7]));
linux-user/signal.c:    __put_user(env->regwptr[UREG_I0], &((*grp)[MC_O0]));
linux-user/signal.c:    __put_user(env->regwptr[UREG_I1], &((*grp)[MC_O1]));
linux-user/signal.c:    __put_user(env->regwptr[UREG_I2], &((*grp)[MC_O2]));
linux-user/signal.c:    __put_user(env->regwptr[UREG_I3], &((*grp)[MC_O3]));
linux-user/signal.c:    __put_user(env->regwptr[UREG_I4], &((*grp)[MC_O4]));
linux-user/signal.c:    __put_user(env->regwptr[UREG_I5], &((*grp)[MC_O5]));
linux-user/signal.c:    __put_user(env->regwptr[UREG_I6], &((*grp)[MC_O6]));
linux-user/signal.c:    __put_user(env->regwptr[UREG_I7], &((*grp)[MC_O7]));
linux-user/signal.c:    w_addr = TARGET_STACK_BIAS+env->regwptr[UREG_I6];
linux-user/signal.c:                __put_user(env->fpr[i/2].l.lower, dst);
linux-user/signal.c:                __put_user(env->fpr[i/2].l.upper, dst);
linux-user/signal.c:    __put_user(env->fsr, &(mcp->mc_fpregs.mcfpu_fsr));
linux-user/signal.c:    __put_user(env->gsr, &(mcp->mc_fpregs.mcfpu_gsr));
linux-user/signal.c:    __put_user(env->fprs, &(mcp->mc_fpregs.mcfpu_fprs));
linux-user/signal.c:    if (env->insn_flags & (ASE_MIPS16 | ASE_MICROMIPS)) {
linux-user/signal.c:        env->hflags &= ~MIPS_HFLAG_M16;
linux-user/signal.c:        env->hflags |= (env->active_tc.PC & 1) << MIPS_HFLAG_M16_SHIFT;
linux-user/signal.c:        env->active_tc.PC &= ~(target_ulong) 1;
linux-user/signal.c:    env->active_tc.gpr[ 4] = sig;
linux-user/signal.c:    env->active_tc.gpr[ 5] = frame_addr
linux-user/signal.c:    env->active_tc.gpr[ 6] = frame_addr
linux-user/signal.c:    env->active_tc.gpr[29] = frame_addr;
linux-user/signal.c:    env->active_tc.gpr[31] = frame_addr
linux-user/signal.c:    env->active_tc.PC = env->active_tc.gpr[25] = ka->_sa_handler;
linux-user/signal.c:    frame_addr = env->active_tc.gpr[29];
linux-user/signal.c:    env->active_tc.PC = env->CP0_EPC;
linux-user/signal.c:    env->CP0_EPC = 0;
linux-user/signal.c:    __put_user(env->regs[0], &sc->regs.r0);
linux-user/signal.c:    __put_user(env->regs[1], &sc->regs.r1);
linux-user/signal.c:    __put_user(env->regs[2], &sc->regs.r2);
linux-user/signal.c:    __put_user(env->regs[3], &sc->regs.r3);
linux-user/signal.c:    __put_user(env->regs[4], &sc->regs.r4);
linux-user/signal.c:    __put_user(env->regs[5], &sc->regs.r5);
linux-user/signal.c:    __put_user(env->regs[6], &sc->regs.r6);
linux-user/signal.c:    __put_user(env->regs[7], &sc->regs.r7);
linux-user/signal.c:    __put_user(env->regs[8], &sc->regs.r8);
linux-user/signal.c:    __put_user(env->regs[9], &sc->regs.r9);
linux-user/signal.c:    __put_user(env->regs[10], &sc->regs.r10);
linux-user/signal.c:    __put_user(env->regs[11], &sc->regs.r11);
linux-user/signal.c:    __put_user(env->regs[12], &sc->regs.r12);
linux-user/signal.c:    __put_user(env->regs[13], &sc->regs.r13);
linux-user/signal.c:    __put_user(env->regs[14], &sc->regs.r14);
linux-user/signal.c:    __put_user(env->regs[15], &sc->regs.r15);
linux-user/signal.c:    __put_user(env->regs[16], &sc->regs.r16);
linux-user/signal.c:    __put_user(env->regs[17], &sc->regs.r17);
linux-user/signal.c:    __put_user(env->regs[18], &sc->regs.r18);
linux-user/signal.c:    __put_user(env->regs[19], &sc->regs.r19);
linux-user/signal.c:    __put_user(env->regs[20], &sc->regs.r20);
linux-user/signal.c:    __put_user(env->regs[21], &sc->regs.r21);
linux-user/signal.c:    __put_user(env->regs[22], &sc->regs.r22);
linux-user/signal.c:    __put_user(env->regs[23], &sc->regs.r23);
linux-user/signal.c:    __put_user(env->regs[24], &sc->regs.r24);
linux-user/signal.c:    __put_user(env->regs[25], &sc->regs.r25);
linux-user/signal.c:    __put_user(env->regs[26], &sc->regs.r26);
linux-user/signal.c:    __put_user(env->regs[27], &sc->regs.r27);
linux-user/signal.c:    __put_user(env->regs[28], &sc->regs.r28);
linux-user/signal.c:    __put_user(env->regs[29], &sc->regs.r29);
linux-user/signal.c:    __put_user(env->regs[30], &sc->regs.r30);
linux-user/signal.c:    __put_user(env->regs[31], &sc->regs.r31);
linux-user/signal.c:    __put_user(env->sregs[SR_PC], &sc->regs.pc);
linux-user/signal.c:    __get_user(env->regs[0], &sc->regs.r0);
linux-user/signal.c:    __get_user(env->regs[1], &sc->regs.r1);
linux-user/signal.c:    __get_user(env->regs[2], &sc->regs.r2);
linux-user/signal.c:    __get_user(env->regs[3], &sc->regs.r3);
linux-user/signal.c:    __get_user(env->regs[4], &sc->regs.r4);
linux-user/signal.c:    __get_user(env->regs[5], &sc->regs.r5);
linux-user/signal.c:    __get_user(env->regs[6], &sc->regs.r6);
linux-user/signal.c:    __get_user(env->regs[7], &sc->regs.r7);
linux-user/signal.c:    __get_user(env->regs[8], &sc->regs.r8);
linux-user/signal.c:    __get_user(env->regs[9], &sc->regs.r9);
linux-user/signal.c:    __get_user(env->regs[10], &sc->regs.r10);
linux-user/signal.c:    __get_user(env->regs[11], &sc->regs.r11);
linux-user/signal.c:    __get_user(env->regs[12], &sc->regs.r12);
linux-user/signal.c:    __get_user(env->regs[13], &sc->regs.r13);
linux-user/signal.c:    __get_user(env->regs[14], &sc->regs.r14);
linux-user/signal.c:    __get_user(env->regs[15], &sc->regs.r15);
linux-user/signal.c:    __get_user(env->regs[16], &sc->regs.r16);
linux-user/signal.c:    __get_user(env->regs[17], &sc->regs.r17);
linux-user/signal.c:    __get_user(env->regs[18], &sc->regs.r18);
linux-user/signal.c:    __get_user(env->regs[19], &sc->regs.r19);
linux-user/signal.c:    __get_user(env->regs[20], &sc->regs.r20);
linux-user/signal.c:    __get_user(env->regs[21], &sc->regs.r21);
linux-user/signal.c:    __get_user(env->regs[22], &sc->regs.r22);
linux-user/signal.c:    __get_user(env->regs[23], &sc->regs.r23);
linux-user/signal.c:    __get_user(env->regs[24], &sc->regs.r24);
linux-user/signal.c:    __get_user(env->regs[25], &sc->regs.r25);
linux-user/signal.c:    __get_user(env->regs[26], &sc->regs.r26);
linux-user/signal.c:    __get_user(env->regs[27], &sc->regs.r27);
linux-user/signal.c:    __get_user(env->regs[28], &sc->regs.r28);
linux-user/signal.c:    __get_user(env->regs[29], &sc->regs.r29);
linux-user/signal.c:    __get_user(env->regs[30], &sc->regs.r30);
linux-user/signal.c:    __get_user(env->regs[31], &sc->regs.r31);
linux-user/signal.c:    __get_user(env->sregs[SR_PC], &sc->regs.pc);
linux-user/signal.c:    abi_ulong sp = env->regs[1];
linux-user/signal.c:        env->regs[15] = ((unsigned long)ka->sa_restorer)-8;
linux-user/signal.c:        env->regs[15] = ((unsigned long)frame->tramp) - 8;
linux-user/signal.c:    env->regs[1] = frame_addr;
linux-user/signal.c:    env->regs[5] = sig; /* Arg 0: signum */
linux-user/signal.c:    env->regs[6] = 0;
linux-user/signal.c:    env->regs[7] = frame_addr += offsetof(typeof(*frame), uc);
linux-user/signal.c:    env->sregs[SR_PC] = (unsigned long)ka->_sa_handler;
linux-user/signal.c:    frame_addr = env->regs[R_SP];
linux-user/signal.c:    env->regs[14] = env->sregs[SR_PC];
linux-user/signal.c:    return env->regs[10];
linux-user/signal.c:	__put_user(env->regs[0], &sc->regs.r0);
linux-user/signal.c:	__put_user(env->regs[1], &sc->regs.r1);
linux-user/signal.c:	__put_user(env->regs[2], &sc->regs.r2);
linux-user/signal.c:	__put_user(env->regs[3], &sc->regs.r3);
linux-user/signal.c:	__put_user(env->regs[4], &sc->regs.r4);
linux-user/signal.c:	__put_user(env->regs[5], &sc->regs.r5);
linux-user/signal.c:	__put_user(env->regs[6], &sc->regs.r6);
linux-user/signal.c:	__put_user(env->regs[7], &sc->regs.r7);
linux-user/signal.c:	__put_user(env->regs[8], &sc->regs.r8);
linux-user/signal.c:	__put_user(env->regs[9], &sc->regs.r9);
linux-user/signal.c:	__put_user(env->regs[10], &sc->regs.r10);
linux-user/signal.c:	__put_user(env->regs[11], &sc->regs.r11);
linux-user/signal.c:	__put_user(env->regs[12], &sc->regs.r12);
linux-user/signal.c:	__put_user(env->regs[13], &sc->regs.r13);
linux-user/signal.c:	__put_user(env->regs[14], &sc->usp);
linux-user/signal.c:	__put_user(env->regs[15], &sc->regs.acr);
linux-user/signal.c:	__put_user(env->pregs[PR_MOF], &sc->regs.mof);
linux-user/signal.c:	__put_user(env->pregs[PR_SRP], &sc->regs.srp);
linux-user/signal.c:	__put_user(env->pc, &sc->regs.erp);
linux-user/signal.c:	__get_user(env->regs[0], &sc->regs.r0);
linux-user/signal.c:	__get_user(env->regs[1], &sc->regs.r1);
linux-user/signal.c:	__get_user(env->regs[2], &sc->regs.r2);
linux-user/signal.c:	__get_user(env->regs[3], &sc->regs.r3);
linux-user/signal.c:	__get_user(env->regs[4], &sc->regs.r4);
linux-user/signal.c:	__get_user(env->regs[5], &sc->regs.r5);
linux-user/signal.c:	__get_user(env->regs[6], &sc->regs.r6);
linux-user/signal.c:	__get_user(env->regs[7], &sc->regs.r7);
linux-user/signal.c:	__get_user(env->regs[8], &sc->regs.r8);
linux-user/signal.c:	__get_user(env->regs[9], &sc->regs.r9);
linux-user/signal.c:	__get_user(env->regs[10], &sc->regs.r10);
linux-user/signal.c:	__get_user(env->regs[11], &sc->regs.r11);
linux-user/signal.c:	__get_user(env->regs[12], &sc->regs.r12);
linux-user/signal.c:	__get_user(env->regs[13], &sc->regs.r13);
linux-user/signal.c:	__get_user(env->regs[14], &sc->usp);
linux-user/signal.c:	__get_user(env->regs[15], &sc->regs.acr);
linux-user/signal.c:	__get_user(env->pregs[PR_MOF], &sc->regs.mof);
linux-user/signal.c:	__get_user(env->pregs[PR_SRP], &sc->regs.srp);
linux-user/signal.c:	__get_user(env->pc, &sc->regs.erp);
linux-user/signal.c:	sp = (env->regs[R_SP] & ~3);
linux-user/signal.c:	env->regs[R_SP] = frame_addr;
linux-user/signal.c:	env->regs[10] = sig;
linux-user/signal.c:	env->pc = (unsigned long) ka->_sa_handler;
linux-user/signal.c:	env->pregs[PR_SRP] = frame_addr + offsetof(typeof(*frame), retcode);
linux-user/signal.c:	frame_addr = env->regs[R_SP];
linux-user/signal.c:	return env->regs[10];
linux-user/signal.c:    __put_user(sas_ss_flags(env->gpr[1]), &frame->uc.tuc_stack.ss_flags);
linux-user/signal.c:    env->pc = (unsigned long)ka->_sa_handler; /* what we enter NOW */
linux-user/signal.c:    env->gpr[9] = (unsigned long)return_ip;     /* what we enter LATER */
linux-user/signal.c:    env->gpr[3] = (unsigned long)sig;           /* arg 1: signo */
linux-user/signal.c:    env->gpr[4] = (unsigned long)&frame->info;  /* arg 2: (siginfo_t*) */
linux-user/signal.c:    env->gpr[5] = (unsigned long)&frame->uc;    /* arg 3: ucontext */
linux-user/signal.c:    env->gpr[1] = (unsigned long)frame;
linux-user/signal.c:    sp = env->regs[15];
linux-user/signal.c:    __put_user(env->psw.mask, &sregs->regs.psw.mask);
linux-user/signal.c:    __put_user(env->psw.addr, &sregs->regs.psw.addr);
linux-user/signal.c:        __put_user(env->regs[i], &sregs->regs.gprs[i]);
linux-user/signal.c:        __put_user(env->aregs[i], &sregs->regs.acrs[i]);
linux-user/signal.c:        __put_user(env->fregs[i].ll, &sregs->fpregs.fprs[i]);
linux-user/signal.c:            env->regs[14] = (unsigned long)
linux-user/signal.c:            env->regs[14] = (unsigned long)
linux-user/signal.c:    __put_user(env->regs[15], (abi_ulong *) frame);
linux-user/signal.c:    env->regs[15] = frame_addr;
linux-user/signal.c:    env->psw.addr = (target_ulong) ka->_sa_handler | PSW_ADDR_AMODE;
linux-user/signal.c:    env->regs[2] = sig; //map_signal(sig);
linux-user/signal.c:    env->regs[3] = frame_addr += offsetof(typeof(*frame), sc);
linux-user/signal.c:    env->regs[4] = 0; // FIXME: no clue... current->thread.trap_no;
linux-user/signal.c:    env->regs[5] = 0; // FIXME: no clue... current->thread.prot_addr;
linux-user/signal.c:    __put_user(env->regs[2], (int *) &frame->signo);
linux-user/signal.c:        env->regs[14] = (unsigned long) ka->sa_restorer | PSW_ADDR_AMODE;
linux-user/signal.c:        env->regs[14] = (unsigned long) frame->retcode | PSW_ADDR_AMODE;
linux-user/signal.c:    __put_user(env->regs[15], (abi_ulong *) frame);
linux-user/signal.c:    env->regs[15] = frame_addr;
linux-user/signal.c:    env->psw.addr = (target_ulong) ka->_sa_handler | PSW_ADDR_AMODE;
linux-user/signal.c:    env->regs[2] = sig; //map_signal(sig);
linux-user/signal.c:    env->regs[3] = frame_addr + offsetof(typeof(*frame), info);
linux-user/signal.c:    env->regs[4] = frame_addr + offsetof(typeof(*frame), uc);
linux-user/signal.c:        __get_user(env->regs[i], &sc->regs.gprs[i]);
linux-user/signal.c:    __get_user(env->psw.mask, &sc->regs.psw.mask);
linux-user/signal.c:    qemu_log("%s: sc->regs.psw.addr 0x%llx env->psw.addr 0x%llx\n",
linux-user/signal.c:             (unsigned long long)env->psw.addr);
linux-user/signal.c:    __get_user(env->psw.addr, &sc->regs.psw.addr);
linux-user/signal.c:        __get_user(env->aregs[i], &sc->regs.acrs[i]);
linux-user/signal.c:        __get_user(env->fregs[i].ll, &sc->fpregs.fprs[i]);
linux-user/signal.c:    abi_ulong frame_addr = env->regs[15];
linux-user/signal.c:    return env->regs[2];
linux-user/signal.c:    abi_ulong frame_addr = env->regs[15];
linux-user/signal.c:    return env->regs[2];
linux-user/signal.c:    oldsp = env->gpr[1];
linux-user/signal.c:    target_ulong msr = env->msr;
linux-user/signal.c:    for (i = 0; i < ARRAY_SIZE(env->gpr); i++) {
linux-user/signal.c:       __put_user(env->gpr[i], &frame->mc_gregs[i]);
linux-user/signal.c:    __put_user(env->nip, &frame->mc_gregs[TARGET_PT_NIP]);
linux-user/signal.c:    __put_user(env->ctr, &frame->mc_gregs[TARGET_PT_CTR]);
linux-user/signal.c:    __put_user(env->lr, &frame->mc_gregs[TARGET_PT_LNK]);
linux-user/signal.c:    __put_user(env->xer, &frame->mc_gregs[TARGET_PT_XER]);
linux-user/signal.c:    for (i = 0; i < ARRAY_SIZE(env->crf); i++) {
linux-user/signal.c:        ccr |= env->crf[i] << (32 - ((i + 1) * 4));
linux-user/signal.c:    if (env->insns_flags & PPC_ALTIVEC) {
linux-user/signal.c:        for (i = 0; i < ARRAY_SIZE(env->avr); i++) {
linux-user/signal.c:            ppc_avr_t *avr = &env->avr[i];
linux-user/signal.c:        __put_user((uint32_t)env->spr[SPR_VRSAVE],
linux-user/signal.c:    if (env->insns_flags & PPC_FLOAT) {
linux-user/signal.c:        for (i = 0; i < ARRAY_SIZE(env->fpr); i++) {
linux-user/signal.c:            __put_user(env->fpr[i], &frame->mc_fregs[i]);
linux-user/signal.c:        __put_user((uint64_t) env->fpscr, &frame->mc_fregs[32]);
linux-user/signal.c:    if (env->insns_flags & PPC_SPE) {
linux-user/signal.c:        for (i = 0; i < ARRAY_SIZE(env->gpr); i++) {
linux-user/signal.c:            __put_user(env->gpr[i] >> 32, &frame->mc_vregs.spe[i]);
linux-user/signal.c:        for (i = 0; i < ARRAY_SIZE(env->gprh); i++) {
linux-user/signal.c:            __put_user(env->gprh[i], &frame->mc_vregs.spe[i]);
linux-user/signal.c:        __put_user(env->spe_fscr, &frame->mc_vregs.spe[32]);
linux-user/signal.c:        save_r2 = env->gpr[2];
linux-user/signal.c:    for (i = 0; i < ARRAY_SIZE(env->gpr); i++) {
linux-user/signal.c:        __get_user(env->gpr[i], &frame->mc_gregs[i]);
linux-user/signal.c:    __get_user(env->nip, &frame->mc_gregs[TARGET_PT_NIP]);
linux-user/signal.c:    __get_user(env->ctr, &frame->mc_gregs[TARGET_PT_CTR]);
linux-user/signal.c:    __get_user(env->lr, &frame->mc_gregs[TARGET_PT_LNK]);
linux-user/signal.c:    __get_user(env->xer, &frame->mc_gregs[TARGET_PT_XER]);
linux-user/signal.c:    for (i = 0; i < ARRAY_SIZE(env->crf); i++) {
linux-user/signal.c:        env->crf[i] = (ccr >> (32 - ((i + 1) * 4))) & 0xf;
linux-user/signal.c:        env->gpr[2] = save_r2;
linux-user/signal.c:        env->msr = (env->msr & ~MSR_LE) | (msr & MSR_LE);
linux-user/signal.c:    if (env->insns_flags & PPC_ALTIVEC) {
linux-user/signal.c:        for (i = 0; i < ARRAY_SIZE(env->avr); i++) {
linux-user/signal.c:            ppc_avr_t *avr = &env->avr[i];
linux-user/signal.c:        __get_user(env->spr[SPR_VRSAVE],
linux-user/signal.c:    if (env->insns_flags & PPC_FLOAT) {
linux-user/signal.c:        for (i = 0; i < ARRAY_SIZE(env->fpr); i++) {
linux-user/signal.c:            __get_user(env->fpr[i], &frame->mc_fregs[i]);
linux-user/signal.c:        env->fpscr = (uint32_t) fpscr;
linux-user/signal.c:    if (env->insns_flags & PPC_SPE) {
linux-user/signal.c:        for (i = 0; i < ARRAY_SIZE(env->gpr); i++) {
linux-user/signal.c:            env->gpr[i] = ((uint64_t)hi << 32) | ((uint32_t) env->gpr[i]);
linux-user/signal.c:        for (i = 0; i < ARRAY_SIZE(env->gprh); i++) {
linux-user/signal.c:            __get_user(env->gprh[i], &frame->mc_vregs.spe[i]);
linux-user/signal.c:        __get_user(env->spe_fscr, &frame->mc_vregs.spe[32]);
linux-user/signal.c:    env->lr = (target_ulong) h2g(frame->mctx.tramp);
linux-user/signal.c:    env->fpscr = 0;
linux-user/signal.c:    err |= put_user(env->gpr[1], newsp, target_ulong);
linux-user/signal.c:    env->gpr[1] = newsp;
linux-user/signal.c:    env->gpr[3] = signal;
linux-user/signal.c:    env->gpr[4] = frame_addr + offsetof(struct target_sigframe, sctx);
linux-user/signal.c:    env->nip = (target_ulong) ka->_sa_handler;
linux-user/signal.c:    env->msr &= ~MSR_LE;
linux-user/signal.c:    __put_user(sas_ss_flags(env->gpr[1]),
linux-user/signal.c:    env->lr = (target_ulong) h2g(frame->tramp);
linux-user/signal.c:    env->fpscr = 0;
linux-user/signal.c:    __put_user(env->gpr[1], (target_ulong *)(uintptr_t) newsp);
linux-user/signal.c:    env->gpr[1] = newsp;
linux-user/signal.c:    env->gpr[3] = (target_ulong) signal;
linux-user/signal.c:    env->gpr[4] = (target_ulong) h2g(&rt_sf->info);
linux-user/signal.c:    env->gpr[5] = (target_ulong) h2g(&rt_sf->uc);
linux-user/signal.c:    env->gpr[6] = (target_ulong) h2g(rt_sf);
linux-user/signal.c:    env->nip = (target_ulong) ka->_sa_handler;
linux-user/signal.c:    env->msr &= ~MSR_LE;
linux-user/signal.c:    sc_addr = env->gpr[1] + SIGNAL_FRAMESIZE;
linux-user/signal.c:    rt_sf_addr = env->gpr[1] + SIGNAL_FRAMESIZE + 16;
linux-user/signal.c:                   0, env->gpr[1]);
linux-user/signal.c:    __put_user(env->aregs[7], &sc->sc_usp);
linux-user/signal.c:    __put_user(env->dregs[0], &sc->sc_d0);
linux-user/signal.c:    __put_user(env->dregs[1], &sc->sc_d1);
linux-user/signal.c:    __put_user(env->aregs[0], &sc->sc_a0);
linux-user/signal.c:    __put_user(env->aregs[1], &sc->sc_a1);
linux-user/signal.c:    __put_user(env->sr, &sc->sc_sr);
linux-user/signal.c:    __put_user(env->pc, &sc->sc_pc);
linux-user/signal.c:    __get_user(env->aregs[7], &sc->sc_usp);
linux-user/signal.c:    __get_user(env->dregs[1], &sc->sc_d1);
linux-user/signal.c:    __get_user(env->aregs[0], &sc->sc_a0);
linux-user/signal.c:    __get_user(env->aregs[1], &sc->sc_a1);
linux-user/signal.c:    __get_user(env->pc, &sc->sc_pc);
linux-user/signal.c:    env->sr = (env->sr & 0xff00) | (temp & 0xff);
linux-user/signal.c:    env->aregs[7] = frame_addr;
linux-user/signal.c:    env->pc = ka->_sa_handler;
linux-user/signal.c:    __put_user(env->dregs[0], &gregs[0]);
linux-user/signal.c:    __put_user(env->dregs[1], &gregs[1]);
linux-user/signal.c:    __put_user(env->dregs[2], &gregs[2]);
linux-user/signal.c:    __put_user(env->dregs[3], &gregs[3]);
linux-user/signal.c:    __put_user(env->dregs[4], &gregs[4]);
linux-user/signal.c:    __put_user(env->dregs[5], &gregs[5]);
linux-user/signal.c:    __put_user(env->dregs[6], &gregs[6]);
linux-user/signal.c:    __put_user(env->dregs[7], &gregs[7]);
linux-user/signal.c:    __put_user(env->aregs[0], &gregs[8]);
linux-user/signal.c:    __put_user(env->aregs[1], &gregs[9]);
linux-user/signal.c:    __put_user(env->aregs[2], &gregs[10]);
linux-user/signal.c:    __put_user(env->aregs[3], &gregs[11]);
linux-user/signal.c:    __put_user(env->aregs[4], &gregs[12]);
linux-user/signal.c:    __put_user(env->aregs[5], &gregs[13]);
linux-user/signal.c:    __put_user(env->aregs[6], &gregs[14]);
linux-user/signal.c:    __put_user(env->aregs[7], &gregs[15]);
linux-user/signal.c:    __put_user(env->pc, &gregs[16]);
linux-user/signal.c:    __put_user(env->sr, &gregs[17]);
linux-user/signal.c:    __get_user(env->dregs[0], &gregs[0]);
linux-user/signal.c:    __get_user(env->dregs[1], &gregs[1]);
linux-user/signal.c:    __get_user(env->dregs[2], &gregs[2]);
linux-user/signal.c:    __get_user(env->dregs[3], &gregs[3]);
linux-user/signal.c:    __get_user(env->dregs[4], &gregs[4]);
linux-user/signal.c:    __get_user(env->dregs[5], &gregs[5]);
linux-user/signal.c:    __get_user(env->dregs[6], &gregs[6]);
linux-user/signal.c:    __get_user(env->dregs[7], &gregs[7]);
linux-user/signal.c:    __get_user(env->aregs[0], &gregs[8]);
linux-user/signal.c:    __get_user(env->aregs[1], &gregs[9]);
linux-user/signal.c:    __get_user(env->aregs[2], &gregs[10]);
linux-user/signal.c:    __get_user(env->aregs[3], &gregs[11]);
linux-user/signal.c:    __get_user(env->aregs[4], &gregs[12]);
linux-user/signal.c:    __get_user(env->aregs[5], &gregs[13]);
linux-user/signal.c:    __get_user(env->aregs[6], &gregs[14]);
linux-user/signal.c:    __get_user(env->aregs[7], &gregs[15]);
linux-user/signal.c:    __get_user(env->pc, &gregs[16]);
linux-user/signal.c:    env->sr = (env->sr & 0xff00) | (temp & 0xff);
linux-user/signal.c:    *pd0 = env->dregs[0];
linux-user/signal.c:    __put_user(sas_ss_flags(env->aregs[7]),
linux-user/signal.c:    env->aregs[7] = frame_addr;
linux-user/signal.c:    env->pc = ka->_sa_handler;
linux-user/signal.c:    abi_ulong frame_addr = env->aregs[7] - 4;
linux-user/signal.c:    abi_ulong frame_addr = env->aregs[7] - 4;
linux-user/signal.c:    __put_user(env->pc, &sc->sc_pc);
linux-user/signal.c:        __put_user(env->ir[i], &sc->sc_regs[i]);
linux-user/signal.c:        __put_user(env->fir[i], &sc->sc_fpregs[i]);
linux-user/signal.c:    __get_user(env->pc, &sc->sc_pc);
linux-user/signal.c:        __get_user(env->ir[i], &sc->sc_regs[i]);
linux-user/signal.c:        __get_user(env->fir[i], &sc->sc_fpregs[i]);
linux-user/signal.c:    abi_ulong sp = env->ir[IR_SP];
linux-user/signal.c:    env->ir[IR_RA] = r26;
linux-user/signal.c:    env->ir[IR_PV] = env->pc = ka->_sa_handler;
linux-user/signal.c:    env->ir[IR_A0] = sig;
linux-user/signal.c:    env->ir[IR_A1] = 0;
linux-user/signal.c:    env->ir[IR_A2] = frame_addr + offsetof(struct target_sigframe, sc);
linux-user/signal.c:    env->ir[IR_SP] = frame_addr;
linux-user/signal.c:    __put_user(sas_ss_flags(env->ir[IR_SP]),
linux-user/signal.c:    env->ir[IR_RA] = r26;
linux-user/signal.c:    env->ir[IR_PV] = env->pc = ka->_sa_handler;
linux-user/signal.c:    env->ir[IR_A0] = sig;
linux-user/signal.c:    env->ir[IR_A1] = frame_addr + offsetof(struct target_rt_sigframe, info);
linux-user/signal.c:    env->ir[IR_A2] = frame_addr + offsetof(struct target_rt_sigframe, uc);
linux-user/signal.c:    env->ir[IR_SP] = frame_addr;
linux-user/signal.c:    abi_ulong sc_addr = env->ir[IR_A0];
linux-user/signal.c:    return env->ir[IR_V0];
linux-user/signal.c:    abi_ulong frame_addr = env->ir[IR_A0];
linux-user/signal.c:                       0, env->ir[IR_SP]) == -EFAULT) {
linux-user/signal.c:    return env->ir[IR_V0];
linux-user/signal.c:            if (env->eflags & VM_MASK)
linux-user/ppc/target_cpu.h:        env->gpr[1] = newsp;
linux-user/ppc/target_cpu.h:    env->gpr[3] = 0;
linux-user/ppc/target_cpu.h:    env->gpr[13] = newtls;
linux-user/ppc/target_cpu.h:    env->gpr[2] = newtls;
linux-user/sh4/target_cpu.h:        env->gregs[15] = newsp;
linux-user/sh4/target_cpu.h:    env->gregs[0] = 0;
linux-user/sh4/target_cpu.h:  env->gbr = newtls;
linux-user/cris/target_cpu.h:        env->regs[14] = newsp;
linux-user/cris/target_cpu.h:    env->regs[10] = 0;
linux-user/cris/target_cpu.h:    env->pregs[PR_PID] = (env->pregs[PR_PID] & 0xff) | newtls;
linux-user/sparc/target_cpu.h:        env->regwptr[22] = newsp;
linux-user/sparc/target_cpu.h:    env->regwptr[0] = 0;
linux-user/sparc/target_cpu.h:    env->xcc &= ~PSR_CARRY;
linux-user/sparc/target_cpu.h:    env->psr &= ~PSR_CARRY;
linux-user/sparc/target_cpu.h:    env->gregs[7] = newtls;
linux-user/arm/target_cpu.h:        env->regs[13] = newsp;
linux-user/arm/target_cpu.h:    env->regs[0] = 0;
linux-user/arm/target_cpu.h:    env->cp15.tpidrro_el0 = newtls;
linux-user/m68k/target_cpu.h:        env->aregs[7] = newsp;
linux-user/m68k/target_cpu.h:    env->dregs[0] = 0;
linux-user/main.c:            env->regs[R_EAX] = do_syscall(env,
linux-user/main.c:                                          env->regs[R_EAX],
linux-user/main.c:                                          env->regs[R_EBX],
linux-user/main.c:                                          env->regs[R_ECX],
linux-user/main.c:                                          env->regs[R_EDX],
linux-user/main.c:                                          env->regs[R_ESI],
linux-user/main.c:                                          env->regs[R_EDI],
linux-user/main.c:                                          env->regs[R_EBP],
linux-user/main.c:            env->regs[R_EAX] = do_syscall(env,
linux-user/main.c:                                          env->regs[R_EAX],
linux-user/main.c:                                          env->regs[R_EDI],
linux-user/main.c:                                          env->regs[R_ESI],
linux-user/main.c:                                          env->regs[R_EDX],
linux-user/main.c:                                          env->regs[10],
linux-user/main.c:                                          env->regs[8],
linux-user/main.c:                                          env->regs[9],
linux-user/main.c:            env->eip = env->exception_next_eip;
linux-user/main.c:            if (env->eflags & VM_MASK) {
linux-user/main.c:            if (!(env->error_code & 1))
linux-user/main.c:            info._sifields._sigfault._addr = env->cr[2];
linux-user/main.c:            if (env->eflags & VM_MASK) {
linux-user/main.c:                info._sifields._sigfault._addr = env->eip;
linux-user/main.c:            if (env->eflags & VM_MASK) {
linux-user/main.c:                    info._sifields._sigfault._addr = env->eip;
linux-user/main.c:            if (env->eflags & VM_MASK) {
linux-user/main.c:            info._sifields._sigfault._addr = env->eip;
linux-user/main.c:            pc = env->segs[R_CS].base + env->eip;
linux-user/main.c:    addr = env->regs[2];
linux-user/main.c:    if (get_user_u64(oldval, env->regs[0])) {
linux-user/main.c:        env->exception.vaddress = env->regs[0];
linux-user/main.c:    if (get_user_u64(newval, env->regs[1])) {
linux-user/main.c:        env->exception.vaddress = env->regs[1];
linux-user/main.c:        env->exception.vaddress = addr;
linux-user/main.c:            env->exception.vaddress = addr;
linux-user/main.c:        env->regs[0] = 0;
linux-user/main.c:        env->regs[0] = -1;
linux-user/main.c:    /* XXX: check env->error_code */
linux-user/main.c:    info._sifields._sigfault._addr = env->exception.vaddress;
linux-user/main.c:    switch (env->regs[15]) {
linux-user/main.c:        addr = env->regs[2];
linux-user/main.c:            val = ~env->regs[0];
linux-user/main.c:        if (val == env->regs[0]) {
linux-user/main.c:            val = env->regs[1];
linux-user/main.c:            env->regs[0] = 0;
linux-user/main.c:            env->regs[0] = -1;
linux-user/main.c:        env->regs[0] = env->cp15.tpidrro_el0;
linux-user/main.c:    addr = env->regs[14];
linux-user/main.c:        env->thumb = 1;
linux-user/main.c:    env->regs[15] = addr;
linux-user/main.c:    if (env->exclusive_addr != env->exclusive_test) {
linux-user/main.c:    assert(extract64(env->exclusive_addr, 32, 32) == 0);
linux-user/main.c:    addr = env->exclusive_addr;
linux-user/main.c:    size = env->exclusive_info & 0xf;
linux-user/main.c:        env->exception.vaddress = addr;
linux-user/main.c:            env->exception.vaddress = addr + 4;
linux-user/main.c:    if (val != env->exclusive_val) {
linux-user/main.c:    val = env->regs[(env->exclusive_info >> 8) & 0xf];
linux-user/main.c:        env->exception.vaddress = addr;
linux-user/main.c:        val = env->regs[(env->exclusive_info >> 12) & 0xf];
linux-user/main.c:            env->exception.vaddress = addr + 4;
linux-user/main.c:    env->regs[15] += 4;
linux-user/main.c:    env->regs[(env->exclusive_info >> 4) & 0xf] = rc;
linux-user/main.c:                get_user_code_u32(opcode, env->regs[15], env->bswap_code);
linux-user/main.c:                    info._sifields._sigfault._addr = env->regs[15];
linux-user/main.c:                      info._sifields._sigfault._addr = env->regs[15];
linux-user/main.c:                      env->regs[15] += 4;
linux-user/main.c:                    env->regs[15] += 4;
linux-user/main.c:                env->eabi = 1;
linux-user/main.c:                    if (env->thumb) {
linux-user/main.c:                        get_user_code_u16(insn, env->regs[15], env->bswap_code);
linux-user/main.c:                        env->regs[15] += 2;
linux-user/main.c:                        get_user_code_u32(insn, env->regs[15], env->bswap_code);
linux-user/main.c:                        env->regs[15] += 4;
linux-user/main.c:                    if (env->thumb) {
linux-user/main.c:                        get_user_code_u16(insn, env->regs[15] - 2,
linux-user/main.c:                                          env->bswap_code);
linux-user/main.c:                        get_user_code_u32(insn, env->regs[15] - 4,
linux-user/main.c:                                          env->bswap_code);
linux-user/main.c:                    env->regs[0] = do_arm_semihosting (env);
linux-user/main.c:                } else if (n == 0 || n >= ARM_SYSCALL_BASE || env->thumb) {
linux-user/main.c:                    if (env->thumb || n == 0) {
linux-user/main.c:                        n = env->regs[7];
linux-user/main.c:                        env->eabi = 0;
linux-user/main.c:                            cpu_set_tls(env, env->regs[0]);
linux-user/main.c:                            env->regs[0] = 0;
linux-user/main.c:                            env->regs[15] -= env->thumb ? 2 : 4;
linux-user/main.c:                            env->regs[0] = -TARGET_ENOSYS;
linux-user/main.c:                        env->regs[0] = do_syscall(env,
linux-user/main.c:                                                  env->regs[0],
linux-user/main.c:                                                  env->regs[1],
linux-user/main.c:                                                  env->regs[2],
linux-user/main.c:                                                  env->regs[3],
linux-user/main.c:                                                  env->regs[4],
linux-user/main.c:                                                  env->regs[5],
linux-user/main.c:            addr = env->exception.vaddress;
linux-user/main.c:                /* XXX: check env->error_code */
linux-user/main.c:    size = extract32(env->exclusive_info, 0, 2);
linux-user/main.c:    is_pair = extract32(env->exclusive_info, 2, 1);
linux-user/main.c:    rs = extract32(env->exclusive_info, 4, 5);
linux-user/main.c:    rt = extract32(env->exclusive_info, 9, 5);
linux-user/main.c:    rt2 = extract32(env->exclusive_info, 14, 5);
linux-user/main.c:    addr = env->exclusive_addr;
linux-user/main.c:    if (addr != env->exclusive_test) {
linux-user/main.c:        env->exception.vaddress = addr;
linux-user/main.c:    if (val != env->exclusive_val) {
linux-user/main.c:            env->exception.vaddress = addr + (size == 2 ? 4 : 8);
linux-user/main.c:        if (val != env->exclusive_high) {
linux-user/main.c:    val = rt == 31 ? 0 : env->xregs[rt];
linux-user/main.c:        val = rt2 == 31 ? 0 : env->xregs[rt2];
linux-user/main.c:            env->exception.vaddress = addr + (size == 2 ? 4 : 8);
linux-user/main.c:    env->pc += 4;
linux-user/main.c:        env->xregs[rs] = rc;
linux-user/main.c:    env->exclusive_addr = -1;
linux-user/main.c:            env->xregs[0] = do_syscall(env,
linux-user/main.c:                                       env->xregs[8],
linux-user/main.c:                                       env->xregs[0],
linux-user/main.c:                                       env->xregs[1],
linux-user/main.c:                                       env->xregs[2],
linux-user/main.c:                                       env->xregs[3],
linux-user/main.c:                                       env->xregs[4],
linux-user/main.c:                                       env->xregs[5],
linux-user/main.c:            info._sifields._sigfault._addr = env->pc;
linux-user/main.c:            addr = env->exception.vaddress;
linux-user/main.c:            /* XXX: check env->error_code */
linux-user/main.c:        env->exclusive_addr = -1;
linux-user/main.c:                get_user_u32(insn, env->regs[31] - 4);
linux-user/main.c:                            cpu_set_tls(env, env->regs[0]);
linux-user/main.c:                            env->regs[0] = 0;
linux-user/main.c:                        env->regs[0] = do_syscall(env,
linux-user/main.c:                                                  env->regs[0],
linux-user/main.c:                                                  env->regs[1],
linux-user/main.c:                                                  env->regs[2],
linux-user/main.c:                                                  env->regs[3],
linux-user/main.c:                                                  env->regs[4],
linux-user/main.c:                                                  env->regs[5],
linux-user/main.c:            /* XXX: check env->error_code */
linux-user/main.c:            info._sifields._sigfault._addr = env->cp0.c4_faultaddr;
linux-user/main.c:    index = (index + cwp * 16) % (16 * env->nwindows);
linux-user/main.c:    if (index < 8 && env->cwp == env->nwindows - 1)
linux-user/main.c:        index += 16 * env->nwindows;
linux-user/main.c:    sp_ptr = env->regbase[get_reg_index(env, cwp1, 6)];
linux-user/main.c:        put_user_ual(env->regbase[get_reg_index(env, cwp1, 8 + i)], sp_ptr);
linux-user/main.c:    new_wim = ((env->wim >> 1) | (env->wim << (env->nwindows - 1))) &
linux-user/main.c:        ((1LL << env->nwindows) - 1);
linux-user/main.c:    save_window_offset(env, cpu_cwp_dec(env, env->cwp - 2));
linux-user/main.c:    env->wim = new_wim;
linux-user/main.c:    save_window_offset(env, cpu_cwp_dec(env, env->cwp - 2));
linux-user/main.c:    env->cansave++;
linux-user/main.c:    env->canrestore--;
linux-user/main.c:    new_wim = ((env->wim << 1) | (env->wim >> (env->nwindows - 1))) &
linux-user/main.c:        ((1LL << env->nwindows) - 1);
linux-user/main.c:    cwp1 = cpu_cwp_inc(env, env->cwp + 1);
linux-user/main.c:    sp_ptr = env->regbase[get_reg_index(env, cwp1, 6)];
linux-user/main.c:        get_user_ual(env->regbase[get_reg_index(env, cwp1, 8 + i)], sp_ptr);
linux-user/main.c:    env->canrestore++;
linux-user/main.c:    if (env->cleanwin < env->nwindows - 1)
linux-user/main.c:        env->cleanwin++;
linux-user/main.c:    env->cansave--;
linux-user/main.c:    env->wim = new_wim;
linux-user/main.c:        cwp1 = cpu_cwp_inc(env, env->cwp + offset);
linux-user/main.c:        if (env->wim & (1 << cwp1))
linux-user/main.c:        if (env->canrestore == 0)
linux-user/main.c:        env->cansave++;
linux-user/main.c:        env->canrestore--;
linux-user/main.c:    cwp1 = cpu_cwp_inc(env, env->cwp + 1);
linux-user/main.c:    env->wim = 1 << cwp1;
linux-user/main.c:        if (env->cc_op != CC_OP_FLAGS) {
linux-user/main.c:            ret = do_syscall (env, env->gregs[1],
linux-user/main.c:                              env->regwptr[0], env->regwptr[1],
linux-user/main.c:                              env->regwptr[2], env->regwptr[3],
linux-user/main.c:                              env->regwptr[4], env->regwptr[5],
linux-user/main.c:                env->xcc |= PSR_CARRY;
linux-user/main.c:                env->psr |= PSR_CARRY;
linux-user/main.c:                env->xcc &= ~PSR_CARRY;
linux-user/main.c:                env->psr &= ~PSR_CARRY;
linux-user/main.c:            env->regwptr[0] = ret;
linux-user/main.c:            env->pc = env->npc;
linux-user/main.c:            env->npc = env->npc + 4;
linux-user/main.c:            env->pc = env->npc;
linux-user/main.c:            env->npc = env->npc + 4;
linux-user/main.c:                /* XXX: check env->error_code */
linux-user/main.c:                info._sifields._sigfault._addr = env->mmuregs[4];
linux-user/main.c:                /* XXX: check env->error_code */
linux-user/main.c:                    info._sifields._sigfault._addr = env->dmmuregs[4];
linux-user/main.c:                info._sifields._sigfault._addr = env->pc;
linux-user/main.c:    addr = env->reserve_ea;
linux-user/main.c:        int reg = env->reserve_info & 0x1f;
linux-user/main.c:        int size = env->reserve_info >> 5;
linux-user/main.c:        if (addr == env->reserve_addr) {
linux-user/main.c:            if (!segv && val == env->reserve_val) {
linux-user/main.c:                val = env->gpr[reg];
linux-user/main.c:                    if (val2 == env->reserve_val2) {
linux-user/main.c:                            val = env->gpr[reg+1];
linux-user/main.c:                            val2 = env->gpr[reg+1];
linux-user/main.c:        env->crf[0] = (stored << 1) | xer_so;
linux-user/main.c:        env->reserve_addr = (target_ulong)-1;
linux-user/main.c:        env->nip += 4;
linux-user/main.c:                      env->spr[SPR_DAR]);
linux-user/main.c:            switch (env->error_code & 0xFF000000) {
linux-user/main.c:                          env->error_code);
linux-user/main.c:            info._sifields._sigfault._addr = env->nip;
linux-user/main.c:                      "\n", env->spr[SPR_SRR0]);
linux-user/main.c:            switch (env->error_code & 0xFF000000) {
linux-user/main.c:                          env->error_code);
linux-user/main.c:            info._sifields._sigfault._addr = env->nip - 4;
linux-user/main.c:            info._sifields._sigfault._addr = env->nip - 4;
linux-user/main.c:            switch (env->error_code & ~0xF) {
linux-user/main.c:                switch (env->error_code & 0xF) {
linux-user/main.c:                              env->error_code);
linux-user/main.c:                switch (env->error_code & 0xF) {
linux-user/main.c:                              env->error_code & 0xF);
linux-user/main.c:                switch (env->error_code & 0xF) {
linux-user/main.c:                              env->error_code & 0xF);
linux-user/main.c:                          env->error_code);
linux-user/main.c:            info._sifields._sigfault._addr = env->nip - 4;
linux-user/main.c:            info._sifields._sigfault._addr = env->nip - 4;
linux-user/main.c:            info._sifields._sigfault._addr = env->nip - 4;
linux-user/main.c:            info._sifields._sigfault._addr = env->nip - 4;
linux-user/main.c:            info._sifields._sigfault._addr = env->nip - 4;
linux-user/main.c:            env->crf[0] &= ~0x1;
linux-user/main.c:            ret = do_syscall(env, env->gpr[0], env->gpr[3], env->gpr[4],
linux-user/main.c:                             env->gpr[5], env->gpr[6], env->gpr[7],
linux-user/main.c:                             env->gpr[8], 0, 0);
linux-user/main.c:                env->crf[0] |= 0x1;
linux-user/main.c:            env->gpr[3] = ret;
linux-user/main.c:                info._sifields._sigfault._addr = env->nip;
linux-user/main.c:    addr = env->lladdr;
linux-user/main.c:        reg = env->llreg & 0x1f;
linux-user/main.c:        d = (env->llreg & 0x20) != 0;
linux-user/main.c:            if (val != env->llval) {
linux-user/main.c:                env->active_tc.gpr[reg] = 0;
linux-user/main.c:                    segv = put_user_u64(env->llnewval, addr);
linux-user/main.c:                    segv = put_user_u32(env->llnewval, addr);
linux-user/main.c:                    env->active_tc.gpr[reg] = 1;
linux-user/main.c:    env->lladdr = -1;
linux-user/main.c:        env->active_tc.PC += 4;
linux-user/main.c:            env->active_tc.PC += 4;
linux-user/main.c:            syscall_num = env->active_tc.gpr[2] - 4000;
linux-user/main.c:                sp_reg = env->active_tc.gpr[29];
linux-user/main.c:                ret = do_syscall(env, env->active_tc.gpr[2],
linux-user/main.c:                                 env->active_tc.gpr[4],
linux-user/main.c:                                 env->active_tc.gpr[5],
linux-user/main.c:                                 env->active_tc.gpr[6],
linux-user/main.c:                                 env->active_tc.gpr[7],
linux-user/main.c:            ret = do_syscall(env, env->active_tc.gpr[2],
linux-user/main.c:                             env->active_tc.gpr[4], env->active_tc.gpr[5],
linux-user/main.c:                             env->active_tc.gpr[6], env->active_tc.gpr[7],
linux-user/main.c:                             env->active_tc.gpr[8], env->active_tc.gpr[9],
linux-user/main.c:                             env->active_tc.gpr[10], env->active_tc.gpr[11]);
linux-user/main.c:                env->active_tc.gpr[7] = 1; /* error flag */
linux-user/main.c:                env->active_tc.gpr[7] = 0; /* error flag */
linux-user/main.c:            env->active_tc.gpr[2] = ret;
linux-user/main.c:            /* XXX: check env->error_code */
linux-user/main.c:            info._sifields._sigfault._addr = env->CP0_BadVAddr;
linux-user/main.c:                info._sifields._sigfault._addr = env->active_tc.PC;
linux-user/main.c:                if (env->hflags & MIPS_HFLAG_M16) {
linux-user/main.c:                    if (env->insn_flags & ASE_MICROMIPS) {
linux-user/main.c:                        ret = get_user_u16(trap_instr, env->active_tc.PC);
linux-user/main.c:                                               env->active_tc.PC + 2);
linux-user/main.c:                        ret = get_user_u16(trap_instr, env->active_tc.PC);
linux-user/main.c:                    ret = get_user_ual(trap_instr, env->active_tc.PC);
linux-user/main.c:                if (env->hflags & MIPS_HFLAG_M16) {
linux-user/main.c:                    ret = get_user_u16(instr[0], env->active_tc.PC) ||
linux-user/main.c:                          get_user_u16(instr[1], env->active_tc.PC + 2);
linux-user/main.c:                    ret = get_user_ual(trap_instr, env->active_tc.PC);
linux-user/main.c:                    if (env->hflags & MIPS_HFLAG_M16) {
linux-user/main.c:            qemu_log("\nReset request, exit, pc is %#x\n", env->pc);
linux-user/main.c:            qemu_log("\nBus error, exit, pc is %#x\n", env->pc);
linux-user/main.c:            qemu_log("\nTick time interrupt pc is %#x\n", env->pc);
linux-user/main.c:            qemu_log("\nAlignment pc is %#x\n", env->pc);
linux-user/main.c:            qemu_log("\nIllegal instructionpc is %#x\n", env->pc);
linux-user/main.c:            qemu_log("\nExternal interruptpc is %#x\n", env->pc);
linux-user/main.c:            env->pc += 4;   /* 0xc00; */
linux-user/main.c:            env->gpr[11] = do_syscall(env,
linux-user/main.c:                                      env->gpr[11], /* return value       */
linux-user/main.c:                                      env->gpr[3],  /* r3 - r7 are params */
linux-user/main.c:                                      env->gpr[4],
linux-user/main.c:                                      env->gpr[5],
linux-user/main.c:                                      env->gpr[6],
linux-user/main.c:                                      env->gpr[7],
linux-user/main.c:                                      env->gpr[8], 0, 0);
linux-user/main.c:            env->pc += 2;
linux-user/main.c:                             env->gregs[3],
linux-user/main.c:                             env->gregs[4],
linux-user/main.c:                             env->gregs[5],
linux-user/main.c:                             env->gregs[6],
linux-user/main.c:                             env->gregs[7],
linux-user/main.c:                             env->gregs[0],
linux-user/main.c:                             env->gregs[1],
linux-user/main.c:            env->gregs[0] = ret;
linux-user/main.c:            info._sifields._sigfault._addr = env->tea;
linux-user/main.c:                /* XXX: check env->error_code */
linux-user/main.c:                info._sifields._sigfault._addr = env->pregs[PR_EDA];
linux-user/main.c:                             env->regs[9], 
linux-user/main.c:                             env->regs[10], 
linux-user/main.c:                             env->regs[11], 
linux-user/main.c:                             env->regs[12], 
linux-user/main.c:                             env->regs[13], 
linux-user/main.c:                             env->pregs[7], 
linux-user/main.c:                             env->pregs[11],
linux-user/main.c:            env->regs[10] = ret;
linux-user/main.c:                /* XXX: check env->error_code */
linux-user/main.c:            env->regs[14] += 4;
linux-user/main.c:            env->sregs[SR_PC] = env->regs[14];
linux-user/main.c:                             env->regs[12], 
linux-user/main.c:                             env->regs[5], 
linux-user/main.c:                             env->regs[6], 
linux-user/main.c:                             env->regs[7], 
linux-user/main.c:                             env->regs[8], 
linux-user/main.c:                             env->regs[9], 
linux-user/main.c:                             env->regs[10],
linux-user/main.c:            env->regs[3] = ret;
linux-user/main.c:            env->regs[17] = env->sregs[SR_PC] + 4;
linux-user/main.c:            if (env->iflags & D_FLAG) {
linux-user/main.c:                env->sregs[SR_ESR] |= 1 << 12;
linux-user/main.c:                env->sregs[SR_PC] -= 4;
linux-user/main.c:            env->iflags &= ~(IMM_FLAG | D_FLAG);
linux-user/main.c:            switch (env->sregs[SR_ESR] & 31) {
linux-user/main.c:                    if (env->sregs[SR_FSR] & FSR_IO) {
linux-user/main.c:                    if (env->sregs[SR_FSR] & FSR_DZ) {
linux-user/main.c:                            env->sregs[SR_ESR] & ESR_EC_MASK);
linux-user/main.c:                    nr = lduw(env->pc + 2);
linux-user/main.c:                    env->pc += 4;
linux-user/main.c:            env->pc += 4;
linux-user/main.c:            do_m68k_semihosting(env, env->dregs[0]);
linux-user/main.c:            info._sifields._sigfault._addr = env->pc;
linux-user/main.c:                n = env->dregs[0];
linux-user/main.c:                env->pc += 2;
linux-user/main.c:                env->dregs[0] = do_syscall(env,
linux-user/main.c:                                          env->dregs[1],
linux-user/main.c:                                          env->dregs[2],
linux-user/main.c:                                          env->dregs[3],
linux-user/main.c:                                          env->dregs[4],
linux-user/main.c:                                          env->dregs[5],
linux-user/main.c:                                          env->aregs[0],
linux-user/main.c:                /* XXX: check env->error_code */
linux-user/main.c:                info._sifields._sigfault._addr = env->mmu.ar;
linux-user/main.c:    addr = env->lock_addr;
linux-user/main.c:    tmp = env->lock_st_addr;
linux-user/main.c:    env->lock_addr = -1;
linux-user/main.c:    env->lock_st_addr = 0;
linux-user/main.c:        if (val == env->lock_value) {
linux-user/main.c:            tmp = env->ir[reg];
linux-user/main.c:    env->ir[reg] = ret;
linux-user/main.c:    env->pc += 4;
linux-user/main.c:        env->intr_flag = 0;
linux-user/main.c:            env->lock_addr = -1;
linux-user/main.c:            info.si_code = (page_get_flags(env->trap_arg0) & PAGE_VALID
linux-user/main.c:            info._sifields._sigfault._addr = env->trap_arg0;
linux-user/main.c:            env->lock_addr = -1;
linux-user/main.c:            info._sifields._sigfault._addr = env->trap_arg0;
linux-user/main.c:            env->lock_addr = -1;
linux-user/main.c:            info._sifields._sigfault._addr = env->pc;
linux-user/main.c:            env->lock_addr = -1;
linux-user/main.c:            info._sifields._sigfault._addr = env->pc;
linux-user/main.c:            env->lock_addr = -1;
linux-user/main.c:            switch (env->error_code) {
linux-user/main.c:                info._sifields._sigfault._addr = env->pc;
linux-user/main.c:                info._sifields._sigfault._addr = env->pc;
linux-user/main.c:                trapnr = env->ir[IR_V0];
linux-user/main.c:                                    env->ir[IR_A0], env->ir[IR_A1],
linux-user/main.c:                                    env->ir[IR_A2], env->ir[IR_A3],
linux-user/main.c:                                    env->ir[IR_A4], env->ir[IR_A5],
linux-user/main.c:                trapnr = (env->ir[IR_V0] != 0 && sysret < 0);
linux-user/main.c:                env->ir[IR_V0] = (trapnr ? -sysret : sysret);
linux-user/main.c:                env->ir[IR_A3] = trapnr;
linux-user/main.c:                switch (env->ir[IR_A0]) {
linux-user/main.c:                info._sifields._sigfault._addr = env->pc;
linux-user/main.c:                env->lock_addr = -1;
linux-user/main.c:            do_store_exclusive(env, env->error_code, trapnr - EXCP_STL_C);
linux-user/main.c:            n = env->int_svc_code;
linux-user/main.c:                n = env->regs[1];
linux-user/main.c:            env->psw.addr += env->int_svc_ilen;
linux-user/main.c:            env->regs[2] = do_syscall(env, n, env->regs[2], env->regs[3],
linux-user/main.c:                                      env->regs[4], env->regs[5],
linux-user/main.c:                                      env->regs[6], env->regs[7], 0, 0);
linux-user/main.c:            n = env->int_pgm_code;
linux-user/main.c:                /* XXX: check env->error_code */
linux-user/main.c:                addr = env->__excp_addr;
linux-user/main.c:                n = (env->fpc >> 8) & 0xff;
linux-user/main.c:            addr = env->psw.addr;
linux-user/main.c:    env->cr[0] = CR0_PG_MASK | CR0_WP_MASK | CR0_PE_MASK;
linux-user/main.c:    env->hflags |= HF_PE_MASK | HF_CPL_MASK;
linux-user/main.c:    if (env->features[FEAT_1_EDX] & CPUID_SSE) {
linux-user/main.c:        env->cr[4] |= CR4_OSFXSR_MASK;
linux-user/main.c:        env->hflags |= HF_OSFXSR_MASK;
linux-user/main.c:    if (!(env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM)) {
linux-user/main.c:    env->cr[4] |= CR4_PAE_MASK;
linux-user/main.c:    env->efer |= MSR_EFER_LMA | MSR_EFER_LME;
linux-user/main.c:    env->hflags |= HF_LMA_MASK;
linux-user/main.c:    env->eflags |= IF_MASK;
linux-user/main.c:    env->regs[R_EAX] = regs->rax;
linux-user/main.c:    env->regs[R_EBX] = regs->rbx;
linux-user/main.c:    env->regs[R_ECX] = regs->rcx;
linux-user/main.c:    env->regs[R_EDX] = regs->rdx;
linux-user/main.c:    env->regs[R_ESI] = regs->rsi;
linux-user/main.c:    env->regs[R_EDI] = regs->rdi;
linux-user/main.c:    env->regs[R_EBP] = regs->rbp;
linux-user/main.c:    env->regs[R_ESP] = regs->rsp;
linux-user/main.c:    env->eip = regs->rip;
linux-user/main.c:    env->regs[R_EAX] = regs->eax;
linux-user/main.c:    env->regs[R_EBX] = regs->ebx;
linux-user/main.c:    env->regs[R_ECX] = regs->ecx;
linux-user/main.c:    env->regs[R_EDX] = regs->edx;
linux-user/main.c:    env->regs[R_ESI] = regs->esi;
linux-user/main.c:    env->regs[R_EDI] = regs->edi;
linux-user/main.c:    env->regs[R_EBP] = regs->ebp;
linux-user/main.c:    env->regs[R_ESP] = regs->esp;
linux-user/main.c:    env->eip = regs->eip;
linux-user/main.c:    env->idt.limit = 511;
linux-user/main.c:    env->idt.limit = 255;
linux-user/main.c:    env->idt.base = target_mmap(0, sizeof(uint64_t) * (env->idt.limit + 1),
linux-user/main.c:    idt_table = g2h(env->idt.base);
linux-user/main.c:        env->gdt.base = target_mmap(0, sizeof(uint64_t) * TARGET_GDT_ENTRIES,
linux-user/main.c:        env->gdt.limit = sizeof(uint64_t) * TARGET_GDT_ENTRIES - 1;
linux-user/main.c:        gdt_table = g2h(env->gdt.base);
linux-user/main.c:    env->segs[R_FS].selector = 0;
linux-user/main.c:            env->xregs[i] = regs->regs[i];
linux-user/main.c:        env->pc = regs->pc;
linux-user/main.c:        env->xregs[31] = regs->sp;
linux-user/main.c:            env->regs[i] = regs->uregs[i];
linux-user/main.c:            env->bswap_code = 1;
linux-user/main.c:            env->regs[i] = regs->uregs[i];
linux-user/main.c:	env->pc = regs->pc;
linux-user/main.c:	env->npc = regs->npc;
linux-user/main.c:        env->y = regs->y;
linux-user/main.c:            env->gregs[i] = regs->u_regs[i];
linux-user/main.c:            env->regwptr[i] = regs->u_regs[i + 8];
linux-user/main.c:        env->msr &= ~((target_ulong)1 << MSR_SF);
linux-user/main.c:        env->msr |= (target_ulong)1 << MSR_SF;
linux-user/main.c:        env->nip = regs->nip;
linux-user/main.c:            env->gpr[i] = regs->gpr[i];
linux-user/main.c:        env->pc = regs->pc;
linux-user/main.c:        env->dregs[0] = regs->d0;
linux-user/main.c:        env->dregs[1] = regs->d1;
linux-user/main.c:        env->dregs[2] = regs->d2;
linux-user/main.c:        env->dregs[3] = regs->d3;
linux-user/main.c:        env->dregs[4] = regs->d4;
linux-user/main.c:        env->dregs[5] = regs->d5;
linux-user/main.c:        env->dregs[6] = regs->d6;
linux-user/main.c:        env->dregs[7] = regs->d7;
linux-user/main.c:        env->aregs[0] = regs->a0;
linux-user/main.c:        env->aregs[1] = regs->a1;
linux-user/main.c:        env->aregs[2] = regs->a2;
linux-user/main.c:        env->aregs[3] = regs->a3;
linux-user/main.c:        env->aregs[4] = regs->a4;
linux-user/main.c:        env->aregs[5] = regs->a5;
linux-user/main.c:        env->aregs[6] = regs->a6;
linux-user/main.c:        env->aregs[7] = regs->usp;
linux-user/main.c:        env->sr = regs->sr;
linux-user/main.c:        env->regs[0] = regs->r0;
linux-user/main.c:        env->regs[1] = regs->r1;
linux-user/main.c:        env->regs[2] = regs->r2;
linux-user/main.c:        env->regs[3] = regs->r3;
linux-user/main.c:        env->regs[4] = regs->r4;
linux-user/main.c:        env->regs[5] = regs->r5;
linux-user/main.c:        env->regs[6] = regs->r6;
linux-user/main.c:        env->regs[7] = regs->r7;
linux-user/main.c:        env->regs[8] = regs->r8;
linux-user/main.c:        env->regs[9] = regs->r9;
linux-user/main.c:        env->regs[10] = regs->r10;
linux-user/main.c:        env->regs[11] = regs->r11;
linux-user/main.c:        env->regs[12] = regs->r12;
linux-user/main.c:        env->regs[13] = regs->r13;
linux-user/main.c:        env->regs[14] = regs->r14;
linux-user/main.c:        env->regs[15] = regs->r15;	    
linux-user/main.c:        env->regs[16] = regs->r16;	    
linux-user/main.c:        env->regs[17] = regs->r17;	    
linux-user/main.c:        env->regs[18] = regs->r18;	    
linux-user/main.c:        env->regs[19] = regs->r19;	    
linux-user/main.c:        env->regs[20] = regs->r20;	    
linux-user/main.c:        env->regs[21] = regs->r21;	    
linux-user/main.c:        env->regs[22] = regs->r22;	    
linux-user/main.c:        env->regs[23] = regs->r23;	    
linux-user/main.c:        env->regs[24] = regs->r24;	    
linux-user/main.c:        env->regs[25] = regs->r25;	    
linux-user/main.c:        env->regs[26] = regs->r26;	    
linux-user/main.c:        env->regs[27] = regs->r27;	    
linux-user/main.c:        env->regs[28] = regs->r28;	    
linux-user/main.c:        env->regs[29] = regs->r29;	    
linux-user/main.c:        env->regs[30] = regs->r30;	    
linux-user/main.c:        env->regs[31] = regs->r31;	    
linux-user/main.c:        env->sregs[SR_PC] = regs->pc;
linux-user/main.c:            env->active_tc.gpr[i] = regs->regs[i];
linux-user/main.c:        env->active_tc.PC = regs->cp0_epc & ~(target_ulong)1;
linux-user/main.c:            env->hflags |= MIPS_HFLAG_M16;
linux-user/main.c:            env->gpr[i] = regs->gpr[i];
linux-user/main.c:        env->sr = regs->sr;
linux-user/main.c:        env->pc = regs->pc;
linux-user/main.c:            env->gregs[i] = regs->regs[i];
linux-user/main.c:        env->pc = regs->pc;
linux-user/main.c:            env->ir[i] = ((abi_ulong *)regs)[i];
linux-user/main.c:        env->ir[IR_SP] = regs->usp;
linux-user/main.c:        env->pc = regs->pc;
linux-user/main.c:	    env->regs[0] = regs->r0;
linux-user/main.c:	    env->regs[1] = regs->r1;
linux-user/main.c:	    env->regs[2] = regs->r2;
linux-user/main.c:	    env->regs[3] = regs->r3;
linux-user/main.c:	    env->regs[4] = regs->r4;
linux-user/main.c:	    env->regs[5] = regs->r5;
linux-user/main.c:	    env->regs[6] = regs->r6;
linux-user/main.c:	    env->regs[7] = regs->r7;
linux-user/main.c:	    env->regs[8] = regs->r8;
linux-user/main.c:	    env->regs[9] = regs->r9;
linux-user/main.c:	    env->regs[10] = regs->r10;
linux-user/main.c:	    env->regs[11] = regs->r11;
linux-user/main.c:	    env->regs[12] = regs->r12;
linux-user/main.c:	    env->regs[13] = regs->r13;
linux-user/main.c:	    env->regs[14] = info->start_stack;
linux-user/main.c:	    env->regs[15] = regs->acr;	    
linux-user/main.c:	    env->pc = regs->erp;
linux-user/main.c:                env->regs[i] = regs->gprs[i];
linux-user/main.c:            env->psw.mask = regs->psw.mask;
linux-user/main.c:            env->psw.addr = regs->psw.addr;
linux-user/mips/target_cpu.h:        env->active_tc.gpr[29] = newsp;
linux-user/mips/target_cpu.h:    env->active_tc.gpr[7] = 0;
linux-user/mips/target_cpu.h:    env->active_tc.gpr[2] = 0;
linux-user/mips/target_cpu.h:    env->active_tc.CP0_UserLocal = newtls;
linux-user/syscall.c:        env->ldt.base = target_mmap(0,
linux-user/syscall.c:        if (env->ldt.base == -1)
linux-user/syscall.c:        memset(g2h(env->ldt.base), 0,
linux-user/syscall.c:        env->ldt.limit = 0xffff;
linux-user/syscall.c:        ldt_table = g2h(env->ldt.base);
linux-user/syscall.c:    uint64_t *gdt_table = g2h(env->gdt.base);
linux-user/syscall.c:    uint64_t *gdt_table = g2h(env->gdt.base);
linux-user/syscall.c:        env->segs[idx].base = addr;
linux-user/syscall.c:        val = env->segs[idx].base;
linux-user/openrisc/target_cpu.h:        env->gpr[1] = newsp;
linux-user/openrisc/target_cpu.h:    env->gpr[11] = 0;
translate-all.c:                  cpu_single_env->mem_io_vaddr, len,
translate-all.c:                  cpu_single_env->eip,
translate-all.c:                  cpu_single_env->eip +
translate-all.c:                  (intptr_t)cpu_single_env->segs[R_CS].base);
translate-all.c:    if ((env->hflags & MIPS_HFLAG_BMASK) != 0 && n > 1) {
translate-all.c:        env->active_tc.PC -= 4;
translate-all.c:        env->hflags &= ~MIPS_HFLAG_BMASK;
translate-all.c:    if ((env->flags & ((DELAY_SLOT | DELAY_SLOT_CONDITIONAL))) != 0
translate-all.c:        env->pc -= 2;
translate-all.c:        env->flags &= ~(DELAY_SLOT | DELAY_SLOT_CONDITIONAL);
translate-all.c:    /* TODO: If env->pc != tb->pc (i.e. the faulting instruction was not
cpus.c:        info->value->pc = env->eip + env->segs[R_CS].base;
cpus.c:        info->value->nip = env->nip;
cpus.c:        info->value->pc = env->pc;
cpus.c:        info->value->npc = env->npc;
cpus.c:        info->value->PC = env->active_tc.PC;
include/exec/cpu_ldst_template.h:    if (unlikely(env->tlb_table[mmu_idx][page_index].ADDR_READ !=
include/exec/cpu_ldst_template.h:        uintptr_t hostaddr = addr + env->tlb_table[mmu_idx][page_index].addend;
include/exec/cpu_ldst_template.h:    if (unlikely(env->tlb_table[mmu_idx][page_index].ADDR_READ !=
include/exec/cpu_ldst_template.h:        uintptr_t hostaddr = addr + env->tlb_table[mmu_idx][page_index].addend;
include/exec/cpu_ldst_template.h:    if (unlikely(env->tlb_table[mmu_idx][page_index].addr_write !=
include/exec/cpu_ldst_template.h:        uintptr_t hostaddr = addr + env->tlb_table[mmu_idx][page_index].addend;
include/exec/cpu_ldst.h:    CPUTLBEntry *tlbentry = &env->tlb_table[mmu_idx][index];
include/exec/cpu_ldst.h:    haddr = addr + env->tlb_table[mmu_idx][index].addend;
include/hw/sparc/grlib.h:    env->irq_manager = dev;
target-xtensa/gdbstub.c:    const XtensaGdbReg *reg = env->config->gdb_regmap.reg + n;
target-xtensa/gdbstub.c:    if (n < 0 || n >= env->config->gdb_regmap.num_regs) {
target-xtensa/gdbstub.c:        return gdb_get_reg32(mem_buf, env->pc);
target-xtensa/gdbstub.c:        return gdb_get_reg32(mem_buf, env->phys_regs[(reg->targno & 0xff)
target-xtensa/gdbstub.c:                                                     % env->config->nareg]);
target-xtensa/gdbstub.c:        return gdb_get_reg32(mem_buf, env->sregs[reg->targno & 0xff]);
target-xtensa/gdbstub.c:        return gdb_get_reg32(mem_buf, env->uregs[reg->targno & 0xff]);
target-xtensa/gdbstub.c:        return gdb_get_reg32(mem_buf, float32_val(env->fregs[reg->targno
target-xtensa/gdbstub.c:        return gdb_get_reg32(mem_buf, env->regs[reg->targno & 0x0f]);
target-xtensa/gdbstub.c:    const XtensaGdbReg *reg = env->config->gdb_regmap.reg + n;
target-xtensa/gdbstub.c:    if (n < 0 || n >= env->config->gdb_regmap.num_regs) {
target-xtensa/gdbstub.c:        env->pc = tmp;
target-xtensa/gdbstub.c:        env->phys_regs[(reg->targno & 0xff) % env->config->nareg] = tmp;
target-xtensa/gdbstub.c:        env->sregs[reg->targno & 0xff] = tmp;
target-xtensa/gdbstub.c:        env->uregs[reg->targno & 0xff] = tmp;
target-xtensa/gdbstub.c:        env->fregs[reg->targno & 0x0f] = make_float32(tmp);
target-xtensa/gdbstub.c:        env->regs[reg->targno & 0x0f] = tmp;
target-xtensa/translate.c:        if ((env->sregs[IBREAKENABLE] & (1 << i)) &&
target-xtensa/translate.c:                env->sregs[IBREAKA + i] == dc->pc) {
target-xtensa/translate.c:    dc.config = env->config;
target-xtensa/translate.c:    dc.lbeg = env->sregs[LBEG];
target-xtensa/translate.c:    dc.lend = env->sregs[LEND];
target-xtensa/translate.c:    cpu_fprintf(f, "PC=%08x\n\n", env->pc);
target-xtensa/translate.c:        if (xtensa_option_bits_enabled(env->config, sregnames[i].opt_bits)) {
target-xtensa/translate.c:            cpu_fprintf(f, "%12s=%08x%c", sregnames[i].name, env->sregs[i],
target-xtensa/translate.c:        if (xtensa_option_bits_enabled(env->config, uregnames[i].opt_bits)) {
target-xtensa/translate.c:            cpu_fprintf(f, "%s=%08x%c", uregnames[i].name, env->uregs[i],
target-xtensa/translate.c:        cpu_fprintf(f, " A%02d=%08x%c", i, env->regs[i],
target-xtensa/translate.c:    for (i = 0; i < env->config->nareg; ++i) {
target-xtensa/translate.c:        cpu_fprintf(f, "AR%02d=%08x%c", i, env->phys_regs[i],
target-xtensa/translate.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_FP_COPROCESSOR)) {
target-xtensa/translate.c:                    float32_val(env->fregs[i]),
target-xtensa/translate.c:                    *(float *)&env->fregs[i], (i % 2) == 1 ? '\n' : ' ');
target-xtensa/translate.c:    env->pc = tcg_ctx.gen_opc_pc[pc_pos];
target-xtensa/helper.c:    for (i = 0; i < env->config->ndbreak; ++i) {
target-xtensa/helper.c:        if (env->cpu_watchpoint[i] &&
target-xtensa/helper.c:                env->cpu_watchpoint[i]->flags & BP_WATCHPOINT_HIT) {
target-xtensa/helper.c:    if (xtensa_option_enabled(env->config,
target-xtensa/helper.c:        return vector - env->config->vecbase + env->sregs[VECBASE];
target-xtensa/helper.c:    int level = env->pending_irq_level;
target-xtensa/helper.c:            level <= env->config->nlevel &&
target-xtensa/helper.c:            (env->config->level_mask[level] &
target-xtensa/helper.c:             env->sregs[INTSET] &
target-xtensa/helper.c:             env->sregs[INTENABLE])) {
target-xtensa/helper.c:            env->sregs[EPC1 + level - 1] = env->pc;
target-xtensa/helper.c:            env->sregs[EPS2 + level - 2] = env->sregs[PS];
target-xtensa/helper.c:            env->sregs[PS] =
target-xtensa/helper.c:                (env->sregs[PS] & ~PS_INTLEVEL) | level | PS_EXCM;
target-xtensa/helper.c:            env->pc = relocated_vector(env,
target-xtensa/helper.c:                    env->config->interrupt_vector[level]);
target-xtensa/helper.c:            env->sregs[EXCCAUSE] = LEVEL1_INTERRUPT_CAUSE;
target-xtensa/helper.c:            if (env->sregs[PS] & PS_EXCM) {
target-xtensa/helper.c:                if (env->config->ndepc) {
target-xtensa/helper.c:                    env->sregs[DEPC] = env->pc;
target-xtensa/helper.c:                    env->sregs[EPC1] = env->pc;
target-xtensa/helper.c:                env->sregs[EPC1] = env->pc;
target-xtensa/helper.c:                    (env->sregs[PS] & PS_UM) ? EXC_USER : EXC_KERNEL;
target-xtensa/helper.c:            env->sregs[PS] |= PS_EXCM;
target-xtensa/helper.c:        env->exception_taken = 1;
target-xtensa/helper.c:                __func__, env->pending_irq_level, xtensa_get_cintlevel(env),
target-xtensa/helper.c:                env->pc, env->regs[0], env->sregs[PS],
target-xtensa/helper.c:                env->sregs[INTSET], env->sregs[INTENABLE],
target-xtensa/helper.c:                env->sregs[CCOUNT]);
target-xtensa/helper.c:                env->pc, env->regs[0], env->sregs[PS], env->sregs[CCOUNT]);
target-xtensa/helper.c:        if (env->config->exception_vector[cs->exception_index]) {
target-xtensa/helper.c:            env->pc = relocated_vector(env,
target-xtensa/helper.c:                    env->config->exception_vector[cs->exception_index]);
target-xtensa/helper.c:            env->exception_taken = 1;
target-xtensa/helper.c:                    __func__, env->pc, cs->exception_index);
target-xtensa/helper.c:                __func__, env->pc, cs->exception_index);
target-xtensa/helper.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_MMU)) {
target-xtensa/helper.c:        env->sregs[RASID] = 0x04030201;
target-xtensa/helper.c:        env->sregs[ITLBCFG] = 0;
target-xtensa/helper.c:        env->sregs[DTLBCFG] = 0;
target-xtensa/helper.c:        env->autorefill_idx = 0;
target-xtensa/helper.c:        reset_tlb_mmu_all_ways(env, &env->config->itlb, env->itlb);
target-xtensa/helper.c:        reset_tlb_mmu_all_ways(env, &env->config->dtlb, env->dtlb);
target-xtensa/helper.c:        reset_tlb_mmu_ways56(env, &env->config->itlb, env->itlb);
target-xtensa/helper.c:        reset_tlb_mmu_ways56(env, &env->config->dtlb, env->dtlb);
target-xtensa/helper.c:        reset_tlb_region_way0(env, env->itlb);
target-xtensa/helper.c:        reset_tlb_region_way0(env, env->dtlb);
target-xtensa/helper.c:        if (((env->sregs[RASID] >> i * 8) & 0xff) == asid) {
target-xtensa/helper.c:        &env->config->dtlb : &env->config->itlb;
target-xtensa/helper.c:        env->dtlb : env->itlb;
target-xtensa/helper.c:            wi = ++env->autorefill_idx & 0x3;
target-xtensa/helper.c:            env->sregs[EXCVADDR] = vaddr;
target-xtensa/helper.c:        (env->sregs[PTEVADDR] | (vaddr >> 10)) & 0xfffffffc;
target-xtensa/helper.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_MMU)) {
target-xtensa/helper.c:    } else if (xtensa_option_bits_enabled(env->config,
target-xtensa/helper.c:                env->sregs[CACHEATTR] >> ((vaddr & 0xe0000000) >> 27));
target-xtensa/helper.c:        dtlb ? &env->config->dtlb : &env->config->itlb;
target-xtensa/helper.c:        xtensa_option_enabled(env->config, XTENSA_OPTION_MMU) ?
target-xtensa/helper.c:    if (xtensa_option_bits_enabled(env->config,
target-xtensa/cpu.h:    int level = (env->sregs[PS] & PS_INTLEVEL) >> PS_INTLEVEL_SHIFT;
target-xtensa/cpu.h:    if ((env->sregs[PS] & PS_EXCM) && env->config->excm_level > level) {
target-xtensa/cpu.h:        level = env->config->excm_level;
target-xtensa/cpu.h:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_MMU)) {
target-xtensa/cpu.h:        return (env->sregs[PS] & PS_RING) >> PS_RING_SHIFT;
target-xtensa/cpu.h:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_MMU) &&
target-xtensa/cpu.h:            (env->sregs[PS] & PS_EXCM) == 0) {
target-xtensa/cpu.h:        return (env->sregs[PS] & PS_RING) >> PS_RING_SHIFT;
target-xtensa/cpu.h:        env->dtlb[wi] + ei :
target-xtensa/cpu.h:        env->itlb[wi] + ei;
target-xtensa/cpu.h:    *pc = env->pc;
target-xtensa/cpu.h:    if (env->sregs[PS] & PS_EXCM) {
target-xtensa/cpu.h:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_EXTENDED_L32R) &&
target-xtensa/cpu.h:            (env->sregs[LITBASE] & 1)) {
target-xtensa/cpu.h:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_DEBUG)) {
target-xtensa/cpu.h:        if (xtensa_get_cintlevel(env) < env->config->debug_level) {
target-xtensa/cpu.h:        if (xtensa_get_cintlevel(env) < env->sregs[ICOUNTLEVEL]) {
target-xtensa/cpu.h:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_COPROCESSOR)) {
target-xtensa/cpu.h:        *flags |= env->sregs[CPENABLE] << XTENSA_TBFLAG_CPENABLE_SHIFT;
target-xtensa/cpu.h:    if (cs->singlestep_enabled && env->exception_taken) {
target-xtensa/cpu.c:    env->exception_taken = 0;
target-xtensa/cpu.c:    env->pc = env->config->exception_vector[EXC_RESET];
target-xtensa/cpu.c:    env->sregs[LITBASE] &= ~1;
target-xtensa/cpu.c:    env->sregs[PS] = xtensa_option_enabled(env->config,
target-xtensa/cpu.c:    env->sregs[VECBASE] = env->config->vecbase;
target-xtensa/cpu.c:    env->sregs[IBREAKENABLE] = 0;
target-xtensa/cpu.c:    env->sregs[CACHEATTR] = 0x22222222;
target-xtensa/cpu.c:    env->sregs[ATOMCTL] = xtensa_option_enabled(env->config,
target-xtensa/cpu.c:    env->sregs[CONFIGID0] = env->config->configid[0];
target-xtensa/cpu.c:    env->sregs[CONFIGID1] = env->config->configid[1];
target-xtensa/cpu.c:    env->pending_irq_level = 0;
target-xtensa/cpu.c:    env->config = xcc->config;
target-xtensa/xtensa-semi.c:    uint32_t *regs = env->regs;
target-xtensa/op_helper.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_UNALIGNED_EXCEPTION) &&
target-xtensa/op_helper.c:            !xtensa_option_enabled(env->config, XTENSA_OPTION_HW_ALIGNMENT)) {
target-xtensa/op_helper.c:                env->pc, LOAD_STORE_ALIGNMENT_CAUSE, addr);
target-xtensa/op_helper.c:        HELPER(exception_cause_vaddr)(env, env->pc, ret, vaddr);
target-xtensa/op_helper.c:        env->exception_taken = 0;
target-xtensa/op_helper.c:    env->pc = pc;
target-xtensa/op_helper.c:    if (env->sregs[PS] & PS_EXCM) {
target-xtensa/op_helper.c:        if (env->config->ndepc) {
target-xtensa/op_helper.c:            env->sregs[DEPC] = pc;
target-xtensa/op_helper.c:            env->sregs[EPC1] = pc;
target-xtensa/op_helper.c:        env->sregs[EPC1] = pc;
target-xtensa/op_helper.c:        vector = (env->sregs[PS] & PS_UM) ? EXC_USER : EXC_KERNEL;
target-xtensa/op_helper.c:    env->sregs[EXCCAUSE] = cause;
target-xtensa/op_helper.c:    env->sregs[PS] |= PS_EXCM;
target-xtensa/op_helper.c:    env->sregs[EXCVADDR] = vaddr;
target-xtensa/op_helper.c:    if (xtensa_get_cintlevel(env) < env->config->debug_level) {
target-xtensa/op_helper.c:        HELPER(debug_exception)(env, env->pc, cause);
target-xtensa/op_helper.c:    unsigned level = env->config->debug_level;
target-xtensa/op_helper.c:    env->pc = pc;
target-xtensa/op_helper.c:    env->sregs[DEBUGCAUSE] = cause;
target-xtensa/op_helper.c:    env->sregs[EPC1 + level - 1] = pc;
target-xtensa/op_helper.c:    env->sregs[EPS2 + level - 2] = env->sregs[PS];
target-xtensa/op_helper.c:    env->sregs[PS] = (env->sregs[PS] & ~PS_INTLEVEL) | PS_EXCM |
target-xtensa/op_helper.c:    assert(phys < env->config->nareg);
target-xtensa/op_helper.c:    if (phys + n <= env->config->nareg) {
target-xtensa/op_helper.c:        memcpy(env->regs + window, env->phys_regs + phys,
target-xtensa/op_helper.c:        uint32_t n1 = env->config->nareg - phys;
target-xtensa/op_helper.c:        memcpy(env->regs + window, env->phys_regs + phys,
target-xtensa/op_helper.c:        memcpy(env->regs + window + n1, env->phys_regs,
target-xtensa/op_helper.c:    assert(phys < env->config->nareg);
target-xtensa/op_helper.c:    if (phys + n <= env->config->nareg) {
target-xtensa/op_helper.c:        memcpy(env->phys_regs + phys, env->regs + window,
target-xtensa/op_helper.c:        uint32_t n1 = env->config->nareg - phys;
target-xtensa/op_helper.c:        memcpy(env->phys_regs + phys, env->regs + window,
target-xtensa/op_helper.c:        memcpy(env->phys_regs, env->regs + window + n1,
target-xtensa/op_helper.c:    return a & (env->config->nareg / 4 - 1);
target-xtensa/op_helper.c:    copy_window_from_phys(env, 0, env->sregs[WINDOW_BASE] * 4, 16);
target-xtensa/op_helper.c:    copy_phys_from_window(env, env->sregs[WINDOW_BASE] * 4, 0, 16);
target-xtensa/op_helper.c:    env->sregs[WINDOW_BASE] = windowbase_bound(position, env);
target-xtensa/op_helper.c:    rotate_window_abs(env, env->sregs[WINDOW_BASE] + delta);
target-xtensa/op_helper.c:    int callinc = (env->sregs[PS] & PS_CALLINC) >> PS_CALLINC_SHIFT;
target-xtensa/op_helper.c:    if (s > 3 || ((env->sregs[PS] & (PS_WOE | PS_EXCM)) ^ PS_WOE) != 0) {
target-xtensa/op_helper.c:                pc, env->sregs[PS]);
target-xtensa/op_helper.c:        env->regs[(callinc << 2) | (s & 3)] = env->regs[s] - (imm << 3);
target-xtensa/op_helper.c:        env->sregs[WINDOW_START] |=
target-xtensa/op_helper.c:            windowstart_bit(env->sregs[WINDOW_BASE], env);
target-xtensa/op_helper.c:    uint32_t windowbase = windowbase_bound(env->sregs[WINDOW_BASE], env);
target-xtensa/op_helper.c:    uint32_t windowstart = env->sregs[WINDOW_START];
target-xtensa/op_helper.c:    if ((env->sregs[PS] & (PS_WOE | PS_EXCM)) ^ PS_WOE) {
target-xtensa/op_helper.c:    env->sregs[PS] = (env->sregs[PS] & ~PS_OWB) |
target-xtensa/op_helper.c:    env->sregs[EPC1] = env->pc = pc;
target-xtensa/op_helper.c:    int n = (env->regs[0] >> 30) & 0x3;
target-xtensa/op_helper.c:    uint32_t windowbase = windowbase_bound(env->sregs[WINDOW_BASE], env);
target-xtensa/op_helper.c:    uint32_t windowstart = env->sregs[WINDOW_START];
target-xtensa/op_helper.c:            ((env->sregs[PS] & (PS_WOE | PS_EXCM)) ^ PS_WOE) != 0) {
target-xtensa/op_helper.c:                pc, env->sregs[PS], m, n);
target-xtensa/op_helper.c:        ret_pc = (pc & 0xc0000000) | (env->regs[0] & 0x3fffffff);
target-xtensa/op_helper.c:        if (windowstart & windowstart_bit(env->sregs[WINDOW_BASE], env)) {
target-xtensa/op_helper.c:            env->sregs[WINDOW_START] &= ~windowstart_bit(owb, env);
target-xtensa/op_helper.c:            env->sregs[PS] = (env->sregs[PS] & ~PS_OWB) |
target-xtensa/op_helper.c:            env->sregs[EPC1] = env->pc = pc;
target-xtensa/op_helper.c:    rotate_window_abs(env, (env->sregs[PS] & PS_OWB) >> PS_OWB_SHIFT);
target-xtensa/op_helper.c:    if ((env->sregs[WINDOW_START] &
target-xtensa/op_helper.c:            (windowstart_bit(env->sregs[WINDOW_BASE] - 3, env) |
target-xtensa/op_helper.c:             windowstart_bit(env->sregs[WINDOW_BASE] - 2, env) |
target-xtensa/op_helper.c:             windowstart_bit(env->sregs[WINDOW_BASE] - 1, env))) == 0) {
target-xtensa/op_helper.c:    if (env->sregs[LBEG] != v) {
target-xtensa/op_helper.c:        tb_invalidate_virtual_addr(env, env->sregs[LEND] - 1);
target-xtensa/op_helper.c:        env->sregs[LBEG] = v;
target-xtensa/op_helper.c:    if (env->sregs[LEND] != v) {
target-xtensa/op_helper.c:        tb_invalidate_virtual_addr(env, env->sregs[LEND] - 1);
target-xtensa/op_helper.c:        env->sregs[LEND] = v;
target-xtensa/op_helper.c:        tb_invalidate_virtual_addr(env, env->sregs[LEND] - 1);
target-xtensa/op_helper.c:    env->pc = pc;
target-xtensa/op_helper.c:    env->sregs[PS] = (env->sregs[PS] & ~PS_INTLEVEL) |
target-xtensa/op_helper.c:    if (env->pending_irq_level) {
target-xtensa/op_helper.c:    env->halt_clock = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);
target-xtensa/op_helper.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_TIMER_INTERRUPT)) {
target-xtensa/op_helper.c:    uint32_t atomctl = env->sregs[ATOMCTL];
target-xtensa/op_helper.c:    if (!xtensa_option_enabled(env->config, XTENSA_OPTION_DCACHE)) {
target-xtensa/op_helper.c:    if (v != env->sregs[RASID]) {
target-xtensa/op_helper.c:        env->sregs[RASID] = v;
target-xtensa/op_helper.c:    uint32_t tlbcfg = env->sregs[dtlb ? DTLBCFG : ITLBCFG];
target-xtensa/op_helper.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_MMU)) {
target-xtensa/op_helper.c:            env->config->dtlb.varway56 :
target-xtensa/op_helper.c:            env->config->itlb.varway56;
target-xtensa/op_helper.c:                env->config->dtlb.nrefillentries :
target-xtensa/op_helper.c:                env->config->itlb.nrefillentries) == 32;
target-xtensa/op_helper.c:            env->config->dtlb.varway56 :
target-xtensa/op_helper.c:            env->config->itlb.varway56;
target-xtensa/op_helper.c:        env->config->dtlb.varway56 :
target-xtensa/op_helper.c:        env->config->itlb.varway56;
target-xtensa/op_helper.c:                env->config->dtlb.nrefillentries :
target-xtensa/op_helper.c:                env->config->itlb.nrefillentries) == 32;
target-xtensa/op_helper.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_MMU)) {
target-xtensa/op_helper.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_MMU)) {
target-xtensa/op_helper.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_MMU)) {
target-xtensa/op_helper.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_MMU)) {
target-xtensa/op_helper.c:            HELPER(exception_cause_vaddr)(env, env->pc, res, v);
target-xtensa/op_helper.c:    entry->asid = (env->sregs[RASID] >> ((pte >> 1) & 0x18)) & 0xff;
target-xtensa/op_helper.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_MMU)) {
target-xtensa/op_helper.c:        if (xtensa_option_enabled(env->config,
target-xtensa/op_helper.c:    uint32_t change = v ^ env->sregs[IBREAKENABLE];
target-xtensa/op_helper.c:    for (i = 0; i < env->config->nibreak; ++i) {
target-xtensa/op_helper.c:            tb_invalidate_virtual_addr(env, env->sregs[IBREAKA + i]);
target-xtensa/op_helper.c:    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);
target-xtensa/op_helper.c:    if (env->sregs[IBREAKENABLE] & (1 << i) && env->sregs[IBREAKA + i] != v) {
target-xtensa/op_helper.c:        tb_invalidate_virtual_addr(env, env->sregs[IBREAKA + i]);
target-xtensa/op_helper.c:    env->sregs[IBREAKA + i] = v;
target-xtensa/op_helper.c:    if (env->cpu_watchpoint[i]) {
target-xtensa/op_helper.c:        cpu_watchpoint_remove_by_ref(cs, env->cpu_watchpoint[i]);
target-xtensa/op_helper.c:            flags, &env->cpu_watchpoint[i])) {
target-xtensa/op_helper.c:        env->cpu_watchpoint[i] = NULL;
target-xtensa/op_helper.c:    uint32_t dbreakc = env->sregs[DBREAKC + i];
target-xtensa/op_helper.c:            env->sregs[DBREAKA + i] != v) {
target-xtensa/op_helper.c:    env->sregs[DBREAKA + i] = v;
target-xtensa/op_helper.c:    if ((env->sregs[DBREAKC + i] ^ v) & (DBREAKC_SB_LB | DBREAKC_MASK)) {
target-xtensa/op_helper.c:            set_dbreak(env, i, env->sregs[DBREAKA + i], v);
target-xtensa/op_helper.c:            if (env->cpu_watchpoint[i]) {
target-xtensa/op_helper.c:                cpu_watchpoint_remove_by_ref(cs, env->cpu_watchpoint[i]);
target-xtensa/op_helper.c:                env->cpu_watchpoint[i] = NULL;
target-xtensa/op_helper.c:    env->sregs[DBREAKC + i] = v;
target-xtensa/op_helper.c:    env->uregs[FCR] = v & 0xfffff07f;
target-xtensa/op_helper.c:    set_float_rounding_mode(rounding_mode[v & 3], &env->fp_status);
target-xtensa/op_helper.c:    return float32_add(a, b, &env->fp_status);
target-xtensa/op_helper.c:    return float32_sub(a, b, &env->fp_status);
target-xtensa/op_helper.c:    return float32_mul(a, b, &env->fp_status);
target-xtensa/op_helper.c:            &env->fp_status);
target-xtensa/op_helper.c:            &env->fp_status);
target-xtensa/op_helper.c:    return float32_scalbn(int32_to_float32(v, &env->fp_status),
target-xtensa/op_helper.c:            (int32_t)scale, &env->fp_status);
target-xtensa/op_helper.c:    return float32_scalbn(uint32_to_float32(v, &env->fp_status),
target-xtensa/op_helper.c:            (int32_t)scale, &env->fp_status);
target-xtensa/op_helper.c:        env->sregs[BR] |= br;
target-xtensa/op_helper.c:        env->sregs[BR] &= ~br;
target-xtensa/op_helper.c:    set_br(env, float32_unordered_quiet(a, b, &env->fp_status), br);
target-xtensa/op_helper.c:    set_br(env, float32_eq_quiet(a, b, &env->fp_status), br);
target-xtensa/op_helper.c:    int v = float32_compare_quiet(a, b, &env->fp_status);
target-xtensa/op_helper.c:    set_br(env, float32_lt_quiet(a, b, &env->fp_status), br);
target-xtensa/op_helper.c:    int v = float32_compare_quiet(a, b, &env->fp_status);
target-xtensa/op_helper.c:    set_br(env, float32_le_quiet(a, b, &env->fp_status), br);
target-xtensa/op_helper.c:    int v = float32_compare_quiet(a, b, &env->fp_status);
target-sh4/gdbstub.c:        if ((env->sr & (SR_MD | SR_RB)) == (SR_MD | SR_RB)) {
target-sh4/gdbstub.c:            return gdb_get_regl(mem_buf, env->gregs[n + 16]);
target-sh4/gdbstub.c:            return gdb_get_regl(mem_buf, env->gregs[n]);
target-sh4/gdbstub.c:        return gdb_get_regl(mem_buf, env->gregs[n]);
target-sh4/gdbstub.c:        return gdb_get_regl(mem_buf, env->pc);
target-sh4/gdbstub.c:        return gdb_get_regl(mem_buf, env->pr);
target-sh4/gdbstub.c:        return gdb_get_regl(mem_buf, env->gbr);
target-sh4/gdbstub.c:        return gdb_get_regl(mem_buf, env->vbr);
target-sh4/gdbstub.c:        return gdb_get_regl(mem_buf, env->mach);
target-sh4/gdbstub.c:        return gdb_get_regl(mem_buf, env->macl);
target-sh4/gdbstub.c:        return gdb_get_regl(mem_buf, env->sr);
target-sh4/gdbstub.c:        return gdb_get_regl(mem_buf, env->fpul);
target-sh4/gdbstub.c:        return gdb_get_regl(mem_buf, env->fpscr);
target-sh4/gdbstub.c:        if (env->fpscr & FPSCR_FR) {
target-sh4/gdbstub.c:            stfl_p(mem_buf, env->fregs[n - 9]);
target-sh4/gdbstub.c:            stfl_p(mem_buf, env->fregs[n - 25]);
target-sh4/gdbstub.c:        return gdb_get_regl(mem_buf, env->ssr);
target-sh4/gdbstub.c:        return gdb_get_regl(mem_buf, env->spc);
target-sh4/gdbstub.c:        return gdb_get_regl(mem_buf, env->gregs[n - 43]);
target-sh4/gdbstub.c:        return gdb_get_regl(mem_buf, env->gregs[n - (51 - 16)]);
target-sh4/gdbstub.c:        if ((env->sr & (SR_MD | SR_RB)) == (SR_MD | SR_RB)) {
target-sh4/gdbstub.c:            env->gregs[n + 16] = ldl_p(mem_buf);
target-sh4/gdbstub.c:            env->gregs[n] = ldl_p(mem_buf);
target-sh4/gdbstub.c:        env->gregs[n] = ldl_p(mem_buf);
target-sh4/gdbstub.c:        env->pc = ldl_p(mem_buf);
target-sh4/gdbstub.c:        env->pr = ldl_p(mem_buf);
target-sh4/gdbstub.c:        env->gbr = ldl_p(mem_buf);
target-sh4/gdbstub.c:        env->vbr = ldl_p(mem_buf);
target-sh4/gdbstub.c:        env->mach = ldl_p(mem_buf);
target-sh4/gdbstub.c:        env->macl = ldl_p(mem_buf);
target-sh4/gdbstub.c:        env->sr = ldl_p(mem_buf);
target-sh4/gdbstub.c:        env->fpul = ldl_p(mem_buf);
target-sh4/gdbstub.c:        env->fpscr = ldl_p(mem_buf);
target-sh4/gdbstub.c:        if (env->fpscr & FPSCR_FR) {
target-sh4/gdbstub.c:            env->fregs[n - 9] = ldfl_p(mem_buf);
target-sh4/gdbstub.c:            env->fregs[n - 25] = ldfl_p(mem_buf);
target-sh4/gdbstub.c:        env->ssr = ldl_p(mem_buf);
target-sh4/gdbstub.c:        env->spc = ldl_p(mem_buf);
target-sh4/gdbstub.c:        env->gregs[n - 43] = ldl_p(mem_buf);
target-sh4/gdbstub.c:        env->gregs[n - (51 - 16)] = ldl_p(mem_buf);
target-sh4/translate.c:		env->pc, env->sr, env->pr, env->fpscr);
target-sh4/translate.c:		env->spc, env->ssr, env->gbr, env->vbr);
target-sh4/translate.c:		env->sgr, env->dbr, env->delayed_pc, env->fpul);
target-sh4/translate.c:		    i, env->gregs[i], i + 1, env->gregs[i + 1],
target-sh4/translate.c:		    i + 2, env->gregs[i + 2], i + 3, env->gregs[i + 3]);
target-sh4/translate.c:    if (env->flags & DELAY_SLOT) {
target-sh4/translate.c:		    env->delayed_pc);
target-sh4/translate.c:    } else if (env->flags & DELAY_SLOT_CONDITIONAL) {
target-sh4/translate.c:		    env->delayed_pc);
target-sh4/translate.c:    ctx.features = env->features;
target-sh4/translate.c:    env->pc = tcg_ctx.gen_opc_pc[pc_pos];
target-sh4/translate.c:    env->flags = gen_opc_hflags[pc_pos];
target-sh4/helper.c:    env->tea = address;
target-sh4/helper.c:    if (env->sr & SR_BL) {
target-sh4/helper.c:        if (do_irq && !env->in_sleep) {
target-sh4/helper.c:    env->in_sleep = 0;
target-sh4/helper.c:        irq_vector = sh_intc_get_pending_vector(env->intc_handle,
target-sh4/helper.c:						(env->sr >> 4) & 0xf);
target-sh4/helper.c:    env->ssr = env->sr;
target-sh4/helper.c:    env->spc = env->pc;
target-sh4/helper.c:    env->sgr = env->gregs[15];
target-sh4/helper.c:    env->sr |= SR_BL | SR_MD | SR_RB;
target-sh4/helper.c:    if (env->flags & (DELAY_SLOT | DELAY_SLOT_CONDITIONAL)) {
target-sh4/helper.c:	env->spc -= 2;
target-sh4/helper.c:	env->flags &= ~(DELAY_SLOT | DELAY_SLOT_CONDITIONAL | DELAY_SLOT_TRUE);
target-sh4/helper.c:    if (env->flags & DELAY_SLOT_CLEARME)
target-sh4/helper.c:        env->flags = 0;
target-sh4/helper.c:        env->expevt = cs->exception_index;
target-sh4/helper.c:            env->sr &= ~SR_FD;
target-sh4/helper.c:            env->sr |= 0xf << 4; /* IMASK */
target-sh4/helper.c:            env->pc = 0xa0000000;
target-sh4/helper.c:            env->pc = env->vbr + 0x400;
target-sh4/helper.c:            env->spc += 2; /* special case for TRAPA */
target-sh4/helper.c:            env->pc = env->vbr + 0x100;
target-sh4/helper.c:        env->intevt = irq_vector;
target-sh4/helper.c:        env->pc = env->vbr + 0x600;
target-sh4/helper.c:    env->mmucr &= (and_mask << 24) | 0x00ffffff;
target-sh4/helper.c:    env->mmucr |= (or_mask << 24);
target-sh4/helper.c:    if ((env->mmucr & 0xe0000000) == 0xe0000000) {
target-sh4/helper.c:    if ((env->mmucr & 0x98000000) == 0x18000000) {
target-sh4/helper.c:    if ((env->mmucr & 0x54000000) == 0x04000000) {
target-sh4/helper.c:    if ((env->mmucr & 0x2c000000) == 0x00000000) {
target-sh4/helper.c:    asid = env->pteh & 0xff;
target-sh4/helper.c:    urb = ((env->mmucr) >> 18) & 0x3f;
target-sh4/helper.c:    urc = ((env->mmucr) >> 10) & 0x3f;
target-sh4/helper.c:    env->mmucr = (env->mmucr & 0xffff03ff) | (urc << 10);
target-sh4/helper.c:    ientry = &env->itlb[itlb];
target-sh4/helper.c:    *ientry = env->utlb[utlb];
target-sh4/helper.c:    e = find_tlb_entry(env, address, env->itlb, ITLB_SIZE, use_asid);
target-sh4/helper.c:    return find_tlb_entry(env, address, env->utlb, UTLB_SIZE, use_asid);
target-sh4/helper.c:    use_asid = (env->mmucr & MMUCR_SV) == 0 || (env->sr & SR_MD) == 0;
target-sh4/helper.c:	    matching = &env->itlb[n];
target-sh4/helper.c:	    if (!(env->sr & SR_MD) && !(matching->pr & 2))
target-sh4/helper.c:                matching = &env->itlb[n];
target-sh4/helper.c:                if (!(env->sr & SR_MD) && !(matching->pr & 2)) {
target-sh4/helper.c:	    matching = &env->utlb[n];
target-sh4/helper.c:            if (!(env->sr & SR_MD) && !(matching->pr & 2)) {
target-sh4/helper.c:	if (!(env->sr & SR_MD)
target-sh4/helper.c:    if (!(env->mmucr & MMUCR_AT)) {
target-sh4/helper.c:	env->tea = address;
target-sh4/helper.c:	    env->pteh = (env->pteh & PTEH_ASID_MASK) |
target-sh4/helper.c:    int n = cpu_mmucr_urc(env->mmucr);
target-sh4/helper.c:    tlb_t * entry = &env->utlb[n];
target-sh4/helper.c:    entry->asid = (uint8_t)cpu_pteh_asid(env->pteh);
target-sh4/helper.c:    entry->vpn  = cpu_pteh_vpn(env->pteh);
target-sh4/helper.c:    entry->v    = (uint8_t)cpu_ptel_v(env->ptel);
target-sh4/helper.c:    entry->ppn  = cpu_ptel_ppn(env->ptel);
target-sh4/helper.c:    entry->sz   = (uint8_t)cpu_ptel_sz(env->ptel);
target-sh4/helper.c:    entry->sh   = (uint8_t)cpu_ptel_sh(env->ptel);
target-sh4/helper.c:    entry->c    = (uint8_t)cpu_ptel_c(env->ptel);
target-sh4/helper.c:    entry->pr   = (uint8_t)cpu_ptel_pr(env->ptel);
target-sh4/helper.c:    entry->d    = (uint8_t)cpu_ptel_d(env->ptel);
target-sh4/helper.c:    entry->wt   = (uint8_t)cpu_ptel_wt(env->ptel);
target-sh4/helper.c:    entry->sa   = (uint8_t)cpu_ptea_sa(env->ptea);
target-sh4/helper.c:    entry->tc   = (uint8_t)cpu_ptea_tc(env->ptea);
target-sh4/helper.c:    int use_asid = (env->mmucr & MMUCR_SV) == 0 || (env->sr & SR_MD) == 0;
target-sh4/helper.c:    if (env->sr & SR_MD) {
target-sh4/helper.c:    if (!(env->ccr & 1))
target-sh4/helper.c:    if (env->mmucr & MMUCR_AT)
target-sh4/helper.c:    n = find_tlb_entry(env, addr, env->itlb, ITLB_SIZE, use_asid);
target-sh4/helper.c:        return env->itlb[n].c;
target-sh4/helper.c:    n = find_tlb_entry(env, addr, env->utlb, UTLB_SIZE, use_asid);
target-sh4/helper.c:        return env->utlb[n].c;
target-sh4/cpu.h:    return (env->sr & SR_MD) == 0 ? 1 : 0;
target-sh4/cpu.h:    *pc = env->pc;
target-sh4/cpu.h:    *flags = (env->flags & (DELAY_SLOT | DELAY_SLOT_CONDITIONAL
target-sh4/cpu.h:            | (env->fpscr & (FPSCR_FR | FPSCR_SZ | FPSCR_PR))  /* Bits 19-21 */
target-sh4/cpu.h:            | (env->sr & (SR_MD | SR_RB))                      /* Bits 29-30 */
target-sh4/cpu.h:            | (env->sr & SR_FD)                                /* Bit 15 */
target-sh4/cpu.h:            | (env->movcal_backup ? TB_FLAG_PENDING_MOVCA : 0); /* Bit 4 */
target-sh4/cpu.c:    env->pc = 0xA0000000;
target-sh4/cpu.c:    env->fpscr = FPSCR_PR; /* value for userspace according to the kernel */
target-sh4/cpu.c:    set_float_rounding_mode(float_round_nearest_even, &env->fp_status); /* ?! */
target-sh4/cpu.c:    env->sr = SR_MD | SR_RB | SR_BL | SR_I3 | SR_I2 | SR_I1 | SR_I0;
target-sh4/cpu.c:    env->fpscr = FPSCR_DN | FPSCR_RM_ZERO; /* CPU reset value according to SH4 manual */
target-sh4/cpu.c:    set_float_rounding_mode(float_round_to_zero, &env->fp_status);
target-sh4/cpu.c:    set_flush_to_zero(1, &env->fp_status);
target-sh4/cpu.c:    set_default_nan_mode(1, &env->fp_status);
target-sh4/cpu.c:    env->id = SH_CPU_SH7750R;
target-sh4/cpu.c:    env->features = SH_FEATURE_BCR3_AND_BCR4;
target-sh4/cpu.c:    env->id = SH_CPU_SH7751R;
target-sh4/cpu.c:    env->features = SH_FEATURE_BCR3_AND_BCR4;
target-sh4/cpu.c:    env->id = SH_CPU_SH7785;
target-sh4/cpu.c:    env->features = SH_FEATURE_SH4A;
target-sh4/cpu.c:    env->movcal_backup_tail = &(env->movcal_backup);
target-sh4/op_helper.c:    env->in_sleep = 1;
target-sh4/op_helper.c:    env->tra = tra << 2;
target-sh4/op_helper.c:	*(env->movcal_backup_tail) = r;
target-sh4/op_helper.c:	env->movcal_backup_tail = &(r->next);
target-sh4/op_helper.c:    memory_content *current = env->movcal_backup;
target-sh4/op_helper.c:	env->movcal_backup = current = next;
target-sh4/op_helper.c:	    env->movcal_backup_tail = &(env->movcal_backup);
target-sh4/op_helper.c:    memory_content **current = &(env->movcal_backup);
target-sh4/op_helper.c:		env->movcal_backup_tail = current;
target-sh4/op_helper.c:#define T (env->sr & SR_T)
target-sh4/op_helper.c:#define Q (env->sr & SR_Q ? 1 : 0)
target-sh4/op_helper.c:#define M (env->sr & SR_M ? 1 : 0)
target-sh4/op_helper.c:#define SETT env->sr |= SR_T
target-sh4/op_helper.c:#define CLRT env->sr &= ~SR_T
target-sh4/op_helper.c:#define SETQ env->sr |= SR_Q
target-sh4/op_helper.c:#define CLRQ env->sr &= ~SR_Q
target-sh4/op_helper.c:#define SETM env->sr |= SR_M
target-sh4/op_helper.c:#define CLRM env->sr &= ~SR_M
target-sh4/op_helper.c:    res = ((uint64_t) env->mach << 32) | env->macl;
target-sh4/op_helper.c:    env->mach = (res >> 32) & 0xffffffff;
target-sh4/op_helper.c:    env->macl = res & 0xffffffff;
target-sh4/op_helper.c:    if (env->sr & SR_S) {
target-sh4/op_helper.c:	    env->mach |= 0xffff0000;
target-sh4/op_helper.c:	    env->mach &= 0x00007fff;
target-sh4/op_helper.c:    res = ((uint64_t) env->mach << 32) | env->macl;
target-sh4/op_helper.c:    env->mach = (res >> 32) & 0xffffffff;
target-sh4/op_helper.c:    env->macl = res & 0xffffffff;
target-sh4/op_helper.c:    if (env->sr & SR_S) {
target-sh4/op_helper.c:	    env->mach = 1;
target-sh4/op_helper.c:	    env->macl = 0x80000000;
target-sh4/op_helper.c:	    env->mach = 1;
target-sh4/op_helper.c:	    env->macl = 0x7fffffff;
target-sh4/op_helper.c:    env->sr |= SR_T;
target-sh4/op_helper.c:    env->sr &= ~SR_T;
target-sh4/op_helper.c:    env->fpscr = val & FPSCR_MASK;
target-sh4/op_helper.c:	set_float_rounding_mode(float_round_to_zero, &env->fp_status);
target-sh4/op_helper.c:	set_float_rounding_mode(float_round_nearest_even, &env->fp_status);
target-sh4/op_helper.c:    set_flush_to_zero((val & FPSCR_DN) != 0, &env->fp_status);
target-sh4/op_helper.c:    xcpt = get_float_exception_flags(&env->fp_status);
target-sh4/op_helper.c:    env->fpscr &= ~FPSCR_FLAG_MASK;
target-sh4/op_helper.c:            env->fpscr |= FPSCR_FLAG_V;
target-sh4/op_helper.c:            env->fpscr |= FPSCR_FLAG_Z;
target-sh4/op_helper.c:            env->fpscr |= FPSCR_FLAG_O;
target-sh4/op_helper.c:            env->fpscr |= FPSCR_FLAG_U;
target-sh4/op_helper.c:            env->fpscr |= FPSCR_FLAG_I;
target-sh4/op_helper.c:        env->fpscr |= (env->fpscr & FPSCR_FLAG_MASK)
target-sh4/op_helper.c:        cause = (env->fpscr & FPSCR_CAUSE_MASK) >> FPSCR_CAUSE_SHIFT;
target-sh4/op_helper.c:        enable = (env->fpscr & FPSCR_ENABLE_MASK) >> FPSCR_ENABLE_SHIFT;
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float32_add(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float64_add(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    relation = float32_compare(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    relation = float64_compare(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    relation = float32_compare(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    relation = float64_compare(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    ret = float32_to_float64(t0, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    ret = float64_to_float32(t0, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float32_div(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float64_div(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    ret = int32_to_float32(t0, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    ret = int32_to_float64(t0, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float32_muladd(t0, t1, t2, 0, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float32_mul(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float64_mul(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float32_sqrt(t0, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float64_sqrt(t0, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float32_sub(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float64_sub(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    ret = float32_to_int32_round_to_zero(t0, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    ret = float64_to_int32_round_to_zero(t0, &env->fp_status);
target-sh4/op_helper.c:    bank = (env->sr & FPSCR_FR) ? 16 : 0;
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:        p = float32_mul(env->fregs[bank + m + i],
target-sh4/op_helper.c:                        env->fregs[bank + n + i],
target-sh4/op_helper.c:                        &env->fp_status);
target-sh4/op_helper.c:        r = float32_add(r, p, &env->fp_status);
target-sh4/op_helper.c:    env->fregs[bank + n + 3] = r;
target-sh4/op_helper.c:    bank_matrix = (env->sr & FPSCR_FR) ? 0 : 16;
target-sh4/op_helper.c:    bank_vector = (env->sr & FPSCR_FR) ? 16 : 0;
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:            p = float32_mul(env->fregs[bank_matrix + 4 * j + i],
target-sh4/op_helper.c:                            env->fregs[bank_vector + j],
target-sh4/op_helper.c:                            &env->fp_status);
target-sh4/op_helper.c:            r[i] = float32_add(r[i], p, &env->fp_status);
target-sh4/op_helper.c:        env->fregs[bank_vector + i] = r[i];
target-arm/gdbstub.c:        return gdb_get_reg32(mem_buf, env->regs[n]);
target-arm/gdbstub.c:        env->regs[n] = tmp;
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =			\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =			\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =			\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =			\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =			\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] = NZBIT64(x >> 0);	\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =			\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =			\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] = NZBIT64(x >> 0);	\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =			\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =			\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =			\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =                                 \
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =                               \
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] = NZBIT64(x);
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] = NZBIT64(x);
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] = NZBIT64(x);
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] = NZBIT64(x);
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/arm-semi.c:        env->regs[0] = ret;
target-arm/arm-semi.c:        switch (env->regs[0]) {
target-arm/arm-semi.c:            env->regs[0] = arm_semi_syscall_len - ret;
target-arm/arm-semi.c:            env->regs[0] = 0;
target-arm/arm-semi.c:            env->regs[0] = ret;
target-arm/arm-semi.c:    cpu_memory_rw_debug(cs, env->regs[13]-64+32, (uint8_t *)&size, 4, 0);
target-arm/arm-semi.c:    env->regs[0] = be32_to_cpu(size);
target-arm/arm-semi.c:    nr = env->regs[0];
target-arm/arm-semi.c:    args = env->regs[1];
target-arm/arm-semi.c:            ret = env->regs[0];
target-arm/arm-semi.c:            return env->regs[0];
target-arm/arm-semi.c:                return env->regs[0];
target-arm/arm-semi.c:            ret = env->regs[0];
target-arm/arm-semi.c:            return env->regs[0];
target-arm/arm-semi.c:            return env->regs[0];
target-arm/arm-semi.c:            return env->regs[0];
target-arm/arm-semi.c:            return env->regs[0];
target-arm/arm-semi.c:                           arg0, env->regs[13]-64);
target-arm/arm-semi.c:            return env->regs[0];
target-arm/arm-semi.c:            ret = env->regs[0];
target-arm/arm-semi.c:            return env->regs[0];
target-arm/arm-semi.c:            return env->regs[0];
target-arm/gdbstub64.c:        return gdb_get_reg64(mem_buf, env->xregs[n]);
target-arm/gdbstub64.c:        return gdb_get_reg64(mem_buf, env->xregs[31]);
target-arm/gdbstub64.c:        return gdb_get_reg64(mem_buf, env->pc);
target-arm/gdbstub64.c:        env->xregs[n] = tmp;
target-arm/gdbstub64.c:        env->xregs[31] = tmp;
target-arm/gdbstub64.c:        env->pc = tmp;
target-arm/helper-a64.c:            uint64_t val = extract64(env->vfp.regs[elt], bitidx, 8);
target-arm/helper-a64.c:    float_status *fpst = &env->vfp.fp_status;
target-arm/helper-a64.c:    target_ulong addr = env->cp15.vbar_el[1];
target-arm/helper-a64.c:        if (env->aarch64) {
target-arm/helper-a64.c:                      env->exception.syndrome);
target-arm/helper-a64.c:    env->cp15.esr_el[1] = env->exception.syndrome;
target-arm/helper-a64.c:    env->cp15.far_el1 = env->exception.vaddress;
target-arm/helper-a64.c:                      env->cp15.far_el1);
target-arm/helper-a64.c:        env->banked_spsr[aarch64_banked_spsr_index(1)] = pstate_read(env);
target-arm/helper-a64.c:        env->sp_el[arm_current_pl(env)] = env->xregs[31];
target-arm/helper-a64.c:        env->xregs[31] = env->sp_el[1];
target-arm/helper-a64.c:        env->elr_el[1] = env->pc;
target-arm/helper-a64.c:        env->banked_spsr[0] = cpsr_read(env);
target-arm/helper-a64.c:        if (!env->thumb) {
target-arm/helper-a64.c:            env->cp15.esr_el[1] |= 1 << 25;
target-arm/helper-a64.c:        env->elr_el[1] = env->regs[15];
target-arm/helper-a64.c:            env->xregs[i] = env->regs[i];
target-arm/helper-a64.c:        env->condexec_bits = 0;
target-arm/helper-a64.c:    env->aarch64 = 1;
target-arm/helper-a64.c:    env->pc = addr;
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rm]),
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rm + 1])
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rd]),
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rd + 1])
target-arm/crypto_helper.c:    env->vfp.regs[rd] = make_float64(st.l[0]);
target-arm/crypto_helper.c:    env->vfp.regs[rd + 1] = make_float64(st.l[1]);
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rm]),
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rm + 1])
target-arm/crypto_helper.c:    env->vfp.regs[rd] = make_float64(st.l[0]);
target-arm/crypto_helper.c:    env->vfp.regs[rd + 1] = make_float64(st.l[1]);
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rd]),
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rd + 1])
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rn]),
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rn + 1])
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rm]),
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rm + 1])
target-arm/crypto_helper.c:    env->vfp.regs[rd] = make_float64(d.l[0]);
target-arm/crypto_helper.c:    env->vfp.regs[rd + 1] = make_float64(d.l[1]);
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rm]),
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rm + 1])
target-arm/crypto_helper.c:    env->vfp.regs[rd] = make_float64(m.l[0]);
target-arm/crypto_helper.c:    env->vfp.regs[rd + 1] = make_float64(m.l[1]);
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rd]),
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rd + 1])
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rm]),
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rm + 1])
target-arm/crypto_helper.c:    env->vfp.regs[rd] = make_float64(d.l[0]);
target-arm/crypto_helper.c:    env->vfp.regs[rd + 1] = make_float64(d.l[1]);
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rd]),
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rd + 1])
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rn]),
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rn + 1])
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rm]),
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rm + 1])
target-arm/crypto_helper.c:    env->vfp.regs[rd] = make_float64(d.l[0]);
target-arm/crypto_helper.c:    env->vfp.regs[rd + 1] = make_float64(d.l[1]);
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rd]),
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rd + 1])
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rn]),
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rn + 1])
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rm]),
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rm + 1])
target-arm/crypto_helper.c:    env->vfp.regs[rd] = make_float64(d.l[0]);
target-arm/crypto_helper.c:    env->vfp.regs[rd + 1] = make_float64(d.l[1]);
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rd]),
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rd + 1])
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rm]),
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rm + 1])
target-arm/crypto_helper.c:    env->vfp.regs[rd] = make_float64(d.l[0]);
target-arm/crypto_helper.c:    env->vfp.regs[rd + 1] = make_float64(d.l[1]);
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rd]),
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rd + 1])
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rn]),
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rn + 1])
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rm]),
target-arm/crypto_helper.c:        float64_val(env->vfp.regs[rm + 1])
target-arm/crypto_helper.c:    env->vfp.regs[rd] = make_float64(d.l[0]);
target-arm/crypto_helper.c:    env->vfp.regs[rd + 1] = make_float64(d.l[1]);
target-arm/translate.c:	    && ((env->cp15.c15_cpar ^ 0x3fff) & (1 << cpnum)))
target-arm/translate.c:    /* if (env->exclusive_addr == addr && env->exclusive_val == [addr]) {
target-arm/translate.c:                if (env->cp15.c15_cpar & (1 << 1))
target-arm/translate.c:    dc->features = env->features;
target-arm/translate.c:        cpu_fprintf(f, "R%02d=%08x", i, env->regs[i]);
target-arm/translate.c:            uint64_t v = float64_val(env->vfp.regs[i]);
target-arm/translate.c:        cpu_fprintf(f, "FPSCR: %08x\n", (int)env->vfp.xregs[ARM_VFP_FPSCR]);
target-arm/translate.c:        env->pc = tcg_ctx.gen_opc_pc[pc_pos];
target-arm/translate.c:        env->condexec_bits = 0;
target-arm/translate.c:        env->regs[15] = tcg_ctx.gen_opc_pc[pc_pos];
target-arm/translate.c:        env->condexec_bits = gen_opc_condexec_bits[pc_pos];
target-arm/kvm64.c:        reg.addr = (uintptr_t) &env->xregs[i];
target-arm/kvm64.c:    if (env->pstate & PSTATE_SP) {
target-arm/kvm64.c:        env->sp_el[1] = env->xregs[31];
target-arm/kvm64.c:        env->sp_el[0] = env->xregs[31];
target-arm/kvm64.c:    reg.addr = (uintptr_t) &env->sp_el[0];
target-arm/kvm64.c:    reg.addr = (uintptr_t) &env->sp_el[1];
target-arm/kvm64.c:    reg.addr = (uintptr_t) &env->pc;
target-arm/kvm64.c:    reg.addr = (uintptr_t) &env->elr_el[1];
target-arm/kvm64.c:        reg.addr = (uintptr_t) &env->banked_spsr[i - 1];
target-arm/kvm64.c:        reg.addr = (uintptr_t) &env->xregs[i];
target-arm/kvm64.c:    reg.addr = (uintptr_t) &env->sp_el[0];
target-arm/kvm64.c:    reg.addr = (uintptr_t) &env->sp_el[1];
target-arm/kvm64.c:    if (env->pstate & PSTATE_SP) {
target-arm/kvm64.c:        env->xregs[31] = env->sp_el[1];
target-arm/kvm64.c:        env->xregs[31] = env->sp_el[0];
target-arm/kvm64.c:    reg.addr = (uintptr_t) &env->pc;
target-arm/kvm64.c:    reg.addr = (uintptr_t) &env->elr_el[1];
target-arm/kvm64.c:        reg.addr = (uintptr_t) &env->banked_spsr[i - 1];
target-arm/kvm.c:    env->features = ahcc->features;
target-arm/cpu64.c:    env->features |= 1ULL << feature;
target-arm/helper.c:        stfq_le_p(buf, env->vfp.regs[reg]);
target-arm/helper.c:            stfq_le_p(buf, env->vfp.regs[(reg - 32) * 2]);
target-arm/helper.c:            stfq_le_p(buf + 8, env->vfp.regs[(reg - 32) * 2 + 1]);
target-arm/helper.c:    case 0: stl_p(buf, env->vfp.xregs[ARM_VFP_FPSID]); return 4;
target-arm/helper.c:    case 1: stl_p(buf, env->vfp.xregs[ARM_VFP_FPSCR]); return 4;
target-arm/helper.c:    case 2: stl_p(buf, env->vfp.xregs[ARM_VFP_FPEXC]); return 4;
target-arm/helper.c:        env->vfp.regs[reg] = ldfq_le_p(buf);
target-arm/helper.c:            env->vfp.regs[(reg - 32) * 2] = ldfq_le_p(buf);
target-arm/helper.c:            env->vfp.regs[(reg - 32) * 2 + 1] = ldfq_le_p(buf + 8);
target-arm/helper.c:    case 0: env->vfp.xregs[ARM_VFP_FPSID] = ldl_p(buf); return 4;
target-arm/helper.c:    case 1: env->vfp.xregs[ARM_VFP_FPSCR] = ldl_p(buf); return 4;
target-arm/helper.c:    case 2: env->vfp.xregs[ARM_VFP_FPEXC] = ldl_p(buf) & (1 << 30); return 4;
target-arm/helper.c:        stfq_le_p(buf, env->vfp.regs[reg * 2]);
target-arm/helper.c:        stfq_le_p(buf + 8, env->vfp.regs[reg * 2 + 1]);
target-arm/helper.c:        env->vfp.regs[reg * 2] = ldfq_le_p(buf);
target-arm/helper.c:        env->vfp.regs[reg * 2 + 1] = ldfq_le_p(buf + 8);
target-arm/helper.c:             && (env->cp15.c2_control & TTBCR_EAE)));
target-arm/helper.c:    env->cp15.c1_coproc = value;
target-arm/helper.c:    if (arm_current_pl(env) == 0 && !env->cp15.c9_pmuserenr) {
target-arm/helper.c:    if (env->cp15.c9_pmcr & PMCRE) {
target-arm/helper.c:        if (env->cp15.c9_pmcr & PMCRD) {
target-arm/helper.c:            env->cp15.c15_ccnt = (temp_ticks/64) - env->cp15.c15_ccnt;
target-arm/helper.c:            env->cp15.c15_ccnt = temp_ticks - env->cp15.c15_ccnt;
target-arm/helper.c:        env->cp15.c15_ccnt = 0;
target-arm/helper.c:    env->cp15.c9_pmcr &= ~0x39;
target-arm/helper.c:    env->cp15.c9_pmcr |= (value & 0x39);
target-arm/helper.c:    if (env->cp15.c9_pmcr & PMCRE) {
target-arm/helper.c:        if (env->cp15.c9_pmcr & PMCRD) {
target-arm/helper.c:        env->cp15.c15_ccnt = temp_ticks - env->cp15.c15_ccnt;
target-arm/helper.c:    if (!(env->cp15.c9_pmcr & PMCRE)) {
target-arm/helper.c:        return env->cp15.c15_ccnt;
target-arm/helper.c:    if (env->cp15.c9_pmcr & PMCRD) {
target-arm/helper.c:    return total_ticks - env->cp15.c15_ccnt;
target-arm/helper.c:    if (!(env->cp15.c9_pmcr & PMCRE)) {
target-arm/helper.c:        env->cp15.c15_ccnt = value;
target-arm/helper.c:    if (env->cp15.c9_pmcr & PMCRD) {
target-arm/helper.c:    env->cp15.c15_ccnt = total_ticks - value;
target-arm/helper.c:    env->cp15.c9_pmcnten |= value;
target-arm/helper.c:    env->cp15.c9_pmcnten &= ~value;
target-arm/helper.c:    env->cp15.c9_pmovsr &= ~value;
target-arm/helper.c:    env->cp15.c9_pmxevtyper = value & 0xff;
target-arm/helper.c:    env->cp15.c9_pmuserenr = value & 1;
target-arm/helper.c:    env->cp15.c9_pminten |= value;
target-arm/helper.c:    env->cp15.c9_pminten &= ~value;
target-arm/helper.c:    return cpu->ccsidr[env->cp15.c0_cssel];
target-arm/helper.c:    env->teecr = value;
target-arm/helper.c:    if (arm_current_pl(env) == 0 && (env->teecr & 1)) {
target-arm/helper.c:    if (arm_current_pl(env) == 0 && !extract32(env->cp15.c14_cntkctl, 0, 2)) {
target-arm/helper.c:        !extract32(env->cp15.c14_cntkctl, timeridx, 1)) {
target-arm/helper.c:        !extract32(env->cp15.c14_cntkctl, 9 - timeridx, 1)) {
target-arm/helper.c:    env->cp15.c14_timer[timeridx].cval = value;
target-arm/helper.c:    return (uint32_t)(env->cp15.c14_timer[timeridx].cval -
target-arm/helper.c:    env->cp15.c14_timer[timeridx].cval = gt_get_countervalue(env) +
target-arm/helper.c:    uint32_t oldval = env->cp15.c14_timer[timeridx].ctl;
target-arm/helper.c:    env->cp15.c14_timer[timeridx].ctl = deposit64(oldval, 0, 2, value);
target-arm/helper.c:        env->cp15.par_el1 = par64;
target-arm/helper.c:                env->cp15.par_el1 = (phys_addr & 0xff000000) | 1 << 1;
target-arm/helper.c:                env->cp15.par_el1 = phys_addr & 0xfffff000;
target-arm/helper.c:            env->cp15.par_el1 = ((ret & (1 << 10)) >> 5) |
target-arm/helper.c:    env->cp15.pmsav5_data_ap = extended_mpu_ap_bits(value);
target-arm/helper.c:    return simple_mpu_ap_bits(env->cp15.pmsav5_data_ap);
target-arm/helper.c:    env->cp15.pmsav5_insn_ap = extended_mpu_ap_bits(value);
target-arm/helper.c:    return simple_mpu_ap_bits(env->cp15.pmsav5_insn_ap);
target-arm/helper.c:    env->cp15.c2_mask = ~(((uint32_t)0xffffffffu) >> maskshift);
target-arm/helper.c:    env->cp15.c2_base_mask = ~((uint32_t)0x3fffu >> maskshift);
target-arm/helper.c:    env->cp15.c2_base_mask = 0xffffc000u;
target-arm/helper.c:    env->cp15.c2_mask = 0;
target-arm/helper.c:    env->cp15.c15_ticonfig = value & 0xe7;
target-arm/helper.c:    env->cp15.c0_cpuid = (value & (1 << 5)) ?
target-arm/helper.c:    env->cp15.c15_threadid = value & 0xffff;
target-arm/helper.c:    env->cp15.c15_i_max = 0x000;
target-arm/helper.c:    env->cp15.c15_i_min = 0xff0;
target-arm/helper.c:    if (env->cp15.c15_cpar != value) {
target-arm/helper.c:        env->cp15.c15_cpar = value;
target-arm/helper.c:    if (arm_current_pl(env) == 0 && !(env->cp15.c1_sys & SCTLR_UMA)) {
target-arm/helper.c:    env->daif = value & PSTATE_DAIF;
target-arm/helper.c:    if (arm_current_pl(env) == 0 && !(env->cp15.c1_sys & SCTLR_UCI)) {
target-arm/helper.c:    if (arm_current_pl(env) == 0 && !(env->cp15.c1_sys & SCTLR_DZE)) {
target-arm/helper.c:    if (!env->pstate & PSTATE_SP) {
target-arm/helper.c:    return env->pstate & PSTATE_SP;
target-arm/helper.c:    if (arm_current_pl(env) == 0 && !(env->cp15.c1_sys & SCTLR_UCT)) {
target-arm/helper.c:    ZF = (env->ZF == 0);
target-arm/helper.c:    return env->uncached_cpsr | (env->NF & 0x80000000) | (ZF << 30) |
target-arm/helper.c:        (env->CF << 29) | ((env->VF & 0x80000000) >> 3) | (env->QF << 27)
target-arm/helper.c:        | (env->thumb << 5) | ((env->condexec_bits & 3) << 25)
target-arm/helper.c:        | ((env->condexec_bits & 0xfc) << 8)
target-arm/helper.c:        | (env->GE << 16) | (env->daif & CPSR_AIF);
target-arm/helper.c:        env->ZF = (~val) & CPSR_Z;
target-arm/helper.c:        env->NF = val;
target-arm/helper.c:        env->CF = (val >> 29) & 1;
target-arm/helper.c:        env->VF = (val << 3) & 0x80000000;
target-arm/helper.c:        env->QF = ((val & CPSR_Q) != 0);
target-arm/helper.c:        env->thumb = ((val & CPSR_T) != 0);
target-arm/helper.c:        env->condexec_bits &= ~3;
target-arm/helper.c:        env->condexec_bits |= (val >> 25) & 3;
target-arm/helper.c:        env->condexec_bits &= 3;
target-arm/helper.c:        env->condexec_bits |= (val >> 8) & 0xfc;
target-arm/helper.c:        env->GE = (val >> 16) & 0xf;
target-arm/helper.c:    env->daif &= ~(CPSR_AIF & mask);
target-arm/helper.c:    env->daif |= val & CPSR_AIF & mask;
target-arm/helper.c:    if ((env->uncached_cpsr ^ val) & mask & CPSR_M) {
target-arm/helper.c:    env->uncached_cpsr = (env->uncached_cpsr & ~mask) | (val & mask);
target-arm/helper.c:    env->exception.vaddress = address;
target-arm/helper.c:    old_mode = env->uncached_cpsr & CPSR_M;
target-arm/helper.c:        memcpy (env->fiq_regs, env->regs + 8, 5 * sizeof(uint32_t));
target-arm/helper.c:        memcpy (env->regs + 8, env->usr_regs, 5 * sizeof(uint32_t));
target-arm/helper.c:        memcpy (env->usr_regs, env->regs + 8, 5 * sizeof(uint32_t));
target-arm/helper.c:        memcpy (env->regs + 8, env->fiq_regs, 5 * sizeof(uint32_t));
target-arm/helper.c:    env->banked_r13[i] = env->regs[13];
target-arm/helper.c:    env->banked_r14[i] = env->regs[14];
target-arm/helper.c:    env->banked_spsr[i] = env->spsr;
target-arm/helper.c:    env->regs[13] = env->banked_r13[i];
target-arm/helper.c:    env->regs[14] = env->banked_r14[i];
target-arm/helper.c:    env->spsr = env->banked_spsr[i];
target-arm/helper.c:    env->regs[13] -= 4;
target-arm/helper.c:    stl_phys(cs->as, env->regs[13], val);
target-arm/helper.c:    val = ldl_phys(cs->as, env->regs[13]);
target-arm/helper.c:    env->regs[13] += 4;
target-arm/helper.c:    if (env->v7m.current_sp != process) {
target-arm/helper.c:        tmp = env->v7m.other_sp;
target-arm/helper.c:        env->v7m.other_sp = env->regs[13];
target-arm/helper.c:        env->regs[13] = tmp;
target-arm/helper.c:        env->v7m.current_sp = process;
target-arm/helper.c:    type = env->regs[15];
target-arm/helper.c:    if (env->v7m.exception != 0)
target-arm/helper.c:        armv7m_nvic_complete_irq(env->nvic, env->v7m.exception);
target-arm/helper.c:    env->regs[0] = v7m_pop(env);
target-arm/helper.c:    env->regs[1] = v7m_pop(env);
target-arm/helper.c:    env->regs[2] = v7m_pop(env);
target-arm/helper.c:    env->regs[3] = v7m_pop(env);
target-arm/helper.c:    env->regs[12] = v7m_pop(env);
target-arm/helper.c:    env->regs[14] = v7m_pop(env);
target-arm/helper.c:    env->regs[15] = v7m_pop(env);
target-arm/helper.c:        env->regs[13] |= 4;
target-arm/helper.c:    if (env->v7m.current_sp)
target-arm/helper.c:    if (env->v7m.exception == 0)
target-arm/helper.c:        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_USAGE);
target-arm/helper.c:        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_SVC);
target-arm/helper.c:        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_MEM);
target-arm/helper.c:            nr = arm_lduw_code(env, env->regs[15], env->bswap_code) & 0xff;
target-arm/helper.c:                env->regs[15] += 2;
target-arm/helper.c:                env->regs[0] = do_arm_semihosting(env);
target-arm/helper.c:        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_DEBUG);
target-arm/helper.c:        env->v7m.exception = armv7m_nvic_acknowledge_irq(env->nvic);
target-arm/helper.c:    if (env->regs[13] & 4) {
target-arm/helper.c:        env->regs[13] -= 4;
target-arm/helper.c:    v7m_push(env, env->regs[15]);
target-arm/helper.c:    v7m_push(env, env->regs[14]);
target-arm/helper.c:    v7m_push(env, env->regs[12]);
target-arm/helper.c:    v7m_push(env, env->regs[3]);
target-arm/helper.c:    v7m_push(env, env->regs[2]);
target-arm/helper.c:    v7m_push(env, env->regs[1]);
target-arm/helper.c:    v7m_push(env, env->regs[0]);
target-arm/helper.c:    env->condexec_bits = 0;
target-arm/helper.c:    env->regs[14] = lr;
target-arm/helper.c:    addr = ldl_phys(cs->as, env->v7m.vecbase + env->v7m.exception * 4);
target-arm/helper.c:    env->regs[15] = addr & 0xfffffffe;
target-arm/helper.c:    env->thumb = addr & 1;
target-arm/helper.c:        if (env->thumb)
target-arm/helper.c:            if (env->thumb) {
target-arm/helper.c:                mask = arm_lduw_code(env, env->regs[15] - 2, env->bswap_code)
target-arm/helper.c:                mask = arm_ldl_code(env, env->regs[15] - 4, env->bswap_code)
target-arm/helper.c:            if (((mask == 0x123456 && !env->thumb)
target-arm/helper.c:                    || (mask == 0xab && env->thumb))
target-arm/helper.c:                  && (env->uncached_cpsr & CPSR_M) != ARM_CPU_MODE_USR) {
target-arm/helper.c:                env->regs[0] = do_arm_semihosting(env);
target-arm/helper.c:        if (env->thumb && semihosting_enabled) {
target-arm/helper.c:            mask = arm_lduw_code(env, env->regs[15], env->bswap_code) & 0xff;
target-arm/helper.c:                  && (env->uncached_cpsr & CPSR_M) != ARM_CPU_MODE_USR) {
target-arm/helper.c:                env->regs[15] += 2;
target-arm/helper.c:                env->regs[0] = do_arm_semihosting(env);
target-arm/helper.c:        env->exception.fsr = 2;
target-arm/helper.c:        env->cp15.ifsr_el2 = env->exception.fsr;
target-arm/helper.c:        env->cp15.far_el1 = deposit64(env->cp15.far_el1, 32, 32,
target-arm/helper.c:                                      env->exception.vaddress);
target-arm/helper.c:                      env->cp15.ifsr_el2, (uint32_t)env->exception.vaddress);
target-arm/helper.c:        env->cp15.esr_el[1] = env->exception.fsr;
target-arm/helper.c:        env->cp15.far_el1 = deposit64(env->cp15.far_el1, 0, 32,
target-arm/helper.c:                                      env->exception.vaddress);
target-arm/helper.c:                      (uint32_t)env->cp15.esr_el[1],
target-arm/helper.c:                      (uint32_t)env->exception.vaddress);
target-arm/helper.c:    if (env->cp15.c1_sys & SCTLR_V) {
target-arm/helper.c:        addr += env->cp15.vbar_el[1];
target-arm/helper.c:    env->spsr = cpsr_read(env);
target-arm/helper.c:    env->condexec_bits = 0;
target-arm/helper.c:    env->uncached_cpsr = (env->uncached_cpsr & ~CPSR_M) | new_mode;
target-arm/helper.c:    env->daif |= mask;
target-arm/helper.c:        env->thumb = (env->cp15.c1_sys & SCTLR_TE) != 0;
target-arm/helper.c:    env->regs[14] = env->regs[15] + offset;
target-arm/helper.c:    env->regs[15] = addr;
target-arm/helper.c:      switch (env->cp15.c1_sys & (SCTLR_S | SCTLR_R)) {
target-arm/helper.c:    if (address & env->cp15.c2_mask) {
target-arm/helper.c:        if ((env->cp15.c2_control & TTBCR_PD1)) {
target-arm/helper.c:        *table = env->cp15.ttbr1_el1 & 0xffffc000;
target-arm/helper.c:        if ((env->cp15.c2_control & TTBCR_PD0)) {
target-arm/helper.c:        *table = env->cp15.ttbr0_el1 & env->cp15.c2_base_mask;
target-arm/helper.c:    domain_prot = (env->cp15.c3 >> (domain * 2)) & 3;
target-arm/helper.c:    domain_prot = (env->cp15.c3 >> (domain * 2)) & 3;
target-arm/helper.c:        if ((env->cp15.c1_sys & SCTLR_AFE) && (ap & 1) == 0) {
target-arm/helper.c:            tbi = extract64(env->cp15.c2_control, 38, 1);
target-arm/helper.c:            tbi = extract64(env->cp15.c2_control, 37, 1);
target-arm/helper.c:    uint32_t t0sz = extract32(env->cp15.c2_control, 0, 6);
target-arm/helper.c:    uint32_t t1sz = extract32(env->cp15.c2_control, 16, 6);
target-arm/helper.c:        ttbr = env->cp15.ttbr0_el1;
target-arm/helper.c:        epd = extract32(env->cp15.c2_control, 7, 1);
target-arm/helper.c:        tg = extract32(env->cp15.c2_control, 14, 2);
target-arm/helper.c:        ttbr = env->cp15.ttbr1_el1;
target-arm/helper.c:        epd = extract32(env->cp15.c2_control, 23, 1);
target-arm/helper.c:        tg = extract32(env->cp15.c2_control, 30, 2);
target-arm/helper.c:	base = env->cp15.c6_region[n];
target-arm/helper.c:        mask = env->cp15.pmsav5_insn_ap;
target-arm/helper.c:        mask = env->cp15.pmsav5_data_ap;
target-arm/helper.c:        address += env->cp15.c13_fcse;
target-arm/helper.c:    if ((env->cp15.c1_sys & SCTLR_M) == 0) {
target-arm/helper.c:    } else if (env->cp15.c1_sys & SCTLR_XP) {
target-arm/helper.c:    env->exception.syndrome = syn;
target-arm/helper.c:    env->exception.vaddress = address;
target-arm/helper.c:    env->exception.fsr = ret;
target-arm/helper.c:    if ((env->uncached_cpsr & CPSR_M) == mode) {
target-arm/helper.c:        env->regs[13] = val;
target-arm/helper.c:        env->banked_r13[bank_number(mode)] = val;
target-arm/helper.c:    if ((env->uncached_cpsr & CPSR_M) == mode) {
target-arm/helper.c:        return env->regs[13];
target-arm/helper.c:        return env->banked_r13[bank_number(mode)];
target-arm/helper.c:        return env->v7m.current_sp ? env->v7m.other_sp : env->regs[13];
target-arm/helper.c:        return env->v7m.current_sp ? env->regs[13] : env->v7m.other_sp;
target-arm/helper.c:        return (env->daif & PSTATE_I) != 0;
target-arm/helper.c:        return env->v7m.basepri;
target-arm/helper.c:        return (env->daif & PSTATE_F) != 0;
target-arm/helper.c:        return env->v7m.control;
target-arm/helper.c:        if (env->v7m.current_sp)
target-arm/helper.c:            env->v7m.other_sp = val;
target-arm/helper.c:            env->regs[13] = val;
target-arm/helper.c:        if (env->v7m.current_sp)
target-arm/helper.c:            env->regs[13] = val;
target-arm/helper.c:            env->v7m.other_sp = val;
target-arm/helper.c:            env->daif |= PSTATE_I;
target-arm/helper.c:            env->daif &= ~PSTATE_I;
target-arm/helper.c:        env->v7m.basepri = val & 0xff;
target-arm/helper.c:        if (val != 0 && (val < env->v7m.basepri || env->v7m.basepri == 0))
target-arm/helper.c:            env->v7m.basepri = val;
target-arm/helper.c:            env->daif |= PSTATE_F;
target-arm/helper.c:            env->daif &= ~PSTATE_F;
target-arm/helper.c:        env->v7m.control = val & 3;
target-arm/helper.c:    fpscr = (env->vfp.xregs[ARM_VFP_FPSCR] & 0xffc8ffff)
target-arm/helper.c:            | (env->vfp.vec_len << 16)
target-arm/helper.c:            | (env->vfp.vec_stride << 20);
target-arm/helper.c:    i = get_float_exception_flags(&env->vfp.fp_status);
target-arm/helper.c:    i |= get_float_exception_flags(&env->vfp.standard_fp_status);
target-arm/helper.c:    changed = env->vfp.xregs[ARM_VFP_FPSCR];
target-arm/helper.c:    env->vfp.xregs[ARM_VFP_FPSCR] = (val & 0xffc8ffff);
target-arm/helper.c:    env->vfp.vec_len = (val >> 16) & 7;
target-arm/helper.c:    env->vfp.vec_stride = (val >> 20) & 3;
target-arm/helper.c:        set_float_rounding_mode(i, &env->vfp.fp_status);
target-arm/helper.c:        set_flush_to_zero((val & (1 << 24)) != 0, &env->vfp.fp_status);
target-arm/helper.c:        set_flush_inputs_to_zero((val & (1 << 24)) != 0, &env->vfp.fp_status);
target-arm/helper.c:        set_default_nan_mode((val & (1 << 25)) != 0, &env->vfp.fp_status);
target-arm/helper.c:    set_float_exception_flags(i, &env->vfp.fp_status);
target-arm/helper.c:    set_float_exception_flags(0, &env->vfp.standard_fp_status);
target-arm/helper.c:    return float32_sqrt(a, &env->vfp.fp_status);
target-arm/helper.c:    return float64_sqrt(a, &env->vfp.fp_status);
target-arm/helper.c:    switch(type ## _compare_quiet(a, b, &env->vfp.fp_status)) { \
target-arm/helper.c:    env->vfp.xregs[ARM_VFP_FPSCR] = (flags << 28) \
target-arm/helper.c:        | (env->vfp.xregs[ARM_VFP_FPSCR] & 0x0fffffff); \
target-arm/helper.c:    switch(type ## _compare(a, b, &env->vfp.fp_status)) { \
target-arm/helper.c:    env->vfp.xregs[ARM_VFP_FPSCR] = (flags << 28) \
target-arm/helper.c:        | (env->vfp.xregs[ARM_VFP_FPSCR] & 0x0fffffff); \
target-arm/helper.c:    float64 r = float32_to_float64(x, &env->vfp.fp_status);
target-arm/helper.c:    float32 r =  float64_to_float32(x, &env->vfp.fp_status);
target-arm/helper.c:    float_status *fp_status = &env->vfp.fp_status;
target-arm/helper.c:    float_status *fp_status = &env->vfp.standard_fp_status;
target-arm/helper.c:    int ieee = (env->vfp.xregs[ARM_VFP_FPSCR] & (1 << 26)) == 0;
target-arm/helper.c:    int ieee = (env->vfp.xregs[ARM_VFP_FPSCR] & (1 << 26)) == 0;
target-arm/helper.c:    return do_fcvt_f16_to_f32(a, env, &env->vfp.standard_fp_status);
target-arm/helper.c:    return do_fcvt_f32_to_f16(a, env, &env->vfp.standard_fp_status);
target-arm/helper.c:    return do_fcvt_f16_to_f32(a, env, &env->vfp.fp_status);
target-arm/helper.c:    return do_fcvt_f32_to_f16(a, env, &env->vfp.fp_status);
target-arm/helper.c:    int ieee = (env->vfp.xregs[ARM_VFP_FPSCR] & (1 << 26)) == 0;
target-arm/helper.c:    float64 r = float16_to_float64(make_float16(a), ieee, &env->vfp.fp_status);
target-arm/helper.c:    int ieee = (env->vfp.xregs[ARM_VFP_FPSCR] & (1 << 26)) == 0;
target-arm/helper.c:    float16 r = float64_to_float16(a, ieee, &env->vfp.fp_status);
target-arm/helper.c:    float_status *s = &env->vfp.standard_fp_status;
target-arm/helper.c:    float_status *s = &env->vfp.standard_fp_status;
target-arm/machine.c:    env->uncached_cpsr = val & CPSR_M;
target-arm/cpu.h:     *  NZCV are kept in the split out env->CF/VF/NF/ZF, (which have the same
target-arm/cpu.h:     *  nRW (also known as M[4]) is kept, inverted, in env->aarch64
target-arm/cpu.h:     *  DAIF (exception masks) are kept in env->daif
target-arm/cpu.h:     *  all other bits are stored in their correct places in env->pstate
target-arm/cpu.h:    return env->aarch64;
target-arm/cpu.h:    ZF = (env->ZF == 0);
target-arm/cpu.h:    return (env->NF & 0x80000000) | (ZF << 30)
target-arm/cpu.h:        | (env->CF << 29) | ((env->VF & 0x80000000) >> 3)
target-arm/cpu.h:        | env->pstate | env->daif;
target-arm/cpu.h:    env->ZF = (~val) & PSTATE_Z;
target-arm/cpu.h:    env->NF = val;
target-arm/cpu.h:    env->CF = (val >> 29) & 1;
target-arm/cpu.h:    env->VF = (val << 3) & 0x80000000;
target-arm/cpu.h:    env->daif = val & PSTATE_DAIF;
target-arm/cpu.h:    env->pstate = val & ~CACHED_PSTATE_BITS;
target-arm/cpu.h:    ZF = (env->ZF == 0);
target-arm/cpu.h:    return (env->NF & 0x80000000) | (ZF << 30)
target-arm/cpu.h:        | (env->CF << 29) | ((env->VF & 0x80000000) >> 3) | (env->QF << 27)
target-arm/cpu.h:        | (env->thumb << 24) | ((env->condexec_bits & 3) << 25)
target-arm/cpu.h:        | ((env->condexec_bits & 0xfc) << 8)
target-arm/cpu.h:        | env->v7m.exception;
target-arm/cpu.h:        env->ZF = (~val) & CPSR_Z;
target-arm/cpu.h:        env->NF = val;
target-arm/cpu.h:        env->CF = (val >> 29) & 1;
target-arm/cpu.h:        env->VF = (val << 3) & 0x80000000;
target-arm/cpu.h:        env->QF = ((val & CPSR_Q) != 0);
target-arm/cpu.h:        env->thumb = ((val & (1 << 24)) != 0);
target-arm/cpu.h:        env->condexec_bits &= ~3;
target-arm/cpu.h:        env->condexec_bits |= (val >> 25) & 3;
target-arm/cpu.h:        env->condexec_bits &= 3;
target-arm/cpu.h:        env->condexec_bits |= (val >> 8) & 0xfc;
target-arm/cpu.h:        env->v7m.exception = val & 0x1ff;
target-arm/cpu.h:    return (env->features & (1ULL << feature)) != 0;
target-arm/cpu.h:    if (env->aarch64) {
target-arm/cpu.h:        return extract32(env->pstate, 2, 2);
target-arm/cpu.h:    if ((env->uncached_cpsr & 0x1f) == ARM_CPU_MODE_USR) {
target-arm/cpu.h:        fpen = extract32(env->cp15.c1_coproc, 20, 2);
target-arm/cpu.h:        *pc = env->pc;
target-arm/cpu.h:        *pc = env->regs[15];
target-arm/cpu.h:        *flags = (env->thumb << ARM_TBFLAG_THUMB_SHIFT)
target-arm/cpu.h:            | (env->vfp.vec_len << ARM_TBFLAG_VECLEN_SHIFT)
target-arm/cpu.h:            | (env->vfp.vec_stride << ARM_TBFLAG_VECSTRIDE_SHIFT)
target-arm/cpu.h:            | (env->condexec_bits << ARM_TBFLAG_CONDEXEC_SHIFT)
target-arm/cpu.h:            | (env->bswap_code << ARM_TBFLAG_BSWAP_CODE_SHIFT);
target-arm/cpu.h:            privmode = !((env->v7m.exception == 0) && (env->v7m.control & 1));
target-arm/cpu.h:            privmode = (env->uncached_cpsr & CPSR_M) != ARM_CPU_MODE_USR;
target-arm/cpu.h:        if (env->vfp.xregs[ARM_VFP_FPEXC] & (1 << 30)
target-arm/cpu.h:        env->pc = tb->pc;
target-arm/cpu.h:        env->regs[15] = tb->pc;
target-arm/neon_helper.c:#define SET_QC() env->vfp.xregs[ARM_VFP_FPSCR] |= CPSR_Q
target-arm/neon_helper.c:    uint64_t zm0 = float64_val(env->vfp.regs[rm]);
target-arm/neon_helper.c:    uint64_t zm1 = float64_val(env->vfp.regs[rm + 1]);
target-arm/neon_helper.c:    uint64_t zd0 = float64_val(env->vfp.regs[rd]);
target-arm/neon_helper.c:    uint64_t zd1 = float64_val(env->vfp.regs[rd + 1]);
target-arm/neon_helper.c:    env->vfp.regs[rm] = make_float64(m0);
target-arm/neon_helper.c:    env->vfp.regs[rm + 1] = make_float64(m1);
target-arm/neon_helper.c:    env->vfp.regs[rd] = make_float64(d0);
target-arm/neon_helper.c:    env->vfp.regs[rd + 1] = make_float64(d1);
target-arm/neon_helper.c:    uint64_t zm0 = float64_val(env->vfp.regs[rm]);
target-arm/neon_helper.c:    uint64_t zm1 = float64_val(env->vfp.regs[rm + 1]);
target-arm/neon_helper.c:    uint64_t zd0 = float64_val(env->vfp.regs[rd]);
target-arm/neon_helper.c:    uint64_t zd1 = float64_val(env->vfp.regs[rd + 1]);
target-arm/neon_helper.c:    env->vfp.regs[rm] = make_float64(m0);
target-arm/neon_helper.c:    env->vfp.regs[rm + 1] = make_float64(m1);
target-arm/neon_helper.c:    env->vfp.regs[rd] = make_float64(d0);
target-arm/neon_helper.c:    env->vfp.regs[rd + 1] = make_float64(d1);
target-arm/neon_helper.c:    uint64_t zm0 = float64_val(env->vfp.regs[rm]);
target-arm/neon_helper.c:    uint64_t zm1 = float64_val(env->vfp.regs[rm + 1]);
target-arm/neon_helper.c:    uint64_t zd0 = float64_val(env->vfp.regs[rd]);
target-arm/neon_helper.c:    uint64_t zd1 = float64_val(env->vfp.regs[rd + 1]);
target-arm/neon_helper.c:    env->vfp.regs[rm] = make_float64(m0);
target-arm/neon_helper.c:    env->vfp.regs[rm + 1] = make_float64(m1);
target-arm/neon_helper.c:    env->vfp.regs[rd] = make_float64(d0);
target-arm/neon_helper.c:    env->vfp.regs[rd + 1] = make_float64(d1);
target-arm/neon_helper.c:    uint64_t zm = float64_val(env->vfp.regs[rm]);
target-arm/neon_helper.c:    uint64_t zd = float64_val(env->vfp.regs[rd]);
target-arm/neon_helper.c:    env->vfp.regs[rm] = make_float64(m0);
target-arm/neon_helper.c:    env->vfp.regs[rd] = make_float64(d0);
target-arm/neon_helper.c:    uint64_t zm = float64_val(env->vfp.regs[rm]);
target-arm/neon_helper.c:    uint64_t zd = float64_val(env->vfp.regs[rd]);
target-arm/neon_helper.c:    env->vfp.regs[rm] = make_float64(m0);
target-arm/neon_helper.c:    env->vfp.regs[rd] = make_float64(d0);
target-arm/neon_helper.c:    uint64_t zm0 = float64_val(env->vfp.regs[rm]);
target-arm/neon_helper.c:    uint64_t zm1 = float64_val(env->vfp.regs[rm + 1]);
target-arm/neon_helper.c:    uint64_t zd0 = float64_val(env->vfp.regs[rd]);
target-arm/neon_helper.c:    uint64_t zd1 = float64_val(env->vfp.regs[rd + 1]);
target-arm/neon_helper.c:    env->vfp.regs[rm] = make_float64(m0);
target-arm/neon_helper.c:    env->vfp.regs[rm + 1] = make_float64(m1);
target-arm/neon_helper.c:    env->vfp.regs[rd] = make_float64(d0);
target-arm/neon_helper.c:    env->vfp.regs[rd + 1] = make_float64(d1);
target-arm/neon_helper.c:    uint64_t zm0 = float64_val(env->vfp.regs[rm]);
target-arm/neon_helper.c:    uint64_t zm1 = float64_val(env->vfp.regs[rm + 1]);
target-arm/neon_helper.c:    uint64_t zd0 = float64_val(env->vfp.regs[rd]);
target-arm/neon_helper.c:    uint64_t zd1 = float64_val(env->vfp.regs[rd + 1]);
target-arm/neon_helper.c:    env->vfp.regs[rm] = make_float64(m0);
target-arm/neon_helper.c:    env->vfp.regs[rm + 1] = make_float64(m1);
target-arm/neon_helper.c:    env->vfp.regs[rd] = make_float64(d0);
target-arm/neon_helper.c:    env->vfp.regs[rd + 1] = make_float64(d1);
target-arm/neon_helper.c:    uint64_t zm0 = float64_val(env->vfp.regs[rm]);
target-arm/neon_helper.c:    uint64_t zm1 = float64_val(env->vfp.regs[rm + 1]);
target-arm/neon_helper.c:    uint64_t zd0 = float64_val(env->vfp.regs[rd]);
target-arm/neon_helper.c:    uint64_t zd1 = float64_val(env->vfp.regs[rd + 1]);
target-arm/neon_helper.c:    env->vfp.regs[rm] = make_float64(m0);
target-arm/neon_helper.c:    env->vfp.regs[rm + 1] = make_float64(m1);
target-arm/neon_helper.c:    env->vfp.regs[rd] = make_float64(d0);
target-arm/neon_helper.c:    env->vfp.regs[rd + 1] = make_float64(d1);
target-arm/neon_helper.c:    uint64_t zm = float64_val(env->vfp.regs[rm]);
target-arm/neon_helper.c:    uint64_t zd = float64_val(env->vfp.regs[rd]);
target-arm/neon_helper.c:    env->vfp.regs[rm] = make_float64(m0);
target-arm/neon_helper.c:    env->vfp.regs[rd] = make_float64(d0);
target-arm/neon_helper.c:    uint64_t zm = float64_val(env->vfp.regs[rm]);
target-arm/neon_helper.c:    uint64_t zd = float64_val(env->vfp.regs[rd]);
target-arm/neon_helper.c:    env->vfp.regs[rm] = make_float64(m0);
target-arm/neon_helper.c:    env->vfp.regs[rd] = make_float64(d0);
target-arm/kvm32.c:    mode = env->uncached_cpsr & CPSR_M;
target-arm/kvm32.c:        memcpy(env->fiq_regs, env->regs + 8, 5 * sizeof(uint32_t));
target-arm/kvm32.c:        memcpy(env->usr_regs, env->regs + 8, 5 * sizeof(uint32_t));
target-arm/kvm32.c:    env->banked_r13[bn] = env->regs[13];
target-arm/kvm32.c:    env->banked_r14[bn] = env->regs[14];
target-arm/kvm32.c:    env->banked_spsr[bn] = env->spsr;
target-arm/kvm32.c:        r.addr = (uintptr_t)(&env->vfp.regs[i]);
target-arm/kvm32.c:    mode = env->uncached_cpsr & CPSR_M;
target-arm/kvm32.c:        memcpy(env->regs + 8, env->fiq_regs, 5 * sizeof(uint32_t));
target-arm/kvm32.c:        memcpy(env->regs + 8, env->usr_regs, 5 * sizeof(uint32_t));
target-arm/kvm32.c:    env->regs[13] = env->banked_r13[bn];
target-arm/kvm32.c:    env->regs[14] = env->banked_r14[bn];
target-arm/kvm32.c:    env->spsr = env->banked_spsr[bn];
target-arm/kvm32.c:        r.addr = (uintptr_t)(&env->vfp.regs[i]);
target-arm/translate-a64.c:            env->pc, env->xregs[31]);
target-arm/translate-a64.c:        cpu_fprintf(f, "X%02d=%016"PRIx64, i, env->xregs[i]);
target-arm/translate-a64.c:            uint64_t vlo = float64_val(env->vfp.regs[i * 2]);
target-arm/translate-a64.c:            uint64_t vhi = float64_val(env->vfp.regs[(i * 2) + 1]);
target-arm/translate-a64.c:            vlo = float64_val(env->vfp.regs[(i + 1) * 2]);
target-arm/translate-a64.c:            vhi = float64_val(env->vfp.regs[((i + 1) * 2) + 1]);
target-arm/translate-a64.c:    /* if (env->exclusive_addr == addr && env->exclusive_val == [addr]
target-arm/translate-a64.c:     *     && (!is_pair || env->exclusive_high == [addr + datasize])) {
target-arm/translate-a64.c:     * env->exclusive_addr = -1;
target-arm/translate-a64.c:    dc->features = env->features;
target-arm/cpu.c:    env->vfp.xregs[ARM_VFP_FPSID] = cpu->reset_fpsid;
target-arm/cpu.c:    env->vfp.xregs[ARM_VFP_MVFR0] = cpu->mvfr0;
target-arm/cpu.c:    env->vfp.xregs[ARM_VFP_MVFR1] = cpu->mvfr1;
target-arm/cpu.c:    env->vfp.xregs[ARM_VFP_MVFR2] = cpu->mvfr2;
target-arm/cpu.c:        env->iwmmxt.cregs[ARM_IWMMXT_wCID] = 0x69051000 | 'Q';
target-arm/cpu.c:        env->aarch64 = 1;
target-arm/cpu.c:        env->pstate = PSTATE_MODE_EL0t;
target-arm/cpu.c:        env->cp15.c1_sys |= SCTLR_UCT | SCTLR_UCI;
target-arm/cpu.c:        env->cp15.c1_coproc = deposit64(env->cp15.c1_coproc, 20, 2, 3);
target-arm/cpu.c:        env->pstate = PSTATE_MODE_EL1h;
target-arm/cpu.c:        env->pc = cpu->rvbar;
target-arm/cpu.c:        env->cp15.c1_coproc = deposit64(env->cp15.c1_coproc, 20, 4, 0xf);
target-arm/cpu.c:    env->uncached_cpsr = ARM_CPU_MODE_USR;
target-arm/cpu.c:    env->vfp.xregs[ARM_VFP_FPEXC] = 1 << 30;
target-arm/cpu.c:        env->cp15.c15_cpar = 3;
target-arm/cpu.c:        env->cp15.c15_cpar = 1;
target-arm/cpu.c:    env->uncached_cpsr = ARM_CPU_MODE_SVC;
target-arm/cpu.c:    env->daif = PSTATE_D | PSTATE_A | PSTATE_I | PSTATE_F;
target-arm/cpu.c:        env->daif &= ~PSTATE_I;
target-arm/cpu.c:            env->regs[13] = ldl_p(rom) & 0xFFFFFFFC;
target-arm/cpu.c:            env->thumb = pc & 1;
target-arm/cpu.c:            env->regs[15] = pc & ~1;
target-arm/cpu.c:    if (env->cp15.c1_sys & SCTLR_V) {
target-arm/cpu.c:            env->regs[15] = 0xFFFF0000;
target-arm/cpu.c:    env->vfp.xregs[ARM_VFP_FPEXC] = 0;
target-arm/cpu.c:    set_flush_to_zero(1, &env->vfp.standard_fp_status);
target-arm/cpu.c:    set_flush_inputs_to_zero(1, &env->vfp.standard_fp_status);
target-arm/cpu.c:    set_default_nan_mode(1, &env->vfp.standard_fp_status);
target-arm/cpu.c:                              &env->vfp.fp_status);
target-arm/cpu.c:                              &env->vfp.standard_fp_status);
target-arm/cpu.c:    env->features |= 1ULL << feature;
target-arm/op_helper.c:    table = (uint64_t *)&env->vfp.regs[rn];
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:    env->exception.syndrome = syndrome;
target-arm/op_helper.c:        val = env->banked_r13[0];
target-arm/op_helper.c:        val = env->banked_r14[0];
target-arm/op_helper.c:               && (env->uncached_cpsr & 0x1f) == ARM_CPU_MODE_FIQ) {
target-arm/op_helper.c:        val = env->usr_regs[regno - 8];
target-arm/op_helper.c:        val = env->regs[regno];
target-arm/op_helper.c:        env->banked_r13[0] = val;
target-arm/op_helper.c:        env->banked_r14[0] = val;
target-arm/op_helper.c:               && (env->uncached_cpsr & 0x1f) == ARM_CPU_MODE_FIQ) {
target-arm/op_helper.c:        env->usr_regs[regno - 8] = val;
target-arm/op_helper.c:        env->regs[regno] = val;
target-arm/op_helper.c:        env->exception.syndrome = syndrome;
target-arm/op_helper.c:        env->exception.syndrome = syn_uncategorized();
target-arm/op_helper.c:    if (arm_current_pl(env) == 0 && !(env->cp15.c1_sys & SCTLR_UMA)) {
target-arm/op_helper.c:        env->daif |= (imm << 6) & PSTATE_DAIF;
target-arm/op_helper.c:        env->daif &= ~((imm << 6) & PSTATE_DAIF);
target-arm/op_helper.c:    uint32_t spsr = env->banked_spsr[spsr_idx];
target-arm/op_helper.c:    if (env->pstate & PSTATE_SP) {
target-arm/op_helper.c:        env->sp_el[cur_el] = env->xregs[31];
target-arm/op_helper.c:        env->sp_el[0] = env->xregs[31];
target-arm/op_helper.c:    env->exclusive_addr = -1;
target-arm/op_helper.c:        env->aarch64 = 0;
target-arm/op_helper.c:        env->uncached_cpsr = 0x10;
target-arm/op_helper.c:            env->regs[i] = env->xregs[i];
target-arm/op_helper.c:        env->regs[15] = env->elr_el[1] & ~0x1;
target-arm/op_helper.c:        env->aarch64 = 1;
target-arm/op_helper.c:        env->xregs[31] = env->sp_el[new_el];
target-arm/op_helper.c:        env->pc = env->elr_el[cur_el];
target-arm/op_helper.c:    env->pstate |= PSTATE_IL;
target-arm/op_helper.c:    env->pc = env->elr_el[cur_el];
target-arm/op_helper.c:            env->CF = x & 1;
target-arm/op_helper.c:            env->CF = 0;
target-arm/op_helper.c:        env->CF = (x >> (32 - shift)) & 1;
target-arm/op_helper.c:            env->CF = (x >> 31) & 1;
target-arm/op_helper.c:            env->CF = 0;
target-arm/op_helper.c:        env->CF = (x >> (shift - 1)) & 1;
target-arm/op_helper.c:        env->CF = (x >> 31) & 1;
target-arm/op_helper.c:        env->CF = (x >> (shift - 1)) & 1;
target-arm/op_helper.c:            env->CF = (x >> 31) & 1;
target-arm/op_helper.c:        env->CF = (x >> (shift - 1)) & 1;
target-arm/internals.h:    if (!((imm ^ env->pstate) & PSTATE_SP)) {
target-arm/internals.h:    env->pstate = deposit32(env->pstate, 0, 1, imm);
target-arm/internals.h:    if (env->pstate & PSTATE_SP) {
target-arm/internals.h:        env->sp_el[0] = env->xregs[31];
target-arm/internals.h:        env->xregs[31] = env->sp_el[cur_el];
target-arm/internals.h:        env->sp_el[cur_el] = env->xregs[31];
target-arm/internals.h:        env->xregs[31] = env->sp_el[0];
target-s390x/gdbstub.c:        cc_op = calc_cc(env, env->cc_op, env->cc_src, env->cc_dst, env->cc_vr);
target-s390x/gdbstub.c:        val = deposit64(env->psw.mask, 44, 2, cc_op);
target-s390x/gdbstub.c:        return gdb_get_regl(mem_buf, env->psw.addr);
target-s390x/gdbstub.c:        return gdb_get_regl(mem_buf, env->regs[n-S390_R0_REGNUM]);
target-s390x/gdbstub.c:        return gdb_get_reg32(mem_buf, env->aregs[n-S390_A0_REGNUM]);
target-s390x/gdbstub.c:        return gdb_get_reg32(mem_buf, env->fpc);
target-s390x/gdbstub.c:        return gdb_get_reg64(mem_buf, env->fregs[n-S390_F0_REGNUM].ll);
target-s390x/gdbstub.c:        env->psw.mask = tmpl;
target-s390x/gdbstub.c:        env->cc_op = extract64(tmpl, 44, 2);
target-s390x/gdbstub.c:        env->psw.addr = tmpl;
target-s390x/gdbstub.c:        env->regs[n-S390_R0_REGNUM] = tmpl;
target-s390x/gdbstub.c:        env->aregs[n-S390_A0_REGNUM] = tmp32;
target-s390x/gdbstub.c:        env->fpc = tmp32;
target-s390x/gdbstub.c:        env->fregs[n-S390_F0_REGNUM].ll = tmpl;
target-s390x/interrupt.c:        env->psw.addr += 4;
target-s390x/ioinst.c:    addr = env->regs[reg];
target-s390x/mem_helper.c:    uint64_t asc = env->psw.mask & PSW_MASK_ASC;
target-s390x/mem_helper.c:    uint64_t asc = env->psw.mask & PSW_MASK_ASC;
target-s390x/mem_helper.c:    if (!(env->psw.mask & PSW_MASK_64)) {
target-s390x/mem_helper.c:        r += env->regs[x2];
target-s390x/mem_helper.c:        r += env->regs[b2];
target-s390x/mem_helper.c:    return fix_address(env, env->regs[reg]);
target-s390x/mem_helper.c:    env->retxl = str;
target-s390x/mem_helper.c:            env->cc_op = 2;
target-s390x/mem_helper.c:            env->cc_op = 1;
target-s390x/mem_helper.c:    env->retxl = str + len;
target-s390x/mem_helper.c:    env->cc_op = 3;
target-s390x/mem_helper.c:                env->cc_op = 0;
target-s390x/mem_helper.c:                env->retxl = s2;
target-s390x/mem_helper.c:            env->cc_op = (v1 == c ? 1 : v2 == c ? 2 : v1 < v2 ? 1 : 2);
target-s390x/mem_helper.c:            env->retxl = s2 + len;
target-s390x/mem_helper.c:    env->cc_op = 3;
target-s390x/mem_helper.c:    env->retxl = s2 + len;
target-s390x/mem_helper.c:    env->cc_op = 0;
target-s390x/mem_helper.c:            env->cc_op = 1;
target-s390x/mem_helper.c:            env->retxl = s;
target-s390x/mem_helper.c:    env->cc_op = 3;
target-s390x/mem_helper.c:    env->retxl = s + len;
target-s390x/mem_helper.c:            env->regs[r1] &= ~rmask;
target-s390x/mem_helper.c:            env->regs[r1] |= (uint64_t)val << pos;
target-s390x/mem_helper.c:        env->psw.addr = ret - 4;
target-s390x/mem_helper.c:        env->int_svc_code = (insn | v1) & 0xff;
target-s390x/mem_helper.c:        env->int_svc_ilen = 4;
target-s390x/mem_helper.c:        env->aregs[i] = cpu_ldl_data(env, a2);
target-s390x/mem_helper.c:        cpu_stl_data(env, a2, env->aregs[i]);
target-s390x/mem_helper.c:    uint64_t destlen = env->regs[r1 + 1] & 0xffffff;
target-s390x/mem_helper.c:    uint64_t srclen = env->regs[r2 + 1] & 0xffffff;
target-s390x/mem_helper.c:    env->regs[r1 + 1] = destlen;
target-s390x/mem_helper.c:    env->regs[r2 + 1] -= src - env->regs[r2];
target-s390x/mem_helper.c:    env->regs[r1] = dest;
target-s390x/mem_helper.c:    env->regs[r2] = src;
target-s390x/mem_helper.c:    uint64_t destlen = env->regs[r1 + 1];
target-s390x/mem_helper.c:    uint64_t dest = env->regs[r1];
target-s390x/mem_helper.c:    uint64_t srclen = env->regs[r3 + 1];
target-s390x/mem_helper.c:    uint64_t src = env->regs[r3];
target-s390x/mem_helper.c:    if (!(env->psw.mask & PSW_MASK_64)) {
target-s390x/mem_helper.c:    env->regs[r1 + 1] = destlen;
target-s390x/mem_helper.c:    env->regs[r3 + 1] -= src - env->regs[r3];
target-s390x/mem_helper.c:    env->regs[r1] = dest;
target-s390x/mem_helper.c:    env->regs[r3] = src;
target-s390x/mem_helper.c:    uint64_t destlen = env->regs[r1 + 1];
target-s390x/mem_helper.c:    uint64_t srclen = env->regs[r3 + 1];
target-s390x/mem_helper.c:    env->regs[r1 + 1] = destlen;
target-s390x/mem_helper.c:    env->regs[r3 + 1] -= src - env->regs[r3];
target-s390x/mem_helper.c:    env->regs[r1] = dest;
target-s390x/mem_helper.c:    env->regs[r3] = src;
target-s390x/mem_helper.c:    env->cc_op = (len == src_len ? 0 : 3);
target-s390x/mem_helper.c:    env->retxl = cksm;
target-s390x/mem_helper.c:        env->cregs[i] = cpu_ldq_data(env, src);
target-s390x/mem_helper.c:                   i, src, env->cregs[i]);
target-s390x/mem_helper.c:        env->cregs[i] = (env->cregs[i] & 0xFFFFFFFF00000000ULL) |
target-s390x/mem_helper.c:        cpu_stq_data(env, dest, env->cregs[i]);
target-s390x/mem_helper.c:        cpu_stl_data(env, dest, env->cregs[i]);
target-s390x/mem_helper.c:    return env->storage_keys[addr / TARGET_PAGE_SIZE];
target-s390x/mem_helper.c:    env->storage_keys[addr / TARGET_PAGE_SIZE] = r1;
target-s390x/mem_helper.c:    key = env->storage_keys[r2 / TARGET_PAGE_SIZE];
target-s390x/mem_helper.c:    env->storage_keys[r2 / TARGET_PAGE_SIZE] = (key & ~SK_R);
target-s390x/mem_helper.c:    uint32_t o1 = env->regs[r1];
target-s390x/mem_helper.c:        cpu_stl_data(env, a2, env->regs[(r1 + 1) & 15]);
target-s390x/mem_helper.c:        env->regs[r1] = (env->regs[r1] & 0xffffffff00000000ULL) | o2;
target-s390x/mem_helper.c:    uint64_t asc = env->psw.mask & PSW_MASK_ASC;
target-s390x/mem_helper.c:    if (!(env->psw.mask & PSW_MASK_64) && (addr >> 32)) {
target-s390x/mem_helper.c:        ret = env->int_pgm_code | 0x80000000;
target-s390x/mem_helper.c:    env->cc_op = cc;
target-s390x/translate.c:    if (env->cc_op > 3) {
target-s390x/translate.c:                    env->psw.mask, env->psw.addr, cc_name(env->cc_op));
target-s390x/translate.c:                    env->psw.mask, env->psw.addr, env->cc_op);
target-s390x/translate.c:        cpu_fprintf(f, "R%02d=%016" PRIx64, i, env->regs[i]);
target-s390x/translate.c:        cpu_fprintf(f, "F%02d=%016" PRIx64, i, env->fregs[i].ll);
target-s390x/translate.c:        cpu_fprintf(f, "C%02d=%016" PRIx64, i, env->cregs[i]);
target-s390x/translate.c:/* CC value is in env->cc_op */
target-s390x/translate.c:        /* env->cc_op already is the cc value */
target-s390x/translate.c:    env->psw.addr = tcg_ctx.gen_opc_pc[pc_pos];
target-s390x/translate.c:        env->cc_op = cc_op;
target-s390x/kvm.c:    cs->kvm_run->psw_addr = env->psw.addr;
target-s390x/kvm.c:    cs->kvm_run->psw_mask = env->psw.mask;
target-s390x/kvm.c:            cs->kvm_run->s.regs.gprs[i] = env->regs[i];
target-s390x/kvm.c:            regs.gprs[i] = env->regs[i];
target-s390x/kvm.c:        fpu.fprs[i] = env->fregs[i].ll;
target-s390x/kvm.c:    fpu.fpc = env->fpc;
target-s390x/kvm.c:    kvm_set_one_reg(cs, KVM_REG_S390_CPU_TIMER, &env->cputm);
target-s390x/kvm.c:    kvm_set_one_reg(cs, KVM_REG_S390_CLOCK_COMP, &env->ckc);
target-s390x/kvm.c:    kvm_set_one_reg(cs, KVM_REG_S390_TODPR, &env->todpr);
target-s390x/kvm.c:    kvm_set_one_reg(cs, KVM_REG_S390_GBEA, &env->gbea);
target-s390x/kvm.c:    kvm_set_one_reg(cs, KVM_REG_S390_PP, &env->pp);
target-s390x/kvm.c:        r = kvm_set_one_reg(cs, KVM_REG_S390_PFTOKEN, &env->pfault_token);
target-s390x/kvm.c:        r = kvm_set_one_reg(cs, KVM_REG_S390_PFCOMPARE, &env->pfault_compare);
target-s390x/kvm.c:        r = kvm_set_one_reg(cs, KVM_REG_S390_PFSELECT, &env->pfault_select);
target-s390x/kvm.c:            cs->kvm_run->s.regs.acrs[i] = env->aregs[i];
target-s390x/kvm.c:            cs->kvm_run->s.regs.crs[i] = env->cregs[i];
target-s390x/kvm.c:            sregs.acrs[i] = env->aregs[i];
target-s390x/kvm.c:            sregs.crs[i] = env->cregs[i];
target-s390x/kvm.c:        cs->kvm_run->s.regs.prefix = env->psa;
target-s390x/kvm.c:    env->psw.addr = cs->kvm_run->psw_addr;
target-s390x/kvm.c:    env->psw.mask = cs->kvm_run->psw_mask;
target-s390x/kvm.c:            env->regs[i] = cs->kvm_run->s.regs.gprs[i];
target-s390x/kvm.c:            env->regs[i] = regs.gprs[i];
target-s390x/kvm.c:            env->aregs[i] = cs->kvm_run->s.regs.acrs[i];
target-s390x/kvm.c:            env->cregs[i] = cs->kvm_run->s.regs.crs[i];
target-s390x/kvm.c:            env->aregs[i] = sregs.acrs[i];
target-s390x/kvm.c:            env->cregs[i] = sregs.crs[i];
target-s390x/kvm.c:        env->fregs[i].ll = fpu.fprs[i];
target-s390x/kvm.c:    env->fpc = fpu.fpc;
target-s390x/kvm.c:        env->psa = cs->kvm_run->s.regs.prefix;
target-s390x/kvm.c:    kvm_get_one_reg(cs, KVM_REG_S390_CPU_TIMER, &env->cputm);
target-s390x/kvm.c:    kvm_get_one_reg(cs, KVM_REG_S390_CLOCK_COMP, &env->ckc);
target-s390x/kvm.c:    kvm_get_one_reg(cs, KVM_REG_S390_TODPR, &env->todpr);
target-s390x/kvm.c:    kvm_get_one_reg(cs, KVM_REG_S390_GBEA, &env->gbea);
target-s390x/kvm.c:    kvm_get_one_reg(cs, KVM_REG_S390_PP, &env->pp);
target-s390x/kvm.c:        r = kvm_get_one_reg(cs, KVM_REG_S390_PFTOKEN, &env->pfault_token);
target-s390x/kvm.c:        r = kvm_get_one_reg(cs, KVM_REG_S390_PFCOMPARE, &env->pfault_compare);
target-s390x/kvm.c:        r = kvm_get_one_reg(cs, KVM_REG_S390_PFSELECT, &env->pfault_select);
target-s390x/kvm.c:    sccb = env->regs[ipbh0 & 0xf];
target-s390x/kvm.c:    code = env->regs[(ipbh0 & 0xf0) >> 4];
target-s390x/kvm.c:        ioinst_handle_xsch(cpu, env->regs[1]);
target-s390x/kvm.c:        ioinst_handle_csch(cpu, env->regs[1]);
target-s390x/kvm.c:        ioinst_handle_hsch(cpu, env->regs[1]);
target-s390x/kvm.c:        ioinst_handle_msch(cpu, env->regs[1], run->s390_sieic.ipb);
target-s390x/kvm.c:        ioinst_handle_ssch(cpu, env->regs[1], run->s390_sieic.ipb);
target-s390x/kvm.c:        ioinst_handle_stsch(cpu, env->regs[1], run->s390_sieic.ipb);
target-s390x/kvm.c:        ioinst_handle_schm(cpu, env->regs[1], env->regs[2],
target-s390x/kvm.c:        ioinst_handle_rsch(cpu, env->regs[1]);
target-s390x/kvm.c:        ioinst_handle_rchp(cpu, env->regs[1]);
target-s390x/kvm.c:        ioinst_handle_sal(cpu, env->regs[1]);
target-s390x/kvm.c:    pc = env->psw.addr - 4;
target-s390x/kvm.c:        env->psw.addr = pc;
target-s390x/kvm.c:    uint64_t *statusreg = &env->regs[ipa1 >> 4];
target-s390x/kvm.c:    cpu_addr = env->regs[ipa1 & 0x0f];
target-s390x/kvm.c:    ret = ioinst_handle_tsch(env, env->regs[1], run->s390_tsch.ipb);
target-s390x/helper.c:    env->pending_int |= INTERRUPT_TOD;
target-s390x/helper.c:    env->pending_int |= INTERRUPT_CPUTIMER;
target-s390x/helper.c:    env->int_pgm_code = code;
target-s390x/helper.c:    env->int_pgm_ilen = ilen;
target-s390x/helper.c:             env->psa + offsetof(LowCore, trans_exc_code), vaddr | bits);
target-s390x/helper.c:             env->psa + offsetof(LowCore, trans_exc_code), vaddr | bits);
target-s390x/helper.c:        return raddr + env->psa;    /* Map the lowcore. */
target-s390x/helper.c:    } else if (raddr >= env->psa && raddr < env->psa + 0x2000) {
target-s390x/helper.c:        return raddr - env->psa;    /* Map the 0 page. */
target-s390x/helper.c:               (new_asce & _SEGMENT_ENTRY_FC) && (env->cregs[0] & CR0_EDAT)) {
target-s390x/helper.c:        asce = env->cregs[1];
target-s390x/helper.c:        asce = env->cregs[7];
target-s390x/helper.c:        asce = env->cregs[13];
target-s390x/helper.c:    if (!(env->psw.mask & PSW_MASK_DAT)) {
target-s390x/helper.c:        sk = &env->storage_keys[*raddr / TARGET_PAGE_SIZE];
target-s390x/helper.c:    uint64_t asc = env->psw.mask & PSW_MASK_ASC;
target-s390x/helper.c:    if (!(env->psw.mask & PSW_MASK_64)) {
target-s390x/helper.c:    uint64_t asc = env->psw.mask & PSW_MASK_ASC;
target-s390x/helper.c:    if (!(env->psw.mask & PSW_MASK_64)) {
target-s390x/helper.c:    env->psw.addr = addr;
target-s390x/helper.c:    env->psw.mask = mask;
target-s390x/helper.c:    env->cc_op = (mask >> 44) & 3;
target-s390x/helper.c:    env->cc_op = calc_cc(env, env->cc_op, env->cc_src, env->cc_dst, env->cc_vr);
target-s390x/helper.c:    r = env->psw.mask;
target-s390x/helper.c:    assert(!(env->cc_op & ~3));
target-s390x/helper.c:    r |= (uint64_t)env->cc_op << 44;
target-s390x/helper.c:    lowcore = cpu_physical_memory_map(env->psa, &len, 1);
target-s390x/helper.c:        start += env->psa;
target-s390x/helper.c:    } else if ((addr >= env->psa) && (addr < env->psa + 8192)) {
target-s390x/helper.c:        start -= env->psa;
target-s390x/helper.c:    lowcore->svc_code = cpu_to_be16(env->int_svc_code);
target-s390x/helper.c:    lowcore->svc_ilen = cpu_to_be16(env->int_svc_ilen);
target-s390x/helper.c:    lowcore->svc_old_psw.addr = cpu_to_be64(env->psw.addr + env->int_svc_ilen);
target-s390x/helper.c:    int ilen = env->int_pgm_ilen;
target-s390x/helper.c:        ilen = get_ilen(cpu_ldub_code(env, env->psw.addr));
target-s390x/helper.c:        ilen = get_ilen(cpu_ldub_code(env, env->psw.addr));
target-s390x/helper.c:        env->psw.addr += ilen;
target-s390x/helper.c:                  __func__, env->int_pgm_code, ilen);
target-s390x/helper.c:    lowcore->pgm_code = cpu_to_be16(env->int_pgm_code);
target-s390x/helper.c:    lowcore->program_old_psw.addr = cpu_to_be64(env->psw.addr);
target-s390x/helper.c:            env->int_pgm_code, ilen, env->psw.mask,
target-s390x/helper.c:            env->psw.addr);
target-s390x/helper.c:    if (!(env->psw.mask & PSW_MASK_EXT)) {
target-s390x/helper.c:    if (env->ext_index < 0 || env->ext_index > MAX_EXT_QUEUE) {
target-s390x/helper.c:        cpu_abort(CPU(cpu), "Ext queue overrun: %d\n", env->ext_index);
target-s390x/helper.c:    q = &env->ext_queue[env->ext_index];
target-s390x/helper.c:    lowcore->external_old_psw.addr = cpu_to_be64(env->psw.addr);
target-s390x/helper.c:    lowcore->cpu_addr = cpu_to_be16(env->cpu_num | VIRTIO_SUBCODE_64);
target-s390x/helper.c:    env->ext_index--;
target-s390x/helper.c:    if (env->ext_index == -1) {
target-s390x/helper.c:        env->pending_int &= ~INTERRUPT_EXT;
target-s390x/helper.c:            env->psw.mask, env->psw.addr);
target-s390x/helper.c:    if (!(env->psw.mask & PSW_MASK_IO)) {
target-s390x/helper.c:    for (isc = 0; isc < ARRAY_SIZE(env->io_index); isc++) {
target-s390x/helper.c:        if (env->io_index[isc] < 0) {
target-s390x/helper.c:        if (env->io_index[isc] > MAX_IO_QUEUE) {
target-s390x/helper.c:                      isc, env->io_index[isc]);
target-s390x/helper.c:        q = &env->io_queue[env->io_index[isc]][isc];
target-s390x/helper.c:        if (!(env->cregs[6] & isc_bits)) {
target-s390x/helper.c:            lowcore->io_old_psw.addr = cpu_to_be64(env->psw.addr);
target-s390x/helper.c:            env->io_index[isc]--;
target-s390x/helper.c:                    env->psw.mask, env->psw.addr);
target-s390x/helper.c:        if (env->io_index[isc] >= 0) {
target-s390x/helper.c:        env->pending_int &= ~INTERRUPT_IO;
target-s390x/helper.c:    if (!(env->psw.mask & PSW_MASK_MCHECK)) {
target-s390x/helper.c:    if (env->mchk_index < 0 || env->mchk_index > MAX_MCHK_QUEUE) {
target-s390x/helper.c:        cpu_abort(CPU(cpu), "Mchk queue overrun: %d\n", env->mchk_index);
target-s390x/helper.c:    q = &env->mchk_queue[env->mchk_index];
target-s390x/helper.c:    if (!(env->cregs[14] & (1 << 28))) {
target-s390x/helper.c:        lowcore->floating_pt_save_area[i] = cpu_to_be64(env->fregs[i].ll);
target-s390x/helper.c:        lowcore->gpregs_save_area[i] = cpu_to_be64(env->regs[i]);
target-s390x/helper.c:        lowcore->access_regs_save_area[i] = cpu_to_be32(env->aregs[i]);
target-s390x/helper.c:        lowcore->cregs_save_area[i] = cpu_to_be64(env->cregs[i]);
target-s390x/helper.c:    lowcore->prefixreg_save_area = cpu_to_be32(env->psa);
target-s390x/helper.c:    lowcore->fpt_creg_save_area = cpu_to_be32(env->fpc);
target-s390x/helper.c:    lowcore->tod_progreg_save_area = cpu_to_be32(env->todpr);
target-s390x/helper.c:    lowcore->cpu_timer_save_area[0] = cpu_to_be32(env->cputm >> 32);
target-s390x/helper.c:    lowcore->cpu_timer_save_area[1] = cpu_to_be32((uint32_t)env->cputm);
target-s390x/helper.c:    lowcore->clock_comp_save_area[0] = cpu_to_be32(env->ckc >> 32);
target-s390x/helper.c:    lowcore->clock_comp_save_area[1] = cpu_to_be32((uint32_t)env->ckc);
target-s390x/helper.c:    lowcore->mcck_old_psw.addr = cpu_to_be64(env->psw.addr);
target-s390x/helper.c:    env->mchk_index--;
target-s390x/helper.c:    if (env->mchk_index == -1) {
target-s390x/helper.c:        env->pending_int &= ~INTERRUPT_MCHK;
target-s390x/helper.c:            env->psw.mask, env->psw.addr);
target-s390x/helper.c:                  __func__, cs->exception_index, env->psw.addr);
target-s390x/helper.c:    if ((env->psw.mask & PSW_MASK_MCHECK) &&
target-s390x/helper.c:        if (env->pending_int & INTERRUPT_MCHK) {
target-s390x/helper.c:    if ((env->psw.mask & PSW_MASK_EXT) &&
target-s390x/helper.c:        if (env->pending_int & INTERRUPT_EXT) {
target-s390x/helper.c:        } else if (env->pending_int & INTERRUPT_TOD) {
target-s390x/helper.c:            env->pending_int &= ~INTERRUPT_EXT;
target-s390x/helper.c:            env->pending_int &= ~INTERRUPT_TOD;
target-s390x/helper.c:        } else if (env->pending_int & INTERRUPT_CPUTIMER) {
target-s390x/helper.c:            env->pending_int &= ~INTERRUPT_EXT;
target-s390x/helper.c:            env->pending_int &= ~INTERRUPT_TOD;
target-s390x/helper.c:    if ((env->psw.mask & PSW_MASK_IO) &&
target-s390x/helper.c:        if (env->pending_int & INTERRUPT_IO) {
target-s390x/helper.c:    if (!env->pending_int) {
target-s390x/cpu.h:    if (env->psw.mask & PSW_MASK_PSTATE) {
target-s390x/cpu.h:    *pc = env->psw.addr;
target-s390x/cpu.h:    *flags = ((env->psw.mask >> 32) & ~FLAG_MASK_CC) |
target-s390x/cpu.h:             ((env->psw.mask & PSW_MASK_32) ? FLAG_MASK_32 : 0);
target-s390x/cpu.h:        addr = env->regs[reg];
target-s390x/cpu.h:    CC_OP_DYNAMIC,              /* CC calculation defined by env->cc_op */
target-s390x/cpu.h:    CC_OP_STATIC,               /* CC value is env->cc_op */
target-s390x/cpu.h:    CC_OP_NZ,                   /* env->cc_dst != 0 */
target-s390x/cpu.h:    env->psw.mask &= ~(3ull << 44);
target-s390x/cpu.h:    env->psw.mask |= (cc & 3) << 44;
target-s390x/cpu.h:    if (env->ext_index == MAX_EXT_QUEUE - 1) {
target-s390x/cpu.h:    env->ext_index++;
target-s390x/cpu.h:    assert(env->ext_index < MAX_EXT_QUEUE);
target-s390x/cpu.h:    env->ext_queue[env->ext_index].code = code;
target-s390x/cpu.h:    env->ext_queue[env->ext_index].param = param;
target-s390x/cpu.h:    env->ext_queue[env->ext_index].param64 = param64;
target-s390x/cpu.h:    env->pending_int |= INTERRUPT_EXT;
target-s390x/cpu.h:    if (env->io_index[isc] == MAX_IO_QUEUE - 1) {
target-s390x/cpu.h:    env->io_index[isc]++;
target-s390x/cpu.h:    assert(env->io_index[isc] < MAX_IO_QUEUE);
target-s390x/cpu.h:    env->io_queue[env->io_index[isc]][isc].id = subchannel_id;
target-s390x/cpu.h:    env->io_queue[env->io_index[isc]][isc].nr = subchannel_number;
target-s390x/cpu.h:    env->io_queue[env->io_index[isc]][isc].parm = io_int_parm;
target-s390x/cpu.h:    env->io_queue[env->io_index[isc]][isc].word = io_int_word;
target-s390x/cpu.h:    env->pending_int |= INTERRUPT_IO;
target-s390x/cpu.h:    if (env->mchk_index == MAX_MCHK_QUEUE - 1) {
target-s390x/cpu.h:    env->mchk_index++;
target-s390x/cpu.h:    assert(env->mchk_index < MAX_MCHK_QUEUE);
target-s390x/cpu.h:    env->mchk_queue[env->mchk_index].type = 1;
target-s390x/cpu.h:    env->pending_int |= INTERRUPT_MCHK;
target-s390x/fpu_helper.c:#define RET128(F) (env->retxl = F.low, F.high)
target-s390x/fpu_helper.c:    env->fpc = (env->fpc & ~0xff00) | (dxc << 8);
target-s390x/fpu_helper.c:    qemu_exc = env->fpu_status.float_exception_flags;
target-s390x/fpu_helper.c:    env->fpu_status.float_exception_flags = 0;
target-s390x/fpu_helper.c:    env->fpc |= s390_exc << 16;
target-s390x/fpu_helper.c:    s390_exc &= env->fpc >> 24;
target-s390x/fpu_helper.c:    float32 ret = float32_add(f1, f2, &env->fpu_status);
target-s390x/fpu_helper.c:    float64 ret = float64_add(f1, f2, &env->fpu_status);
target-s390x/fpu_helper.c:                                &env->fpu_status);
target-s390x/fpu_helper.c:    float32 ret = float32_sub(f1, f2, &env->fpu_status);
target-s390x/fpu_helper.c:    float64 ret = float64_sub(f1, f2, &env->fpu_status);
target-s390x/fpu_helper.c:                                &env->fpu_status);
target-s390x/fpu_helper.c:    float32 ret = float32_div(f1, f2, &env->fpu_status);
target-s390x/fpu_helper.c:    float64 ret = float64_div(f1, f2, &env->fpu_status);
target-s390x/fpu_helper.c:                                &env->fpu_status);
target-s390x/fpu_helper.c:    float32 ret = float32_mul(f1, f2, &env->fpu_status);
target-s390x/fpu_helper.c:    float64 ret = float64_mul(f1, f2, &env->fpu_status);
target-s390x/fpu_helper.c:    float64 ret = float32_to_float64(f2, &env->fpu_status);
target-s390x/fpu_helper.c:    ret = float64_mul(f1, ret, &env->fpu_status);
target-s390x/fpu_helper.c:                                &env->fpu_status);
target-s390x/fpu_helper.c:    float128 ret = float64_to_float128(f2, &env->fpu_status);
target-s390x/fpu_helper.c:    ret = float128_mul(make_float128(ah, al), ret, &env->fpu_status);
target-s390x/fpu_helper.c:    float64 ret = float32_to_float64(f2, &env->fpu_status);
target-s390x/fpu_helper.c:    float64 ret = float128_to_float64(make_float128(ah, al), &env->fpu_status);
target-s390x/fpu_helper.c:    float128 ret = float64_to_float128(f2, &env->fpu_status);
target-s390x/fpu_helper.c:    float128 ret = float32_to_float128(f2, &env->fpu_status);
target-s390x/fpu_helper.c:    float32 ret = float64_to_float32(f2, &env->fpu_status);
target-s390x/fpu_helper.c:    float32 ret = float128_to_float32(make_float128(ah, al), &env->fpu_status);
target-s390x/fpu_helper.c:    int cmp = float32_compare_quiet(f1, f2, &env->fpu_status);
target-s390x/fpu_helper.c:    int cmp = float64_compare_quiet(f1, f2, &env->fpu_status);
target-s390x/fpu_helper.c:                                     &env->fpu_status);
target-s390x/fpu_helper.c:    int ret = env->fpu_status.float_rounding_mode;
target-s390x/fpu_helper.c:        set_float_rounding_mode(float_round_nearest_even, &env->fpu_status);
target-s390x/fpu_helper.c:        set_float_rounding_mode(float_round_to_zero, &env->fpu_status);
target-s390x/fpu_helper.c:        set_float_rounding_mode(float_round_up, &env->fpu_status);
target-s390x/fpu_helper.c:        set_float_rounding_mode(float_round_down, &env->fpu_status);
target-s390x/fpu_helper.c:    float32 ret = int64_to_float32(v2, &env->fpu_status);
target-s390x/fpu_helper.c:    set_float_rounding_mode(hold, &env->fpu_status);
target-s390x/fpu_helper.c:    float64 ret = int64_to_float64(v2, &env->fpu_status);
target-s390x/fpu_helper.c:    set_float_rounding_mode(hold, &env->fpu_status);
target-s390x/fpu_helper.c:    float128 ret = int64_to_float128(v2, &env->fpu_status);
target-s390x/fpu_helper.c:    set_float_rounding_mode(hold, &env->fpu_status);
target-s390x/fpu_helper.c:    float32 ret = uint64_to_float32(v2, &env->fpu_status);
target-s390x/fpu_helper.c:    set_float_rounding_mode(hold, &env->fpu_status);
target-s390x/fpu_helper.c:    float64 ret = uint64_to_float64(v2, &env->fpu_status);
target-s390x/fpu_helper.c:    set_float_rounding_mode(hold, &env->fpu_status);
target-s390x/fpu_helper.c:    float128 ret = uint64_to_float128(v2, &env->fpu_status);
target-s390x/fpu_helper.c:    set_float_rounding_mode(hold, &env->fpu_status);
target-s390x/fpu_helper.c:    int64_t ret = float32_to_int64(v2, &env->fpu_status);
target-s390x/fpu_helper.c:    set_float_rounding_mode(hold, &env->fpu_status);
target-s390x/fpu_helper.c:    int64_t ret = float64_to_int64(v2, &env->fpu_status);
target-s390x/fpu_helper.c:    set_float_rounding_mode(hold, &env->fpu_status);
target-s390x/fpu_helper.c:    int64_t ret = float128_to_int64(v2, &env->fpu_status);
target-s390x/fpu_helper.c:    set_float_rounding_mode(hold, &env->fpu_status);
target-s390x/fpu_helper.c:    int32_t ret = float32_to_int32(v2, &env->fpu_status);
target-s390x/fpu_helper.c:    set_float_rounding_mode(hold, &env->fpu_status);
target-s390x/fpu_helper.c:    int32_t ret = float64_to_int32(v2, &env->fpu_status);
target-s390x/fpu_helper.c:    set_float_rounding_mode(hold, &env->fpu_status);
target-s390x/fpu_helper.c:    int32_t ret = float128_to_int32(v2, &env->fpu_status);
target-s390x/fpu_helper.c:    set_float_rounding_mode(hold, &env->fpu_status);
target-s390x/fpu_helper.c:    v2 = float32_to_float64(v2, &env->fpu_status);
target-s390x/fpu_helper.c:    ret = float64_to_uint64(v2, &env->fpu_status);
target-s390x/fpu_helper.c:    set_float_rounding_mode(hold, &env->fpu_status);
target-s390x/fpu_helper.c:    uint64_t ret = float64_to_uint64(v2, &env->fpu_status);
target-s390x/fpu_helper.c:    set_float_rounding_mode(hold, &env->fpu_status);
target-s390x/fpu_helper.c:    uint64_t ret = float128_to_int64(v2, &env->fpu_status);
target-s390x/fpu_helper.c:    set_float_rounding_mode(hold, &env->fpu_status);
target-s390x/fpu_helper.c:    uint32_t ret = float32_to_uint32(v2, &env->fpu_status);
target-s390x/fpu_helper.c:    set_float_rounding_mode(hold, &env->fpu_status);
target-s390x/fpu_helper.c:    uint32_t ret = float64_to_uint32(v2, &env->fpu_status);
target-s390x/fpu_helper.c:    set_float_rounding_mode(hold, &env->fpu_status);
target-s390x/fpu_helper.c:    uint32_t ret = float128_to_int64(v2, &env->fpu_status);
target-s390x/fpu_helper.c:    set_float_rounding_mode(hold, &env->fpu_status);
target-s390x/fpu_helper.c:    float32 ret = float32_muladd(f2, f3, f1, 0, &env->fpu_status);
target-s390x/fpu_helper.c:    float64 ret = float64_muladd(f2, f3, f1, 0, &env->fpu_status);
target-s390x/fpu_helper.c:                                 &env->fpu_status);
target-s390x/fpu_helper.c:                                 &env->fpu_status);
target-s390x/fpu_helper.c:    float32 ret = float32_sqrt(f2, &env->fpu_status);
target-s390x/fpu_helper.c:    float64 ret = float64_sqrt(f2, &env->fpu_status);
target-s390x/fpu_helper.c:    float128 ret = float128_sqrt(make_float128(ah, al), &env->fpu_status);
target-s390x/fpu_helper.c:    env->fpc = fpc;
target-s390x/fpu_helper.c:    set_float_rounding_mode(fpc_to_rnd[fpc & 3], &env->fpu_status);
target-s390x/fpu_helper.c:    uint32_t signalling = env->fpc;
target-s390x/fpu_helper.c:    env->fpc = source | (signalling & 0x00ff0000);
target-s390x/fpu_helper.c:    set_float_rounding_mode(fpc_to_rnd[source & 3], &env->fpu_status);
target-s390x/misc_helper.c:    env->int_pgm_code = excp;
target-s390x/misc_helper.c:    t = cpu_ldub_code(env, env->psw.addr);
target-s390x/misc_helper.c:    env->int_pgm_ilen = t = get_ilen(t);
target-s390x/misc_helper.c:    env->psw.addr += 2 * t;
target-s390x/misc_helper.c:                  env->psw.addr);
target-s390x/misc_helper.c:        env->int_pgm_code = code;
target-s390x/misc_helper.c:        env->int_pgm_ilen = ilen;
target-s390x/misc_helper.c:    uint64_t addr =  env->regs[r1];
target-s390x/misc_helper.c:    uint64_t subcode = env->regs[r3];
target-s390x/misc_helper.c:    if (env->psw.mask & PSW_MASK_PSTATE) {
target-s390x/misc_helper.c:        env->regs[r1+1] = DIAG_308_RC_INVALID;
target-s390x/misc_helper.c:        env->regs[r1+1] = DIAG_308_RC_NO_CONF;
target-s390x/misc_helper.c:    env->psa = prefix;
target-s390x/misc_helper.c:    time = env->tod_offset +
target-s390x/misc_helper.c:        time2tod(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) - env->tod_basetime);
target-s390x/misc_helper.c:    timer_mod(env->tod_timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + time);
target-s390x/misc_helper.c:    timer_mod(env->cpu_timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + time);
target-s390x/misc_helper.c:            stw_p(&sysib.cpu_addr, env->cpu_num);
target-s390x/misc_helper.c:                stw_p(&sysib.cpu_addr, env->cpu_num);
target-s390x/misc_helper.c:        env->regs[0] = STSI_LEVEL_3;
target-s390x/misc_helper.c:        env->regs[r1] &= 0xffffffff00000000ULL;
target-s390x/cpu.c:           (env->psw.mask & PSW_MASK_EXT);
target-s390x/cpu.c:    env->pfault_token = -1UL;
target-s390x/cpu.c:    memset(&env->fpc, 0, offsetof(CPUS390XState, cpu_num) -
target-s390x/cpu.c:    env->cregs[0] = CR0_RESET;
target-s390x/cpu.c:    env->cregs[14] = CR14_RESET;
target-s390x/cpu.c:    env->pfault_token = -1UL;
target-s390x/cpu.c:    env->cregs[0] = CR0_RESET;
target-s390x/cpu.c:    env->cregs[14] = CR14_RESET;
target-s390x/cpu.c:    env->pfault_token = -1UL;
target-s390x/cpu.c:    env->tod_offset = TOD_UNIX_EPOCH +
target-s390x/cpu.c:    env->tod_basetime = 0;
target-s390x/cpu.c:    env->tod_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, s390x_tod_timer, cpu);
target-s390x/cpu.c:    env->cpu_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, s390x_cpu_timer, cpu);
target-s390x/cpu.c:    env->cpu_num = cpu_num++;
target-s390x/cpu.c:    env->ext_index = -1;
target-s390x/cc_helper.c:        env->psw.mask &= ~PSW_MASK_ASC;
target-s390x/cc_helper.c:        env->psw.mask |= PSW_ASC_PRIMARY;
target-s390x/cc_helper.c:        env->psw.mask &= ~PSW_MASK_ASC;
target-s390x/cc_helper.c:        env->psw.mask |= PSW_ASC_SECONDARY;
target-s390x/cc_helper.c:        env->psw.mask &= ~PSW_MASK_ASC;
target-s390x/cc_helper.c:        env->psw.mask |= PSW_ASC_HOME;
target-s390x/int_helper.c:    env->retxl = a % b;
target-s390x/int_helper.c:    env->retxl = a % b;
target-s390x/int_helper.c:    env->retxl = a % b;
target-s390x/int_helper.c:        env->retxl = al % b;
target-s390x/int_helper.c:        env->retxl = a % b;
target-moxie/translate.c:    cpu_fprintf(f, "pc=0x%08x\n", env->pc);
target-moxie/translate.c:                env->gregs[0], env->gregs[1], env->gregs[2], env->gregs[3]);
target-moxie/translate.c:                    i-2, env->gregs[i], i-1, env->gregs[i + 1],
target-moxie/translate.c:                    i, env->gregs[i + 2], i+1, env->gregs[i + 3]);
target-moxie/translate.c:                    i-2, env->sregs[i], i-1, env->sregs[i + 1],
target-moxie/translate.c:                    i, env->sregs[i + 2], i+1, env->sregs[i + 3]);
target-moxie/translate.c:    env->pc = tcg_ctx.gen_opc_pc[pc_pos];
target-moxie/helper.c:    env->sregs[2] = ex;
target-moxie/helper.c:    env->sregs[5] = env->pc;
target-moxie/helper.c:    env->pc = env->sregs[1];
target-moxie/cpu.h:    *pc = env->pc;
target-moxie/cpu.c:    env->pc = 0x1000;
Binary file pc-bios/slof.bin matches
Changelog:  - Fix race condition in env->interrupt_request.  When using TCG and a dynticks
target-cris/gdbstub.c:        return gdb_get_reg32(mem_buf, env->regs[n]);
target-cris/gdbstub.c:        return gdb_get_reg32(mem_buf, env->pc);
target-cris/gdbstub.c:            return gdb_get_reg8(mem_buf, env->pregs[n - 16]);
target-cris/gdbstub.c:            return gdb_get_reg8(mem_buf, env->pregs[n - 16]);
target-cris/gdbstub.c:            return gdb_get_reg16(mem_buf, env->pregs[n - 16]);
target-cris/gdbstub.c:                return gdb_get_reg32(mem_buf, env->pregs[n - 16]);
target-cris/gdbstub.c:    srs = env->pregs[PR_SRS];
target-cris/gdbstub.c:        return gdb_get_reg32(mem_buf, env->regs[n]);
target-cris/gdbstub.c:        return gdb_get_reg32(mem_buf, env->pregs[n - 16]);
target-cris/gdbstub.c:        return gdb_get_reg32(mem_buf, env->sregs[srs][n - 33]);
target-cris/gdbstub.c:        return gdb_get_reg8(mem_buf, env->pregs[0]);
target-cris/gdbstub.c:        return gdb_get_reg8(mem_buf, env->pregs[1]);
target-cris/gdbstub.c:        return gdb_get_reg32(mem_buf, env->pregs[2]);
target-cris/gdbstub.c:        return gdb_get_reg16(mem_buf, env->pregs[4]);
target-cris/gdbstub.c:        return gdb_get_reg32(mem_buf, env->pc);
target-cris/gdbstub.c:        env->regs[n] = tmp;
target-cris/gdbstub.c:        env->pregs[n - 16] = tmp;
target-cris/gdbstub.c:        env->pregs[PR_PID] = tmp;
target-cris/gdbstub.c:        env->pc = tmp;
target-cris/mmu.c:	env->mmu_rand_lfsr = 0xcccc;
target-cris/mmu.c:	f = compute_polynom(env->mmu_rand_lfsr);
target-cris/mmu.c:	env->mmu_rand_lfsr >>= 1;
target-cris/mmu.c:	env->mmu_rand_lfsr |= (f << 15);
target-cris/mmu.c:	env->mmu_rand_lfsr &= 0xffff;
target-cris/mmu.c:		base = env->sregs[SFR_RW_MM_KBASE_LO];
target-cris/mmu.c:		base = env->sregs[SFR_RW_MM_KBASE_HI];
target-cris/mmu.c:			lo = env->tlbsets[mmu][set][idx].lo;
target-cris/mmu.c:			hi = env->tlbsets[mmu][set][idx].hi;
target-cris/mmu.c:	r_cause = env->sregs[SFR_R_MM_CAUSE];
target-cris/mmu.c:	r_cfg = env->sregs[SFR_RW_MM_CFG];
target-cris/mmu.c:	pid = env->pregs[PR_PID] & 0xff;
target-cris/mmu.c:			lo = env->tlbsets[mmu][set][idx].lo;
target-cris/mmu.c:			hi = env->tlbsets[mmu][set][idx].hi;
target-cris/mmu.c:		lo = env->tlbsets[mmu][set][idx].lo;
target-cris/mmu.c:		hi = env->tlbsets[mmu][set][idx].hi;
target-cris/mmu.c:				  vaddr, lo, env->pc));
target-cris/mmu.c:				  vaddr, lo, env->pc));
target-cris/mmu.c:				 vaddr, lo, env->pc));
target-cris/mmu.c:		set = env->mmu_rand_lfsr & 3;
target-cris/mmu.c:		env->sregs[SFR_RW_MM_TLB_SEL] = 0;
target-cris/mmu.c:		set_field(&env->sregs[SFR_RW_MM_TLB_SEL], idx, 0, 4);
target-cris/mmu.c:		set_field(&env->sregs[SFR_RW_MM_TLB_SEL], set, 4, 2);
target-cris/mmu.c:		env->sregs[SFR_R_MM_CAUSE] = r_cause;
target-cris/mmu.c:		D(printf("refill vaddr=%x pc=%x\n", vaddr, env->pc));
target-cris/mmu.c:		  __func__, rw, match, env->pc,
target-cris/mmu.c:		  env->sregs[SFR_RW_MM_TLB_SEL],
target-cris/mmu.c:		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
target-cris/mmu.c:				lo = env->tlbsets[mmu][set][idx].lo;
target-cris/mmu.c:				hi = env->tlbsets[mmu][set][idx].hi;
target-cris/mmu.c:	old_srs= env->pregs[PR_SRS];
target-cris/mmu.c:	env->pregs[PR_SRS] = rw == 2 ? 1 : 2;
target-cris/mmu.c:	if (!cris_mmu_enabled(env->sregs[SFR_RW_GC_CFG])) {
target-cris/mmu.c:	if (!is_user && cris_mmu_segmented_addr(seg, env->sregs[SFR_RW_MM_CFG]))
target-cris/mmu.c:	env->pregs[PR_SRS] = old_srs;
target-cris/translate.c: * The TB contaning the branch insn will set up env->btarget and evaluate 
target-cris/translate.c: * env->btaken. When the translation loop exits we will note that the branch 
target-cris/translate.c: * sequence is broken and let env->dslot be the size of the branch insn (those
target-cris/translate.c: * set). It will also expect to have env->dslot setup with the size of the 
target-cris/translate.c: * delay slot so that env->pc - env->dslot point to the branch insn. This TB 
target-cris/translate.c: * When exceptions occur, we check for env->dslot in do_interrupt to detect 
target-cris/translate.c: * branch and set lsb). Then env->dslot gets cleared so that the exception 
target-cris/translate.c:    if (env->pregs[PR_VR] == 32) {
target-cris/translate.c:                env->btarget, (unsigned)tb->flags & 7,
target-cris/translate.c:                env->pregs[PR_CCS],
target-cris/translate.c:                env->pregs[PR_PID], env->pregs[PR_USP],
target-cris/translate.c:                env->regs[0], env->regs[1], env->regs[2], env->regs[3],
target-cris/translate.c:                env->regs[4], env->regs[5], env->regs[6], env->regs[7],
target-cris/translate.c:                env->regs[8], env->regs[9],
target-cris/translate.c:                env->regs[10], env->regs[11],
target-cris/translate.c:                env->regs[12], env->regs[13],
target-cris/translate.c:                env->regs[14], env->regs[15]);
target-cris/translate.c:        /* Set env->dslot to the size of the branch insn.  */
target-cris/translate.c:                         env->pregs[PR_VR]);
target-cris/translate.c:            env->pc, env->pregs[PR_CCS], env->btaken, env->btarget,
target-cris/translate.c:            env->cc_op,
target-cris/translate.c:            env->cc_src, env->cc_dest, env->cc_result, env->cc_mask);
target-cris/translate.c:        cpu_fprintf(f, "%s=%8.8x ", regnames[i], env->regs[i]);
target-cris/translate.c:        cpu_fprintf(f, "%s=%8.8x ", pregnames[i], env->pregs[i]);
target-cris/translate.c:    srs = env->pregs[PR_SRS];
target-cris/translate.c:    if (srs < ARRAY_SIZE(env->sregs)) {
target-cris/translate.c:                    i, env->sregs[srs][i]);
target-cris/translate.c:    env->pc = tcg_ctx.gen_opc_pc[pc_pos];
target-cris/helper.c:    env->pregs[PR_ERP] = env->pc;
target-cris/helper.c:    ccs = env->pregs[PR_CCS];
target-cris/helper.c:    env->pregs[PR_CCS] = ccs;
target-cris/helper.c:             __func__, address, env->pc, rw));
target-cris/helper.c:        env->pregs[PR_EDA] = address;
target-cris/helper.c:        env->fault_vector = res.bf_vec;
target-cris/helper.c:              res.bf_vec, env->pc);
target-cris/helper.c:    if (env->dslot) {
target-cris/helper.c:    assert(!(env->pregs[PR_CCS] & PFIX_FLAG));
target-cris/helper.c:        ex_vec = env->trap_vector;
target-cris/helper.c:        env->pregs[PRV10_BRP] = env->pc;
target-cris/helper.c:        env->pregs[PR_CCS] &= ~M_FLAG_V10;
target-cris/helper.c:        env->pregs[PRV10_BRP] = env->pc;
target-cris/helper.c:        ex_vec = env->interrupt_vector;
target-cris/helper.c:           TB's.  env->pc is valid here.  */
target-cris/helper.c:        env->pregs[PR_ERP] = env->pc;
target-cris/helper.c:    if (env->pregs[PR_CCS] & U_FLAG) {
target-cris/helper.c:        env->pregs[PR_USP] = env->regs[R_SP];
target-cris/helper.c:        env->regs[R_SP] = env->ksp;
target-cris/helper.c:    env->pc = cpu_ldl_code(env, env->pregs[PR_EBP] + ex_vec * 4);
target-cris/helper.c:    env->locked_irq = 1;
target-cris/helper.c:    env->pregs[PR_CCS] |= F_FLAG_V10; /* set F.  */
target-cris/helper.c:                  __func__, env->pc, ex_vec,
target-cris/helper.c:                  env->pregs[PR_CCS],
target-cris/helper.c:                  env->pregs[PR_PID],
target-cris/helper.c:                  env->pregs[PR_ERP]);
target-cris/helper.c:        ex_vec = env->trap_vector;
target-cris/helper.c:        env->pregs[PR_ERP] = env->pc;
target-cris/helper.c:        env->pregs[PR_CCS] &= ~M_FLAG_V32;
target-cris/helper.c:        env->pregs[PR_NRP] = env->pc;
target-cris/helper.c:        ex_vec = env->fault_vector;
target-cris/helper.c:        env->pregs[PR_ERP] = env->pc;
target-cris/helper.c:        ex_vec = env->interrupt_vector;
target-cris/helper.c:           TB's.  env->pc is valid here.  */
target-cris/helper.c:        env->pregs[PR_ERP] = env->pc;
target-cris/helper.c:    env->pregs[PR_EXS] = (ex_vec & 0xff) << 8;
target-cris/helper.c:    if (env->dslot) {
target-cris/helper.c:              ex_vec, env->pc, env->dslot,
target-cris/helper.c:              env->regs[R_SP],
target-cris/helper.c:              env->pregs[PR_ERP], env->pregs[PR_PID],
target-cris/helper.c:              env->pregs[PR_CCS],
target-cris/helper.c:              env->cc_op, env->cc_mask);
target-cris/helper.c:        env->pregs[PR_ERP] -= env->dslot;
target-cris/helper.c:        env->dslot = 0;
target-cris/helper.c:    if (env->pregs[PR_CCS] & U_FLAG) {
target-cris/helper.c:        env->pregs[PR_USP] = env->regs[R_SP];
target-cris/helper.c:        env->regs[R_SP] = env->ksp;
target-cris/helper.c:    env->pc = cpu_ldl_code(env, env->pregs[PR_EBP] + ex_vec * 4);
target-cris/helper.c:          __func__, env->pc, ex_vec,
target-cris/helper.c:          env->pregs[PR_CCS],
target-cris/helper.c:          env->pregs[PR_PID],
target-cris/helper.c:          env->pregs[PR_ERP]);
target-cris/machine.c:        qemu_put_be32(f, env->regs[i]);
target-cris/machine.c:        qemu_put_be32(f, env->pregs[i]);
target-cris/machine.c:    qemu_put_be32(f, env->pc);
target-cris/machine.c:    qemu_put_be32(f, env->ksp);
target-cris/machine.c:    qemu_put_be32(f, env->dslot);
target-cris/machine.c:    qemu_put_be32(f, env->btaken);
target-cris/machine.c:    qemu_put_be32(f, env->btarget);
target-cris/machine.c:    qemu_put_be32(f, env->cc_op);
target-cris/machine.c:    qemu_put_be32(f, env->cc_mask);
target-cris/machine.c:    qemu_put_be32(f, env->cc_dest);
target-cris/machine.c:    qemu_put_be32(f, env->cc_src);
target-cris/machine.c:    qemu_put_be32(f, env->cc_result);
target-cris/machine.c:    qemu_put_be32(f, env->cc_size);
target-cris/machine.c:    qemu_put_be32(f, env->cc_x);
target-cris/machine.c:            qemu_put_be32(f, env->sregs[s][i]);
target-cris/machine.c:    qemu_put_be32(f, env->mmu_rand_lfsr);
target-cris/machine.c:                qemu_put_be32(f, env->tlbsets[mmu][s][i].lo);
target-cris/machine.c:                qemu_put_be32(f, env->tlbsets[mmu][s][i].hi);
target-cris/machine.c:        env->regs[i] = qemu_get_be32(f);
target-cris/machine.c:        env->pregs[i] = qemu_get_be32(f);
target-cris/machine.c:    env->pc = qemu_get_be32(f);
target-cris/machine.c:    env->ksp = qemu_get_be32(f);
target-cris/machine.c:    env->dslot = qemu_get_be32(f);
target-cris/machine.c:    env->btaken = qemu_get_be32(f);
target-cris/machine.c:    env->btarget = qemu_get_be32(f);
target-cris/machine.c:    env->cc_op = qemu_get_be32(f);
target-cris/machine.c:    env->cc_mask = qemu_get_be32(f);
target-cris/machine.c:    env->cc_dest = qemu_get_be32(f);
target-cris/machine.c:    env->cc_src = qemu_get_be32(f);
target-cris/machine.c:    env->cc_result = qemu_get_be32(f);
target-cris/machine.c:    env->cc_size = qemu_get_be32(f);
target-cris/machine.c:    env->cc_x = qemu_get_be32(f);
target-cris/machine.c:            env->sregs[s][i] = qemu_get_be32(f);
target-cris/machine.c:    env->mmu_rand_lfsr = qemu_get_be32(f);
target-cris/machine.c:                env->tlbsets[mmu][s][i].lo = qemu_get_be32(f);
target-cris/machine.c:                env->tlbsets[mmu][s][i].hi = qemu_get_be32(f);
target-cris/cpu.h:    CC_OP_DYNAMIC, /* Use env->cc_op  */
target-cris/cpu.h:	return !!(env->pregs[PR_CCS] & U_FLAG);
target-cris/cpu.h:#define SFR_RW_MM_CFG      env->pregs[PR_SRS]][0
target-cris/cpu.h:#define SFR_RW_MM_KBASE_LO env->pregs[PR_SRS]][1
target-cris/cpu.h:#define SFR_RW_MM_KBASE_HI env->pregs[PR_SRS]][2
target-cris/cpu.h:#define SFR_R_MM_CAUSE     env->pregs[PR_SRS]][3
target-cris/cpu.h:#define SFR_RW_MM_TLB_SEL  env->pregs[PR_SRS]][4
target-cris/cpu.h:#define SFR_RW_MM_TLB_LO   env->pregs[PR_SRS]][5
target-cris/cpu.h:#define SFR_RW_MM_TLB_HI   env->pregs[PR_SRS]][6
target-cris/cpu.h:    *pc = env->pc;
target-cris/cpu.h:    *flags = env->dslot |
target-cris/cpu.h:            (env->pregs[PR_CCS] & (S_FLAG | P_FLAG | U_FLAG
target-cris/cpu.c:    vr = env->pregs[PR_VR];
target-cris/cpu.c:    env->pregs[PR_VR] = vr;
target-cris/cpu.c:    env->pregs[PR_CCS] |= U_FLAG | I_FLAG | P_FLAG;
target-cris/cpu.c:    env->pregs[PR_CCS] = 0;
target-cris/cpu.c:    env->pregs[PR_VR] = ccc->vr;
target-cris/cpu.c:        if (env->pregs[PR_VR] < 32) {
target-cris/op_helper.c:          env->pc, env->pregs[PR_EDA], (void *)retaddr);
target-cris/op_helper.c:	if (pid != (env->pregs[PR_PID] & 0xff))
target-cris/op_helper.c:		cris_mmu_flush_pid(env, env->pregs[PR_PID]);
target-cris/op_helper.c:    tlb_flush_page(cs, env->pregs[PR_SPC]);
target-cris/op_helper.c:	srs = env->pregs[PR_SRS];
target-cris/op_helper.c:	env->sregs[srs][sreg] = env->regs[reg];
target-cris/op_helper.c:			env->sregs[SFR_RW_MM_TLB_HI] = env->regs[reg];
target-cris/op_helper.c:			env->sregs[SFR_R_MM_CAUSE] = env->regs[reg];
target-cris/op_helper.c:			idx = set = env->sregs[SFR_RW_MM_TLB_SEL];
target-cris/op_helper.c:			lo = env->sregs[SFR_RW_MM_TLB_LO];
target-cris/op_helper.c:			hi = env->sregs[SFR_R_MM_CAUSE];
target-cris/op_helper.c:			vaddr = EXTRACT_FIELD(env->tlbsets[srs-1][set][idx].hi,
target-cris/op_helper.c:			tlb_v = EXTRACT_FIELD(env->tlbsets[srs-1][set][idx].lo,
target-cris/op_helper.c:			env->tlbsets[srs - 1][set][idx].lo = lo;
target-cris/op_helper.c:			env->tlbsets[srs - 1][set][idx].hi = hi;
target-cris/op_helper.c:				  vaddr, tlb_v, env->pc);
target-cris/op_helper.c:	env->pregs[PR_SRS] &= 3;
target-cris/op_helper.c:	srs = env->pregs[PR_SRS];
target-cris/op_helper.c:		idx = set = env->sregs[SFR_RW_MM_TLB_SEL];
target-cris/op_helper.c:		hi = env->tlbsets[srs - 1][set][idx].hi;
target-cris/op_helper.c:		lo = env->tlbsets[srs - 1][set][idx].lo;
target-cris/op_helper.c:		env->sregs[SFR_RW_MM_TLB_HI] = hi;
target-cris/op_helper.c:		env->sregs[SFR_RW_MM_TLB_LO] = lo;
target-cris/op_helper.c:	env->regs[reg] = env->sregs[srs][sreg];
target-cris/op_helper.c:	ccs = env->pregs[PR_CCS];
target-cris/op_helper.c:		env->ksp = env->regs[R_SP];
target-cris/op_helper.c:		env->regs[R_SP] = env->pregs[PR_USP];
target-cris/op_helper.c:	env->pregs[PR_CCS] = ccs;
target-cris/op_helper.c:	int rflag = env->pregs[PR_CCS] & R_FLAG;
target-cris/op_helper.c:		 env->pregs[PR_ERP], env->pregs[PR_PID],
target-cris/op_helper.c:		 env->pregs[PR_CCS],
target-cris/op_helper.c:		 env->btarget);
target-cris/op_helper.c:		env->pregs[PR_CCS] |= P_FLAG;
target-cris/op_helper.c:	int rflag = env->pregs[PR_CCS] & R_FLAG;
target-cris/op_helper.c:		 env->pregs[PR_ERP], env->pregs[PR_PID],
target-cris/op_helper.c:		 env->pregs[PR_CCS],
target-cris/op_helper.c:		 env->btarget);
target-cris/op_helper.c:		env->pregs[PR_CCS] |= P_FLAG;
target-cris/op_helper.c:	env->pregs[PR_CCS] |= M_FLAG_V32;
target-cris/op_helper.c:	if (env->pregs[PR_VR] < 32)
target-cris/op_helper.c:	x = env->cc_x;
target-cris/op_helper.c:	mask = env->cc_mask | X_FLAG;
target-cris/op_helper.c:	src = env->cc_src;
target-cris/op_helper.c:	dst = env->cc_dest;
target-cris/op_helper.c:	res = env->cc_result;
target-cris/op_helper.c:	if (env->cc_op == CC_OP_SUB || env->cc_op == CC_OP_CMP)
target-cris/op_helper.c:	switch (env->cc_size)
target-cris/op_helper.c:	if (env->cc_op == CC_OP_SUB || env->cc_op == CC_OP_CMP)
target-cris/op_helper.c:        env->pregs[PR_CCS] = evaluate_flags_writeback(env, flags,
target-cris/op_helper.c:                                                      env->pregs[PR_CCS]);
target-cris/op_helper.c:	switch (env->cc_op)
target-cris/op_helper.c:                        env->pregs[PR_CCS] = helper_evaluate_flags_mcp(env,
target-cris/op_helper.c:					env->pregs[PR_CCS], env->cc_src,
target-cris/op_helper.c:					env->cc_dest, env->cc_result);
target-cris/op_helper.c:                        env->pregs[PR_CCS] = helper_evaluate_flags_muls(env,
target-cris/op_helper.c:					env->pregs[PR_CCS], env->cc_result,
target-cris/op_helper.c:					env->pregs[PR_MOF]);
target-cris/op_helper.c:                        env->pregs[PR_CCS] = helper_evaluate_flags_mulu(env,
target-cris/op_helper.c:					env->pregs[PR_CCS], env->cc_result,
target-cris/op_helper.c:					env->pregs[PR_MOF]);
target-cris/op_helper.c:		switch (env->cc_size)
target-cris/op_helper.c:				env->pregs[PR_CCS] =
target-cris/op_helper.c:							env->pregs[PR_CCS],
target-cris/op_helper.c:							env->cc_result);
target-cris/op_helper.c:				env->pregs[PR_CCS] =
target-cris/op_helper.c:							env->pregs[PR_CCS],
target-cris/op_helper.c:							env->cc_result);
target-cris/op_helper.c:			if (env->cc_size == 4)
target-cris/op_helper.c:				env->pregs[PR_CCS] =
target-cris/op_helper.c:						env->pregs[PR_CCS],
target-cris/op_helper.c:						env->cc_src, env->cc_dest,
target-cris/op_helper.c:						env->cc_result);
target-cris/op_helper.c:			switch (env->cc_size)
target-cris/op_helper.c:				env->pregs[PR_CCS] =
target-cris/op_helper.c:						env->pregs[PR_CCS],
target-cris/op_helper.c:						env->cc_src, env->cc_dest,
target-cris/op_helper.c:						env->cc_result);
target-lm32/gdbstub.c:        return gdb_get_reg32(mem_buf, env->regs[n]);
target-lm32/gdbstub.c:            return gdb_get_reg32(mem_buf, env->pc);
target-lm32/gdbstub.c:            return gdb_get_reg32(mem_buf, env->eba);
target-lm32/gdbstub.c:            return gdb_get_reg32(mem_buf, env->deba);
target-lm32/gdbstub.c:            return gdb_get_reg32(mem_buf, env->ie);
target-lm32/gdbstub.c:            return gdb_get_reg32(mem_buf, lm32_pic_get_im(env->pic_state));
target-lm32/gdbstub.c:            return gdb_get_reg32(mem_buf, lm32_pic_get_ip(env->pic_state));
target-lm32/gdbstub.c:        env->regs[n] = tmp;
target-lm32/gdbstub.c:            env->pc = tmp;
target-lm32/gdbstub.c:            env->eba = tmp;
target-lm32/gdbstub.c:            env->deba = tmp;
target-lm32/gdbstub.c:            env->ie = tmp;
target-lm32/gdbstub.c:            lm32_pic_set_im(env->pic_state, tmp);
target-lm32/gdbstub.c:            lm32_pic_set_ip(env->pic_state, tmp);
target-lm32/translate.c:                env->pc, lookup_symbol(env->pc));
target-lm32/translate.c:             env->ie,
target-lm32/translate.c:             (env->ie & IE_IE) ? 1 : 0,
target-lm32/translate.c:             (env->ie & IE_EIE) ? 1 : 0,
target-lm32/translate.c:             (env->ie & IE_BIE) ? 1 : 0,
target-lm32/translate.c:             lm32_pic_get_im(env->pic_state),
target-lm32/translate.c:             lm32_pic_get_ip(env->pic_state));
target-lm32/translate.c:             env->eba,
target-lm32/translate.c:             env->deba);
target-lm32/translate.c:        cpu_fprintf(f, "r%2.2d=%8.8x ", i, env->regs[i]);
target-lm32/translate.c:    env->pc = tcg_ctx.gen_opc_pc[pc_pos];
target-lm32/helper.c:    if (env->flags & LM32_FLAG_IGNORE_MSB) {
target-lm32/helper.c:                          &env->cpu_breakpoint[idx]);
target-lm32/helper.c:    if (!env->cpu_breakpoint[idx]) {
target-lm32/helper.c:    cpu_breakpoint_remove_by_ref(CPU(cpu), env->cpu_breakpoint[idx]);
target-lm32/helper.c:    env->cpu_breakpoint[idx] = NULL;
target-lm32/helper.c:                &env->cpu_watchpoint[idx]);
target-lm32/helper.c:    if (!env->cpu_watchpoint[idx]) {
target-lm32/helper.c:    cpu_watchpoint_remove_by_ref(CPU(cpu), env->cpu_watchpoint[idx]);
target-lm32/helper.c:    env->cpu_watchpoint[idx] = NULL;
target-lm32/helper.c:        if (env->cpu_watchpoint[i] &&
target-lm32/helper.c:                env->cpu_watchpoint[i]->flags & BP_WATCHPOINT_HIT) {
target-lm32/helper.c:            if (bp->pc == env->pc) {
target-lm32/helper.c:            "exception at pc=%x type=%x\n", env->pc, cs->exception_index);
target-lm32/helper.c:                env->pc += 4;
target-lm32/helper.c:        env->regs[R_EA] = env->pc;
target-lm32/helper.c:        env->ie |= (env->ie & IE_IE) ? IE_EIE : 0;
target-lm32/helper.c:        env->ie &= ~IE_IE;
target-lm32/helper.c:        if (env->dc & DC_RE) {
target-lm32/helper.c:            env->pc = env->deba + (cs->exception_index * 32);
target-lm32/helper.c:            env->pc = env->eba + (cs->exception_index * 32);
target-lm32/helper.c:        env->regs[R_BA] = env->pc;
target-lm32/helper.c:        env->ie |= (env->ie & IE_IE) ? IE_BIE : 0;
target-lm32/helper.c:        env->ie &= ~IE_IE;
target-lm32/helper.c:        env->pc = env->deba + (cs->exception_index * 32);
target-lm32/helper.c:        env->flags |= LM32_FLAG_IGNORE_MSB;
target-lm32/helper.c:        env->flags &= ~LM32_FLAG_IGNORE_MSB;
target-lm32/cpu.h:    *pc = env->pc;
target-lm32/cpu.c:    env->cfg = cfg;
target-lm32/cpu.c:    env->flags = 0;
target-lm32/op_helper.c:    env->bp[idx] = bp;
target-lm32/op_helper.c:    env->wp[idx] = wp;
target-lm32/op_helper.c:    wp_type = lm32_wp_type(env->dc, idx);
target-lm32/op_helper.c:    old_dc = env->dc;
target-lm32/op_helper.c:    env->dc = dc;
target-lm32/op_helper.c:                lm32_watchpoint_insert(env, i, env->wp[i], new_type);
target-lm32/op_helper.c:    lm32_pic_set_im(env->pic_state, im);
target-lm32/op_helper.c:    lm32_pic_set_ip(env->pic_state, im);
target-lm32/op_helper.c:    lm32_juart_set_jtx(env->juart_state, jtx);
target-lm32/op_helper.c:    lm32_juart_set_jrx(env->juart_state, jrx);
target-lm32/op_helper.c:    return lm32_pic_get_im(env->pic_state);
target-lm32/op_helper.c:    return lm32_pic_get_ip(env->pic_state);
target-lm32/op_helper.c:    return lm32_juart_get_jtx(env->juart_state);
target-lm32/op_helper.c:    return lm32_juart_get_jrx(env->juart_state);
target-lm32/lm32-semi.c:    nr = env->regs[R_R8];
target-lm32/lm32-semi.c:    arg0 = env->regs[R_R1];
target-lm32/lm32-semi.c:    arg1 = env->regs[R_R2];
target-lm32/lm32-semi.c:    arg2 = env->regs[R_R3];
target-lm32/lm32-semi.c:    env->regs[R_R1] = ret;
softmmu_template.h:    target_ulong tlb_addr = env->tlb_table[mmu_idx][index].ADDR_READ;
softmmu_template.h:        tlb_addr = env->tlb_table[mmu_idx][index].ADDR_READ;
softmmu_template.h:        ioaddr = env->iotlb[mmu_idx][index];
softmmu_template.h:    haddr = addr + env->tlb_table[mmu_idx][index].addend;
softmmu_template.h:    target_ulong tlb_addr = env->tlb_table[mmu_idx][index].ADDR_READ;
softmmu_template.h:        tlb_addr = env->tlb_table[mmu_idx][index].ADDR_READ;
softmmu_template.h:        ioaddr = env->iotlb[mmu_idx][index];
softmmu_template.h:    haddr = addr + env->tlb_table[mmu_idx][index].addend;
softmmu_template.h:    target_ulong tlb_addr = env->tlb_table[mmu_idx][index].addr_write;
softmmu_template.h:        tlb_addr = env->tlb_table[mmu_idx][index].addr_write;
softmmu_template.h:        ioaddr = env->iotlb[mmu_idx][index];
softmmu_template.h:    haddr = addr + env->tlb_table[mmu_idx][index].addend;
softmmu_template.h:    target_ulong tlb_addr = env->tlb_table[mmu_idx][index].addr_write;
softmmu_template.h:        tlb_addr = env->tlb_table[mmu_idx][index].addr_write;
softmmu_template.h:        ioaddr = env->iotlb[mmu_idx][index];
softmmu_template.h:    haddr = addr + env->tlb_table[mmu_idx][index].addend;
target-mips/gdbstub.c:        return gdb_get_regl(mem_buf, env->active_tc.gpr[n]);
target-mips/gdbstub.c:    if (env->CP0_Config1 & (1 << CP0C1_FP)) {
target-mips/gdbstub.c:            if (env->CP0_Status & (1 << CP0St_FR)) {
target-mips/gdbstub.c:                    env->active_fpu.fpr[n - 38].d);
target-mips/gdbstub.c:                    env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX]);
target-mips/gdbstub.c:            return gdb_get_regl(mem_buf, (int32_t)env->active_fpu.fcr31);
target-mips/gdbstub.c:            return gdb_get_regl(mem_buf, (int32_t)env->active_fpu.fcr0);
target-mips/gdbstub.c:        return gdb_get_regl(mem_buf, (int32_t)env->CP0_Status);
target-mips/gdbstub.c:        return gdb_get_regl(mem_buf, env->active_tc.LO[0]);
target-mips/gdbstub.c:        return gdb_get_regl(mem_buf, env->active_tc.HI[0]);
target-mips/gdbstub.c:        return gdb_get_regl(mem_buf, env->CP0_BadVAddr);
target-mips/gdbstub.c:        return gdb_get_regl(mem_buf, (int32_t)env->CP0_Cause);
target-mips/gdbstub.c:        return gdb_get_regl(mem_buf, env->active_tc.PC |
target-mips/gdbstub.c:                                     !!(env->hflags & MIPS_HFLAG_M16));
target-mips/gdbstub.c:        return gdb_get_regl(mem_buf, (int32_t)env->CP0_PRid);
target-mips/gdbstub.c:    set_float_rounding_mode(ieee_rm[env->active_fpu.fcr31 & 3], \
target-mips/gdbstub.c:                            &env->active_fpu.fp_status)
target-mips/gdbstub.c:        env->active_tc.gpr[n] = tmp;
target-mips/gdbstub.c:    if (env->CP0_Config1 & (1 << CP0C1_FP)
target-mips/gdbstub.c:            if (env->CP0_Status & (1 << CP0St_FR)) {
target-mips/gdbstub.c:                env->active_fpu.fpr[n - 38].d = tmp;
target-mips/gdbstub.c:                env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX] = tmp;
target-mips/gdbstub.c:            env->active_fpu.fcr31 = tmp & 0xFF83FFFF;
target-mips/gdbstub.c:            env->active_fpu.fcr0 = tmp;
target-mips/gdbstub.c:        env->CP0_Status = tmp;
target-mips/gdbstub.c:        env->active_tc.LO[0] = tmp;
target-mips/gdbstub.c:        env->active_tc.HI[0] = tmp;
target-mips/gdbstub.c:        env->CP0_BadVAddr = tmp;
target-mips/gdbstub.c:        env->CP0_Cause = tmp;
target-mips/gdbstub.c:        env->active_tc.PC = tmp & ~(target_ulong)1;
target-mips/gdbstub.c:            env->hflags |= MIPS_HFLAG_M16;
target-mips/gdbstub.c:            env->hflags &= ~(MIPS_HFLAG_M16);
target-mips/translate.c:        ctx->btarget = env->btarget;
target-mips/translate.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/translate.c:    if ((env->CP0_VPEConf0 & (1 << CP0VPEC0_MVP)) == 0 &&
target-mips/translate.c:        ((env->tcs[other_tc].CP0_TCBind & (0xf << CP0TCBd_CurVPE)) !=
target-mips/translate.c:         (env->active_tc.CP0_TCBind & (0xf << CP0TCBd_CurVPE))))
target-mips/translate.c:    else if ((env->CP0_VPEControl & (0xff << CP0VPECo_TargTC)) >
target-mips/translate.c:             (env->mvp->CP0_MVPConf0 & (0xff << CP0MVPC0_PTC)))
target-mips/translate.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/translate.c:    if ((env->CP0_VPEConf0 & (1 << CP0VPEC0_MVP)) == 0 &&
target-mips/translate.c:        ((env->tcs[other_tc].CP0_TCBind & (0xf << CP0TCBd_CurVPE)) !=
target-mips/translate.c:         (env->active_tc.CP0_TCBind & (0xf << CP0TCBd_CurVPE))))
target-mips/translate.c:    else if ((env->CP0_VPEControl & (0xff << CP0VPECo_TargTC)) >
target-mips/translate.c:             (env->mvp->CP0_MVPConf0 & (0xff << CP0MVPC0_PTC)))
target-mips/translate.c:        if (!env->tlb->helper_tlbwi)
target-mips/translate.c:        if (!env->tlb->helper_tlbwr)
target-mips/translate.c:        if (!env->tlb->helper_tlbp)
target-mips/translate.c:        if (!env->tlb->helper_tlbr)
target-mips/translate.c:        env->CP0_BadVAddr = ctx->pc;
target-mips/translate.c:        env->CP0_BadVAddr = ctx->pc;
target-mips/translate.c:    ctx.insn_flags = env->insn_flags;
target-mips/translate.c:    ctx.CP0_Config1 = env->CP0_Config1;
target-mips/translate.c:    ctx.ulri = env->CP0_Config3 & (1 << CP0C3_ULRI);
target-mips/translate.c:    int is_fpu64 = !!(env->hflags & MIPS_HFLAG_F64);
target-mips/translate.c:                env->active_fpu.fcr0, env->active_fpu.fcr31, is_fpu64,
target-mips/translate.c:                get_float_exception_flags(&env->active_fpu.fp_status));
target-mips/translate.c:        printfpr(&env->active_fpu.fpr[i]);
target-mips/translate.c:    if (!SIGN_EXT_P(env->active_tc.PC))
target-mips/translate.c:        cpu_fprintf(f, "BROKEN: pc=0x" TARGET_FMT_lx "\n", env->active_tc.PC);
target-mips/translate.c:    if (!SIGN_EXT_P(env->active_tc.HI[0]))
target-mips/translate.c:        cpu_fprintf(f, "BROKEN: HI=0x" TARGET_FMT_lx "\n", env->active_tc.HI[0]);
target-mips/translate.c:    if (!SIGN_EXT_P(env->active_tc.LO[0]))
target-mips/translate.c:        cpu_fprintf(f, "BROKEN: LO=0x" TARGET_FMT_lx "\n", env->active_tc.LO[0]);
target-mips/translate.c:    if (!SIGN_EXT_P(env->btarget))
target-mips/translate.c:        cpu_fprintf(f, "BROKEN: btarget=0x" TARGET_FMT_lx "\n", env->btarget);
target-mips/translate.c:        if (!SIGN_EXT_P(env->active_tc.gpr[i]))
target-mips/translate.c:            cpu_fprintf(f, "BROKEN: %s=0x" TARGET_FMT_lx "\n", regnames[i], env->active_tc.gpr[i]);
target-mips/translate.c:    if (!SIGN_EXT_P(env->CP0_EPC))
target-mips/translate.c:        cpu_fprintf(f, "BROKEN: EPC=0x" TARGET_FMT_lx "\n", env->CP0_EPC);
target-mips/translate.c:    if (!SIGN_EXT_P(env->lladdr))
target-mips/translate.c:        cpu_fprintf(f, "BROKEN: LLAddr=0x" TARGET_FMT_lx "\n", env->lladdr);
target-mips/translate.c:                env->active_tc.PC, env->active_tc.HI[0], env->active_tc.LO[0],
target-mips/translate.c:                env->hflags, env->btarget, env->bcond);
target-mips/translate.c:        cpu_fprintf(f, " %s " TARGET_FMT_lx, regnames[i], env->active_tc.gpr[i]);
target-mips/translate.c:                env->CP0_Status, env->CP0_Cause, env->CP0_EPC);
target-mips/translate.c:                env->CP0_Config0, env->CP0_Config1, env->lladdr);
target-mips/translate.c:    if (env->hflags & MIPS_HFLAG_FPU)
target-mips/translate.c:    env->cpu_model = def;
target-mips/translate.c:    env->CP0_PRid = env->cpu_model->CP0_PRid;
target-mips/translate.c:    env->CP0_Config0 = env->cpu_model->CP0_Config0;
target-mips/translate.c:    env->CP0_Config0 |= (1 << CP0C0_BE);
target-mips/translate.c:    env->CP0_Config1 = env->cpu_model->CP0_Config1;
target-mips/translate.c:    env->CP0_Config2 = env->cpu_model->CP0_Config2;
target-mips/translate.c:    env->CP0_Config3 = env->cpu_model->CP0_Config3;
target-mips/translate.c:    env->CP0_Config4 = env->cpu_model->CP0_Config4;
target-mips/translate.c:    env->CP0_Config4_rw_bitmask = env->cpu_model->CP0_Config4_rw_bitmask;
target-mips/translate.c:    env->CP0_Config5 = env->cpu_model->CP0_Config5;
target-mips/translate.c:    env->CP0_Config5_rw_bitmask = env->cpu_model->CP0_Config5_rw_bitmask;
target-mips/translate.c:    env->CP0_Config6 = env->cpu_model->CP0_Config6;
target-mips/translate.c:    env->CP0_Config7 = env->cpu_model->CP0_Config7;
target-mips/translate.c:    env->CP0_LLAddr_rw_bitmask = env->cpu_model->CP0_LLAddr_rw_bitmask
target-mips/translate.c:                                 << env->cpu_model->CP0_LLAddr_shift;
target-mips/translate.c:    env->CP0_LLAddr_shift = env->cpu_model->CP0_LLAddr_shift;
target-mips/translate.c:    env->SYNCI_Step = env->cpu_model->SYNCI_Step;
target-mips/translate.c:    env->CCRes = env->cpu_model->CCRes;
target-mips/translate.c:    env->CP0_Status_rw_bitmask = env->cpu_model->CP0_Status_rw_bitmask;
target-mips/translate.c:    env->CP0_TCStatus_rw_bitmask = env->cpu_model->CP0_TCStatus_rw_bitmask;
target-mips/translate.c:    env->CP0_SRSCtl = env->cpu_model->CP0_SRSCtl;
target-mips/translate.c:    env->current_tc = 0;
target-mips/translate.c:    env->SEGBITS = env->cpu_model->SEGBITS;
target-mips/translate.c:    env->SEGMask = (target_ulong)((1ULL << env->cpu_model->SEGBITS) - 1);
target-mips/translate.c:    if (env->cpu_model->insn_flags & ISA_MIPS3) {
target-mips/translate.c:        env->SEGMask |= 3ULL << 62;
target-mips/translate.c:    env->PABITS = env->cpu_model->PABITS;
target-mips/translate.c:    env->PAMask = (target_ulong)((1ULL << env->cpu_model->PABITS) - 1);
target-mips/translate.c:    env->CP0_SRSConf0_rw_bitmask = env->cpu_model->CP0_SRSConf0_rw_bitmask;
target-mips/translate.c:    env->CP0_SRSConf0 = env->cpu_model->CP0_SRSConf0;
target-mips/translate.c:    env->CP0_SRSConf1_rw_bitmask = env->cpu_model->CP0_SRSConf1_rw_bitmask;
target-mips/translate.c:    env->CP0_SRSConf1 = env->cpu_model->CP0_SRSConf1;
target-mips/translate.c:    env->CP0_SRSConf2_rw_bitmask = env->cpu_model->CP0_SRSConf2_rw_bitmask;
target-mips/translate.c:    env->CP0_SRSConf2 = env->cpu_model->CP0_SRSConf2;
target-mips/translate.c:    env->CP0_SRSConf3_rw_bitmask = env->cpu_model->CP0_SRSConf3_rw_bitmask;
target-mips/translate.c:    env->CP0_SRSConf3 = env->cpu_model->CP0_SRSConf3;
target-mips/translate.c:    env->CP0_SRSConf4_rw_bitmask = env->cpu_model->CP0_SRSConf4_rw_bitmask;
target-mips/translate.c:    env->CP0_SRSConf4 = env->cpu_model->CP0_SRSConf4;
target-mips/translate.c:    env->active_fpu.fcr0 = env->cpu_model->CP1_fcr0;
target-mips/translate.c:    env->insn_flags = env->cpu_model->insn_flags;
target-mips/translate.c:    env->CP0_Status = (MIPS_HFLAG_UM << CP0St_KSU);
target-mips/translate.c:    env->CP0_Status |= (1 << CP0St_PX);
target-mips/translate.c:    env->CP0_Status |= (1 << CP0St_UX);
target-mips/translate.c:    env->CP0_HWREna |= 0x0000000F;
target-mips/translate.c:    if (env->CP0_Config1 & (1 << CP0C1_FP)) {
target-mips/translate.c:        env->CP0_Status |= (1 << CP0St_CU1);
target-mips/translate.c:    if (env->CP0_Config3 & (1 << CP0C3_DSPP)) {
target-mips/translate.c:        env->CP0_Status |= (1 << CP0St_MX);
target-mips/translate.c:    if ((env->CP0_Config1 & (1 << CP0C1_FP)) &&
target-mips/translate.c:        (env->CP0_Status_rw_bitmask & (1 << CP0St_FR))) {
target-mips/translate.c:        env->CP0_Status |= (1 << CP0St_FR);
target-mips/translate.c:    if (env->hflags & MIPS_HFLAG_BMASK) {
target-mips/translate.c:        env->CP0_ErrorEPC = env->active_tc.PC - 4;
target-mips/translate.c:        env->CP0_ErrorEPC = env->active_tc.PC;
target-mips/translate.c:    env->active_tc.PC = (int32_t)0xBFC00000;
target-mips/translate.c:    env->CP0_Random = env->tlb->nb_tlb - 1;
target-mips/translate.c:    env->tlb->tlb_in_use = env->tlb->nb_tlb;
target-mips/translate.c:    env->CP0_Wired = 0;
target-mips/translate.c:    env->CP0_EBase = (cs->cpu_index & 0x3FF);
target-mips/translate.c:        env->CP0_EBase |= 0x40000000;
target-mips/translate.c:        env->CP0_EBase |= 0x80000000;
target-mips/translate.c:    env->CP0_Status = (1 << CP0St_BEV) | (1 << CP0St_ERL);
target-mips/translate.c:    env->CP0_IntCtl = 0xe0000000;
target-mips/translate.c:            env->CP0_WatchLo[i] = 0;
target-mips/translate.c:            env->CP0_WatchHi[i] = 0x80000000;
target-mips/translate.c:        env->CP0_WatchLo[7] = 0;
target-mips/translate.c:        env->CP0_WatchHi[7] = 0;
target-mips/translate.c:    env->CP0_Debug = (1 << CP0DB_CNT) | (0x1 << CP0DB_VER);
target-mips/translate.c:    if (env->CP0_Config3 & (1 << CP0C3_MT)) {
target-mips/translate.c:        for (i = 0; i < ARRAY_SIZE(env->tcs); i++) {
target-mips/translate.c:            env->tcs[i].CP0_TCBind = cs->cpu_index << CP0TCBd_CurVPE;
target-mips/translate.c:            env->tcs[i].CP0_TCHalt = 1;
target-mips/translate.c:        env->active_tc.CP0_TCHalt = 1;
target-mips/translate.c:            env->mvp->CP0_MVPControl |= (1 << CP0MVPCo_EVP);
target-mips/translate.c:            env->CP0_VPEConf0 |= (1 << CP0VPEC0_MVP) | (1 << CP0VPEC0_VPA);
target-mips/translate.c:            env->active_tc.CP0_TCHalt = 0;
target-mips/translate.c:            env->tcs[0].CP0_TCHalt = 0;
target-mips/translate.c:            env->active_tc.CP0_TCStatus = (1 << CP0TCSt_A);
target-mips/translate.c:            env->tcs[0].CP0_TCStatus = (1 << CP0TCSt_A);
target-mips/translate.c:    env->active_tc.PC = tcg_ctx.gen_opc_pc[pc_pos];
target-mips/translate.c:    env->hflags &= ~MIPS_HFLAG_BMASK;
target-mips/translate.c:    env->hflags |= gen_opc_hflags[pc_pos];
target-mips/translate.c:    switch (env->hflags & MIPS_HFLAG_BMASK_BASE) {
target-mips/translate.c:        env->btarget = gen_opc_btarget[pc_pos];
target-mips/kvm.c:    if (env->CP0_Config1 & (1 << CP0C1_FP)) {
target-mips/kvm.c:        env->CP0_Config1 &= ~(1 << CP0C1_FP);
target-mips/kvm.c:    DPRINTF("%s: %#x\n", __func__, env->CP0_Cause & (1 << (2 + CP0Ca_IP)));
target-mips/kvm.c:    return env->CP0_Cause & (0x1 << (2 + CP0Ca_IP));
target-mips/kvm.c:    err = kvm_mips_get_one_reg(cs, KVM_REG_MIPS_CP0_CAUSE, &env->CP0_Cause);
target-mips/kvm.c:    err = kvm_mips_get_one_reg(cs, KVM_REG_MIPS_CP0_COUNT, &env->CP0_Count);
target-mips/kvm.c:    err = kvm_mips_put_one_reg(cs, KVM_REG_MIPS_CP0_CAUSE, &env->CP0_Cause);
target-mips/kvm.c:    err = kvm_mips_put_one_reg(cs, KVM_REG_MIPS_CP0_COUNT, &env->CP0_Count);
target-mips/kvm.c:    err = kvm_mips_put_one_reg(cs, KVM_REG_MIPS_CP0_INDEX, &env->CP0_Index);
target-mips/kvm.c:                                 &env->CP0_Context);
target-mips/kvm.c:                                 &env->active_tc.CP0_UserLocal);
target-mips/kvm.c:                               &env->CP0_PageMask);
target-mips/kvm.c:    err = kvm_mips_put_one_reg(cs, KVM_REG_MIPS_CP0_WIRED, &env->CP0_Wired);
target-mips/kvm.c:    err = kvm_mips_put_one_reg(cs, KVM_REG_MIPS_CP0_HWRENA, &env->CP0_HWREna);
target-mips/kvm.c:                                 &env->CP0_BadVAddr);
target-mips/kvm.c:                                 &env->CP0_EntryHi);
target-mips/kvm.c:                               &env->CP0_Compare);
target-mips/kvm.c:    err = kvm_mips_put_one_reg(cs, KVM_REG_MIPS_CP0_STATUS, &env->CP0_Status);
target-mips/kvm.c:    err = kvm_mips_put_one_ulreg(cs, KVM_REG_MIPS_CP0_EPC, &env->CP0_EPC);
target-mips/kvm.c:                                 &env->CP0_ErrorEPC);
target-mips/kvm.c:    err = kvm_mips_get_one_reg(cs, KVM_REG_MIPS_CP0_INDEX, &env->CP0_Index);
target-mips/kvm.c:                                 &env->CP0_Context);
target-mips/kvm.c:                                 &env->active_tc.CP0_UserLocal);
target-mips/kvm.c:                               &env->CP0_PageMask);
target-mips/kvm.c:    err = kvm_mips_get_one_reg(cs, KVM_REG_MIPS_CP0_WIRED, &env->CP0_Wired);
target-mips/kvm.c:    err = kvm_mips_get_one_reg(cs, KVM_REG_MIPS_CP0_HWRENA, &env->CP0_HWREna);
target-mips/kvm.c:                                 &env->CP0_BadVAddr);
target-mips/kvm.c:                                 &env->CP0_EntryHi);
target-mips/kvm.c:                               &env->CP0_Compare);
target-mips/kvm.c:    err = kvm_mips_get_one_reg(cs, KVM_REG_MIPS_CP0_STATUS, &env->CP0_Status);
target-mips/kvm.c:    err = kvm_mips_get_one_ulreg(cs, KVM_REG_MIPS_CP0_EPC, &env->CP0_EPC);
target-mips/kvm.c:                                 &env->CP0_ErrorEPC);
target-mips/kvm.c:        regs.gpr[i] = env->active_tc.gpr[i];
target-mips/kvm.c:    regs.hi = env->active_tc.HI[0];
target-mips/kvm.c:    regs.lo = env->active_tc.LO[0];
target-mips/kvm.c:    regs.pc = env->active_tc.PC;
target-mips/kvm.c:        env->active_tc.gpr[i] = regs.gpr[i];
target-mips/kvm.c:    env->active_tc.HI[0] = regs.hi;
target-mips/kvm.c:    env->active_tc.LO[0] = regs.lo;
target-mips/kvm.c:    env->active_tc.PC = regs.pc;
target-mips/helper.c:        if (!(env->CP0_Status & (1 << CP0St_ERL)))
target-mips/helper.c:    uint8_t ASID = env->CP0_EntryHi & 0xFF;
target-mips/helper.c:    for (i = 0; i < env->tlb->tlb_in_use; i++) {
target-mips/helper.c:        r4k_tlb_t *tlb = &env->tlb->mmu.r4k.tlb[i];
target-mips/helper.c:        tag &= env->SEGMask;
target-mips/helper.c:    int user_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_UM;
target-mips/helper.c:    int supervisor_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_SM;
target-mips/helper.c:    int UX = (env->CP0_Status & (1 << CP0St_UX)) != 0;
target-mips/helper.c:    int SX = (env->CP0_Status & (1 << CP0St_SX)) != 0;
target-mips/helper.c:    int KX = (env->CP0_Status & (1 << CP0St_KX)) != 0;
target-mips/helper.c:    qemu_log("user mode %d h %08x\n", user_mode, env->hflags);
target-mips/helper.c:        if (env->CP0_Status & (1 << CP0St_ERL)) {
target-mips/helper.c:            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);
target-mips/helper.c:        if (UX && address <= (0x3FFFFFFFFFFFFFFFULL & env->SEGMask)) {
target-mips/helper.c:            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);
target-mips/helper.c:            SX && address <= (0x7FFFFFFFFFFFFFFFULL & env->SEGMask)) {
target-mips/helper.c:            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);
target-mips/helper.c:            (address & 0x07FFFFFFFFFFFFFFULL) <= env->PAMask) {
target-mips/helper.c:            *physical = address & env->PAMask;
target-mips/helper.c:            address <= (0xFFFFFFFF7FFFFFFFULL & env->SEGMask)) {
target-mips/helper.c:            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);
target-mips/helper.c:            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);
target-mips/helper.c:            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);
target-mips/helper.c:    env->CP0_BadVAddr = address;
target-mips/helper.c:    env->CP0_Context = (env->CP0_Context & ~0x007fffff) |
target-mips/helper.c:    env->CP0_EntryHi =
target-mips/helper.c:        (env->CP0_EntryHi & 0xFF) | (address & (TARGET_PAGE_MASK << 1));
target-mips/helper.c:    env->CP0_EntryHi &= env->SEGMask;
target-mips/helper.c:    env->CP0_XContext = (env->CP0_XContext & ((~0ULL) << (env->SEGBITS - 7))) |
target-mips/helper.c:                        ((address & 0xC00000000000ULL) >> (55 - env->SEGBITS)) |
target-mips/helper.c:                        ((address & ((1ULL << env->SEGBITS) - 1) & 0xFFFFFFFFFFFFE000ULL) >> 9);
target-mips/helper.c:    env->error_code = error_code;
target-mips/helper.c:              __func__, env->active_tc.PC, address, rw, mmu_idx);
target-mips/helper.c:    isa_mode = !!(env->hflags & MIPS_HFLAG_M16);
target-mips/helper.c:    bad_pc = env->active_tc.PC | isa_mode;
target-mips/helper.c:    if (env->hflags & MIPS_HFLAG_BMASK) {
target-mips/helper.c:        bad_pc -= (env->hflags & MIPS_HFLAG_B16 ? 2 : 4);
target-mips/helper.c:    env->hflags &= ~(MIPS_HFLAG_M16);
target-mips/helper.c:    if (env->insn_flags & ASE_MICROMIPS) {
target-mips/helper.c:        env->hflags |= (!!(env->CP0_Config3
target-mips/helper.c:                 __func__, env->active_tc.PC, env->CP0_EPC, name);
target-mips/helper.c:        (env->hflags & MIPS_HFLAG_DM)) {
target-mips/helper.c:        env->CP0_Debug |= 1 << CP0DB_DSS;
target-mips/helper.c:        env->CP0_DEPC = env->active_tc.PC | !!(env->hflags & MIPS_HFLAG_M16);
target-mips/helper.c:        env->CP0_Debug |= 1 << CP0DB_DINT;
target-mips/helper.c:        env->CP0_Debug |= 1 << CP0DB_DIB;
target-mips/helper.c:        env->CP0_Debug |= 1 << CP0DB_DBp;
target-mips/helper.c:        env->CP0_Debug |= 1 << CP0DB_DDBS;
target-mips/helper.c:        env->CP0_Debug |= 1 << CP0DB_DDBL;
target-mips/helper.c:        env->CP0_DEPC = exception_resume_pc(env);
target-mips/helper.c:        env->hflags &= ~MIPS_HFLAG_BMASK;
target-mips/helper.c:        env->hflags |= MIPS_HFLAG_DM | MIPS_HFLAG_64 | MIPS_HFLAG_CP0;
target-mips/helper.c:        env->hflags &= ~(MIPS_HFLAG_KSU);
target-mips/helper.c:        if (!(env->CP0_Status & (1 << CP0St_EXL)))
target-mips/helper.c:            env->CP0_Cause &= ~(1U << CP0Ca_BD);
target-mips/helper.c:        env->active_tc.PC = (int32_t)0xBFC00480;
target-mips/helper.c:        env->CP0_Status |= (1 << CP0St_SR);
target-mips/helper.c:        memset(env->CP0_WatchLo, 0, sizeof(*env->CP0_WatchLo));
target-mips/helper.c:        env->CP0_Status |= (1 << CP0St_NMI);
target-mips/helper.c:        env->CP0_ErrorEPC = exception_resume_pc(env);
target-mips/helper.c:        env->hflags &= ~MIPS_HFLAG_BMASK;
target-mips/helper.c:        env->CP0_Status |= (1 << CP0St_ERL) | (1 << CP0St_BEV);
target-mips/helper.c:        env->hflags |= MIPS_HFLAG_64 | MIPS_HFLAG_CP0;
target-mips/helper.c:        env->hflags &= ~(MIPS_HFLAG_KSU);
target-mips/helper.c:        if (!(env->CP0_Status & (1 << CP0St_EXL)))
target-mips/helper.c:            env->CP0_Cause &= ~(1U << CP0Ca_BD);
target-mips/helper.c:        env->active_tc.PC = (int32_t)0xBFC00000;
target-mips/helper.c:        if (env->CP0_Cause & (1 << CP0Ca_IV))
target-mips/helper.c:        if (env->CP0_Config3 & ((1 << CP0C3_VInt) | (1 << CP0C3_VEIC))) {
target-mips/helper.c:            unsigned int pending = (env->CP0_Cause & CP0Ca_IP_mask) >> 8;
target-mips/helper.c:            pending &= env->CP0_Status >> 8;
target-mips/helper.c:            spacing = (env->CP0_IntCtl >> CP0IntCtl_VS) & ((1 << 6) - 1);
target-mips/helper.c:            if (env->CP0_Config3 & (1 << CP0C3_VInt)) {
target-mips/helper.c:        if (env->error_code == 1 && !(env->CP0_Status & (1 << CP0St_EXL))) {
target-mips/helper.c:            int R = env->CP0_BadVAddr >> 62;
target-mips/helper.c:            int UX = (env->CP0_Status & (1 << CP0St_UX)) != 0;
target-mips/helper.c:            int SX = (env->CP0_Status & (1 << CP0St_SX)) != 0;
target-mips/helper.c:            int KX = (env->CP0_Status & (1 << CP0St_KX)) != 0;
target-mips/helper.c:                (!(env->insn_flags & (INSN_LOONGSON2E | INSN_LOONGSON2F))))
target-mips/helper.c:        if (env->error_code == 1 && !(env->CP0_Status & (1 << CP0St_EXL))) {
target-mips/helper.c:            int R = env->CP0_BadVAddr >> 62;
target-mips/helper.c:            int UX = (env->CP0_Status & (1 << CP0St_UX)) != 0;
target-mips/helper.c:            int SX = (env->CP0_Status & (1 << CP0St_SX)) != 0;
target-mips/helper.c:            int KX = (env->CP0_Status & (1 << CP0St_KX)) != 0;
target-mips/helper.c:                (!(env->insn_flags & (INSN_LOONGSON2E | INSN_LOONGSON2F))))
target-mips/helper.c:        env->CP0_Cause = (env->CP0_Cause & ~(0x3 << CP0Ca_CE)) |
target-mips/helper.c:                         (env->error_code << CP0Ca_CE);
target-mips/helper.c:        if (env->CP0_Status & (1 << CP0St_BEV)) {
target-mips/helper.c:        if (!(env->CP0_Status & (1 << CP0St_EXL))) {
target-mips/helper.c:            env->CP0_EPC = exception_resume_pc(env);
target-mips/helper.c:            if (env->hflags & MIPS_HFLAG_BMASK) {
target-mips/helper.c:                env->CP0_Cause |= (1U << CP0Ca_BD);
target-mips/helper.c:                env->CP0_Cause &= ~(1U << CP0Ca_BD);
target-mips/helper.c:            env->CP0_Status |= (1 << CP0St_EXL);
target-mips/helper.c:            env->hflags |= MIPS_HFLAG_64 | MIPS_HFLAG_CP0;
target-mips/helper.c:            env->hflags &= ~(MIPS_HFLAG_KSU);
target-mips/helper.c:        env->hflags &= ~MIPS_HFLAG_BMASK;
target-mips/helper.c:        if (env->CP0_Status & (1 << CP0St_BEV)) {
target-mips/helper.c:            env->active_tc.PC = (int32_t)0xBFC00200;
target-mips/helper.c:            env->active_tc.PC = (int32_t)(env->CP0_EBase & ~0x3ff);
target-mips/helper.c:        env->active_tc.PC += offset;
target-mips/helper.c:        env->CP0_Cause = (env->CP0_Cause & ~(0x1f << CP0Ca_EC)) | (cause << CP0Ca_EC);
target-mips/helper.c:                __func__, env->active_tc.PC, env->CP0_EPC, cause,
target-mips/helper.c:                env->CP0_Status, env->CP0_Cause, env->CP0_BadVAddr,
target-mips/helper.c:                env->CP0_DEPC);
target-mips/helper.c:    uint8_t ASID = env->CP0_EntryHi & 0xFF;
target-mips/helper.c:    tlb = &env->tlb->mmu.r4k.tlb[idx];
target-mips/helper.c:    if (use_extra && env->tlb->tlb_in_use < MIPS_TLB_MAX) {
target-mips/helper.c:        env->tlb->mmu.r4k.tlb[env->tlb->tlb_in_use] = *tlb;
target-mips/helper.c:        env->tlb->tlb_in_use++;
target-mips/helper.c:        if (addr >= (0xFFFFFFFF80000000ULL & env->SEGMask)) {
target-mips/helper.c:        if (addr >= (0xFFFFFFFF80000000ULL & env->SEGMask)) {
target-mips/machine.c:    save_tc(f, &env->active_tc);
target-mips/machine.c:    save_fpu(f, &env->active_fpu);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->mvp->CP0_MVPControl);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->mvp->CP0_MVPConf0);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->mvp->CP0_MVPConf1);
target-mips/machine.c:    qemu_put_be32s(f, &env->tlb->nb_tlb);
target-mips/machine.c:    qemu_put_be32s(f, &env->tlb->tlb_in_use);
target-mips/machine.c:        uint16_t flags = ((env->tlb->mmu.r4k.tlb[i].G << 10) |
target-mips/machine.c:                          (env->tlb->mmu.r4k.tlb[i].C0 << 7) |
target-mips/machine.c:                          (env->tlb->mmu.r4k.tlb[i].C1 << 4) |
target-mips/machine.c:                          (env->tlb->mmu.r4k.tlb[i].V0 << 3) |
target-mips/machine.c:                          (env->tlb->mmu.r4k.tlb[i].V1 << 2) |
target-mips/machine.c:                          (env->tlb->mmu.r4k.tlb[i].D0 << 1) |
target-mips/machine.c:                          (env->tlb->mmu.r4k.tlb[i].D1 << 0));
target-mips/machine.c:        qemu_put_betls(f, &env->tlb->mmu.r4k.tlb[i].VPN);
target-mips/machine.c:        qemu_put_be32s(f, &env->tlb->mmu.r4k.tlb[i].PageMask);
target-mips/machine.c:        asid = env->tlb->mmu.r4k.tlb[i].ASID;
target-mips/machine.c:        qemu_put_betls(f, &env->tlb->mmu.r4k.tlb[i].PFN[0]);
target-mips/machine.c:        qemu_put_betls(f, &env->tlb->mmu.r4k.tlb[i].PFN[1]);
target-mips/machine.c:    qemu_put_be32s(f, &env->current_tc);
target-mips/machine.c:    qemu_put_be32s(f, &env->current_fpu);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->error_code);
target-mips/machine.c:    qemu_put_be32s(f, &env->hflags);
target-mips/machine.c:    qemu_put_betls(f, &env->btarget);
target-mips/machine.c:    i = env->bcond;
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Index);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Random);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_VPEControl);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_VPEConf0);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_VPEConf1);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_YQMask);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_VPESchedule);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_VPEScheFBack);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_VPEOpt);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_EntryLo0);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_EntryLo1);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_Context);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_PageMask);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_PageGrain);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Wired);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_SRSConf0);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_SRSConf1);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_SRSConf2);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_SRSConf3);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_SRSConf4);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_HWREna);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_BadVAddr);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Count);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_EntryHi);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Compare);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Status);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_IntCtl);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_SRSCtl);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_SRSMap);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Cause);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_EPC);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_PRid);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_EBase);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Config0);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Config1);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Config2);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Config3);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Config6);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Config7);
target-mips/machine.c:    qemu_put_betls(f, &env->lladdr);
target-mips/machine.c:        qemu_put_betls(f, &env->CP0_WatchLo[i]);
target-mips/machine.c:        qemu_put_sbe32s(f, &env->CP0_WatchHi[i]);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_XContext);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Framemask);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Debug);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_DEPC);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Performance0);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_TagLo);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_DataLo);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_TagHi);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_DataHi);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_ErrorEPC);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_DESAVE);
target-mips/machine.c:        save_tc(f, &env->tcs[i]);
target-mips/machine.c:        save_fpu(f, &env->fpus[i]);
target-mips/machine.c:    load_tc(f, &env->active_tc, version_id);
target-mips/machine.c:    load_fpu(f, &env->active_fpu);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->mvp->CP0_MVPControl);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->mvp->CP0_MVPConf0);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->mvp->CP0_MVPConf1);
target-mips/machine.c:    qemu_get_be32s(f, &env->tlb->nb_tlb);
target-mips/machine.c:    qemu_get_be32s(f, &env->tlb->tlb_in_use);
target-mips/machine.c:        qemu_get_betls(f, &env->tlb->mmu.r4k.tlb[i].VPN);
target-mips/machine.c:        qemu_get_be32s(f, &env->tlb->mmu.r4k.tlb[i].PageMask);
target-mips/machine.c:        env->tlb->mmu.r4k.tlb[i].ASID = asid;
target-mips/machine.c:        env->tlb->mmu.r4k.tlb[i].G = (flags >> 10) & 1;
target-mips/machine.c:        env->tlb->mmu.r4k.tlb[i].C0 = (flags >> 7) & 3;
target-mips/machine.c:        env->tlb->mmu.r4k.tlb[i].C1 = (flags >> 4) & 3;
target-mips/machine.c:        env->tlb->mmu.r4k.tlb[i].V0 = (flags >> 3) & 1;
target-mips/machine.c:        env->tlb->mmu.r4k.tlb[i].V1 = (flags >> 2) & 1;
target-mips/machine.c:        env->tlb->mmu.r4k.tlb[i].D0 = (flags >> 1) & 1;
target-mips/machine.c:        env->tlb->mmu.r4k.tlb[i].D1 = (flags >> 0) & 1;
target-mips/machine.c:        qemu_get_betls(f, &env->tlb->mmu.r4k.tlb[i].PFN[0]);
target-mips/machine.c:        qemu_get_betls(f, &env->tlb->mmu.r4k.tlb[i].PFN[1]);
target-mips/machine.c:    qemu_get_be32s(f, &env->current_tc);
target-mips/machine.c:    qemu_get_be32s(f, &env->current_fpu);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->error_code);
target-mips/machine.c:    qemu_get_be32s(f, &env->hflags);
target-mips/machine.c:    qemu_get_betls(f, &env->btarget);
target-mips/machine.c:    env->bcond = i;
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Index);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Random);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_VPEControl);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_VPEConf0);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_VPEConf1);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_YQMask);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_VPESchedule);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_VPEScheFBack);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_VPEOpt);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_EntryLo0);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_EntryLo1);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_Context);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_PageMask);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_PageGrain);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Wired);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_SRSConf0);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_SRSConf1);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_SRSConf2);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_SRSConf3);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_SRSConf4);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_HWREna);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_BadVAddr);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Count);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_EntryHi);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Compare);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Status);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_IntCtl);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_SRSCtl);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_SRSMap);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Cause);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_EPC);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_PRid);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_EBase);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Config0);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Config1);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Config2);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Config3);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Config6);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Config7);
target-mips/machine.c:    qemu_get_betls(f, &env->lladdr);
target-mips/machine.c:        qemu_get_betls(f, &env->CP0_WatchLo[i]);
target-mips/machine.c:        qemu_get_sbe32s(f, &env->CP0_WatchHi[i]);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_XContext);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Framemask);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Debug);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_DEPC);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Performance0);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_TagLo);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_DataLo);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_TagHi);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_DataHi);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_ErrorEPC);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_DESAVE);
target-mips/machine.c:        load_tc(f, &env->tcs[i], version_id);
target-mips/machine.c:        load_fpu(f, &env->fpus[i]);
target-mips/cpu.h:    return env->hflags & MIPS_HFLAG_KSU;
target-mips/cpu.h:    if (!(env->CP0_Status & (1 << CP0St_IE)) ||
target-mips/cpu.h:        (env->CP0_Status & (1 << CP0St_EXL)) ||
target-mips/cpu.h:        (env->CP0_Status & (1 << CP0St_ERL)) ||
target-mips/cpu.h:        (env->active_tc.CP0_TCStatus & (1 << CP0TCSt_IXMT)) ||
target-mips/cpu.h:        (env->hflags & MIPS_HFLAG_DM)) {
target-mips/cpu.h:    pending = env->CP0_Cause & CP0Ca_IP_mask;
target-mips/cpu.h:    status = env->CP0_Status & CP0Ca_IP_mask;
target-mips/cpu.h:    if (env->CP0_Config3 & (1 << CP0C3_VEIC)) {
target-mips/cpu.h:    *pc = env->active_tc.PC;
target-mips/cpu.h:    *flags = env->hflags & (MIPS_HFLAG_TMASK | MIPS_HFLAG_BMASK |
target-mips/cpu.h:    if (!(env->mvp->CP0_MVPControl & (1 << CP0MVPCo_EVP))) {
target-mips/cpu.h:    if (!(env->CP0_VPEConf0 & (1 << CP0VPEC0_VPA))) {
target-mips/cpu.h:    if (!(env->active_tc.CP0_TCStatus & (1 << CP0TCSt_A))) {
target-mips/cpu.h:    if (env->active_tc.CP0_TCHalt & 1) {
target-mips/cpu.h:    env->hflags &= ~(MIPS_HFLAG_COP1X | MIPS_HFLAG_64 | MIPS_HFLAG_CP0 |
target-mips/cpu.h:    if (!(env->CP0_Status & (1 << CP0St_EXL)) &&
target-mips/cpu.h:        !(env->CP0_Status & (1 << CP0St_ERL)) &&
target-mips/cpu.h:        !(env->hflags & MIPS_HFLAG_DM)) {
target-mips/cpu.h:        env->hflags |= (env->CP0_Status >> CP0St_KSU) & MIPS_HFLAG_KSU;
target-mips/cpu.h:    if (((env->hflags & MIPS_HFLAG_KSU) != MIPS_HFLAG_UM) ||
target-mips/cpu.h:        (env->CP0_Status & (1 << CP0St_PX)) ||
target-mips/cpu.h:        (env->CP0_Status & (1 << CP0St_UX))) {
target-mips/cpu.h:        env->hflags |= MIPS_HFLAG_64;
target-mips/cpu.h:    if (env->CP0_Status & (1 << CP0St_UX)) {
target-mips/cpu.h:        env->hflags |= MIPS_HFLAG_UX;
target-mips/cpu.h:    if ((env->CP0_Status & (1 << CP0St_CU0)) ||
target-mips/cpu.h:        !(env->hflags & MIPS_HFLAG_KSU)) {
target-mips/cpu.h:        env->hflags |= MIPS_HFLAG_CP0;
target-mips/cpu.h:    if (env->CP0_Status & (1 << CP0St_CU1)) {
target-mips/cpu.h:        env->hflags |= MIPS_HFLAG_FPU;
target-mips/cpu.h:    if (env->CP0_Status & (1 << CP0St_FR)) {
target-mips/cpu.h:        env->hflags |= MIPS_HFLAG_F64;
target-mips/cpu.h:    if (env->insn_flags & ASE_DSPR2) {
target-mips/cpu.h:        if (env->CP0_Status & (1 << CP0St_MX)) {
target-mips/cpu.h:            env->hflags |= MIPS_HFLAG_DSP | MIPS_HFLAG_DSPR2;
target-mips/cpu.h:    } else if (env->insn_flags & ASE_DSP) {
target-mips/cpu.h:        if (env->CP0_Status & (1 << CP0St_MX)) {
target-mips/cpu.h:            env->hflags |= MIPS_HFLAG_DSP;
target-mips/cpu.h:    if (env->insn_flags & ISA_MIPS32R2) {
target-mips/cpu.h:        if (env->active_fpu.fcr0 & (1 << FCR0_F64)) {
target-mips/cpu.h:            env->hflags |= MIPS_HFLAG_COP1X;
target-mips/cpu.h:    } else if (env->insn_flags & ISA_MIPS32) {
target-mips/cpu.h:        if (env->hflags & MIPS_HFLAG_64) {
target-mips/cpu.h:            env->hflags |= MIPS_HFLAG_COP1X;
target-mips/cpu.h:    } else if (env->insn_flags & ISA_MIPS4) {
target-mips/cpu.h:        if (env->CP0_Status & (1U << CP0St_CU3)) {
target-mips/cpu.h:            env->hflags |= MIPS_HFLAG_COP1X;
target-mips/dsp_helper.c:    env->active_tc.DSPControl |= (target_ulong)flag << position;
target-mips/dsp_helper.c:    env->active_tc.DSPControl &= ~(1 << 13);
target-mips/dsp_helper.c:    env->active_tc.DSPControl |= flag << 13;
target-mips/dsp_helper.c:    return (env->active_tc.DSPControl >> 13) & 0x01;
target-mips/dsp_helper.c:  env->active_tc.DSPControl &= filter;
target-mips/dsp_helper.c:  env->active_tc.DSPControl |= (target_ulong)flag << 24;
target-mips/dsp_helper.c:  return (env->active_tc.DSPControl >> 24) & filter;
target-mips/dsp_helper.c:    dspc = env->active_tc.DSPControl;
target-mips/dsp_helper.c:    env->active_tc.DSPControl = dspc;
target-mips/dsp_helper.c:    dspc = env->active_tc.DSPControl;
target-mips/dsp_helper.c:    env->active_tc.DSPControl &= 0xFFFFBFFF;
target-mips/dsp_helper.c:    env->active_tc.DSPControl |= (target_ulong)flag << 14;
target-mips/dsp_helper.c:    temp = ((uint64_t)env->active_tc.HI[acc] << 32) |
target-mips/dsp_helper.c:           (uint64_t)env->active_tc.LO[acc];
target-mips/dsp_helper.c:    temp = (uint64_t)env->active_tc.LO[acc];
target-mips/dsp_helper.c:    ret[0] = env->active_tc.LO[ac] + a[0];
target-mips/dsp_helper.c:    ret[1] = env->active_tc.HI[ac] + a[1];
target-mips/dsp_helper.c:    if (((uint64_t)ret[0] < (uint64_t)env->active_tc.LO[ac]) &&
target-mips/dsp_helper.c:    ret[0] = env->active_tc.LO[ac] - a[0];
target-mips/dsp_helper.c:    ret[1] = env->active_tc.HI[ac] - a[1];
target-mips/dsp_helper.c:    if ((uint64_t)ret[0] > (uint64_t)env->active_tc.LO[ac]) {
target-mips/dsp_helper.c:    acc = ((int64_t)env->active_tc.HI[ac] << 32) |
target-mips/dsp_helper.c:          ((int64_t)env->active_tc.LO[ac] & 0xFFFFFFFF);
target-mips/dsp_helper.c:    tempB = env->active_tc.HI[ac];
target-mips/dsp_helper.c:    tempA = env->active_tc.LO[ac];
target-mips/dsp_helper.c:    tempB = env->active_tc.HI[ac];
target-mips/dsp_helper.c:    tempA = env->active_tc.LO[ac];
target-mips/dsp_helper.c:    acc = ((uint64_t)env->active_tc.HI[ac] << 32) |                      \
target-mips/dsp_helper.c:          ((uint64_t)env->active_tc.LO[ac] & MIPSDSP_LLO);               \
target-mips/dsp_helper.c:    env->active_tc.HI[ac] = (target_long)(int32_t)                       \
target-mips/dsp_helper.c:    env->active_tc.LO[ac] = (target_long)(int32_t)(dotp & MIPSDSP_LLO);  \
target-mips/dsp_helper.c:    acc[0] = env->active_tc.LO[ac];
target-mips/dsp_helper.c:    acc[1] = env->active_tc.HI[ac];
target-mips/dsp_helper.c:    env->active_tc.HI[ac] = acc[1];
target-mips/dsp_helper.c:    env->active_tc.LO[ac] = acc[0];
target-mips/dsp_helper.c:        tempC = (((uint64_t)env->active_tc.HI[ac] << 32) |               \
target-mips/dsp_helper.c:                 ((uint64_t)env->active_tc.LO[ac] & MIPSDSP_LLO))        \
target-mips/dsp_helper.c:        tempC = (((uint64_t)env->active_tc.HI[ac] << 32) |               \
target-mips/dsp_helper.c:                 ((uint64_t)env->active_tc.LO[ac] & MIPSDSP_LLO))        \
target-mips/dsp_helper.c:    env->active_tc.HI[ac] = (target_long)(int32_t)                       \
target-mips/dsp_helper.c:    env->active_tc.LO[ac] = (target_long)(int32_t)(tempC & MIPSDSP_LLO); \
target-mips/dsp_helper.c:    acc[0] = env->active_tc.LO[ac];                                     \
target-mips/dsp_helper.c:    acc[1] = env->active_tc.HI[ac];                                     \
target-mips/dsp_helper.c:    env->active_tc.HI[ac] = temp[1];                                    \
target-mips/dsp_helper.c:    env->active_tc.LO[ac] = temp[0];                                    \
target-mips/dsp_helper.c:    acc = ((uint64_t)env->active_tc.HI[ac] << 32) |                            \
target-mips/dsp_helper.c:          ((uint64_t)env->active_tc.LO[ac] & MIPSDSP_LLO);                     \
target-mips/dsp_helper.c:    env->active_tc.HI[ac] = (target_long)(int32_t)((acc & MIPSDSP_LHI) >> 32); \
target-mips/dsp_helper.c:    env->active_tc.LO[ac] = (target_long)(int32_t)(acc & MIPSDSP_LLO);         \
target-mips/dsp_helper.c:    acc = ((uint64_t)env->active_tc.HI[ac] << 32) |        \
target-mips/dsp_helper.c:          ((uint64_t)env->active_tc.LO[ac] & MIPSDSP_LLO); \
target-mips/dsp_helper.c:    env->active_tc.HI[ac] = (target_long)(int32_t)         \
target-mips/dsp_helper.c:    env->active_tc.LO[ac] = (target_long)(int32_t)         \
target-mips/dsp_helper.c:    acc = ((uint64_t)env->active_tc.HI[ac] << 32) |                      \
target-mips/dsp_helper.c:          ((uint64_t)env->active_tc.LO[ac] & MIPSDSP_LLO);               \
target-mips/dsp_helper.c:    env->active_tc.HI[ac] = (target_long)(int32_t)                       \
target-mips/dsp_helper.c:    env->active_tc.LO[ac] = (target_long)(int32_t)                       \
target-mips/dsp_helper.c:    acc[1] = env->active_tc.HI[ac];                                  \
target-mips/dsp_helper.c:    acc[0] = env->active_tc.LO[ac];                                  \
target-mips/dsp_helper.c:    env->active_tc.HI[ac] = temp[1];                                 \
target-mips/dsp_helper.c:    env->active_tc.LO[ac] = temp[0];                                 \
target-mips/dsp_helper.c:    acc = ((uint64_t)env->active_tc.HI[ac] << 32) |                    \
target-mips/dsp_helper.c:          ((uint64_t)env->active_tc.LO[ac] & MIPSDSP_LLO);             \
target-mips/dsp_helper.c:    env->active_tc.HI[ac] = (target_long)(int32_t)                     \
target-mips/dsp_helper.c:    env->active_tc.LO[ac] = (target_long)(int32_t)                     \
target-mips/dsp_helper.c:    env->active_tc.HI[ac] = acc[1];                               \
target-mips/dsp_helper.c:    env->active_tc.LO[ac] = acc[0];                               \
target-mips/dsp_helper.c:    acc[0] = env->active_tc.LO[ac];
target-mips/dsp_helper.c:    acc[1] = env->active_tc.HI[ac];
target-mips/dsp_helper.c:    env->active_tc.HI[ac] = acc[1];
target-mips/dsp_helper.c:    env->active_tc.LO[ac] = acc[0];
target-mips/dsp_helper.c:    acc = ((uint64_t)env->active_tc.HI[ac] << 32) |               \
target-mips/dsp_helper.c:          ((uint64_t)env->active_tc.LO[ac] & MIPSDSP_LLO);        \
target-mips/dsp_helper.c:    env->active_tc.HI[ac] = (target_long)(int32_t)                \
target-mips/dsp_helper.c:    env->active_tc.LO[ac] = (target_long)(int32_t)                \
target-mips/dsp_helper.c:    env->active_tc.HI[ac] = (target_long)(int32_t)(((int64_t)tempA &     \
target-mips/dsp_helper.c:    env->active_tc.LO[ac] = (target_long)(int32_t)((int64_t)tempA &      \
target-mips/dsp_helper.c:    acc[0] = env->active_tc.LO[ac];                               \
target-mips/dsp_helper.c:    acc[1] = env->active_tc.HI[ac];                               \
target-mips/dsp_helper.c:    env->active_tc.HI[ac] = acc[1];                               \
target-mips/dsp_helper.c:    env->active_tc.LO[ac] = acc[0];                               \
target-mips/dsp_helper.c:    env->active_tc.HI[ac] = acc[1];                               \
target-mips/dsp_helper.c:    env->active_tc.LO[ac] = acc[0];                               \
target-mips/dsp_helper.c:    acc[0] = env->active_tc.LO[ac];                               \
target-mips/dsp_helper.c:    acc[1] = env->active_tc.HI[ac];                               \
target-mips/dsp_helper.c:    env->active_tc.HI[ac] = acc[1];                               \
target-mips/dsp_helper.c:    env->active_tc.LO[ac] = acc[0];                               \
target-mips/dsp_helper.c:    acc[1] = env->active_tc.HI[ac];                                  \
target-mips/dsp_helper.c:    acc[0] = env->active_tc.LO[ac];                                  \
target-mips/dsp_helper.c:    env->active_tc.HI[ac] = temp[1];                                 \
target-mips/dsp_helper.c:    env->active_tc.LO[ac] = temp[0];                                 \
target-mips/dsp_helper.c:    dspc = env->active_tc.DSPControl;                           \
target-mips/dsp_helper.c:    dsp = env->active_tc.DSPControl;                           \
target-mips/dsp_helper.c:    acc = ((int64_t)env->active_tc.HI[ac] << 32) |
target-mips/dsp_helper.c:          ((int64_t)env->active_tc.LO[ac] & 0xFFFFFFFF);
target-mips/dsp_helper.c:        acc = ((uint64_t)env->active_tc.HI[ac] << 32) |
target-mips/dsp_helper.c:              ((uint64_t)env->active_tc.LO[ac] & MIPSDSP_LLO);
target-mips/dsp_helper.c:        acc  = ((uint64_t)env->active_tc.HI[ac] << 32) |
target-mips/dsp_helper.c:               ((uint64_t)env->active_tc.LO[ac] & MIPSDSP_LLO);
target-mips/dsp_helper.c:    tempB = env->active_tc.HI[ac];
target-mips/dsp_helper.c:    tempA = env->active_tc.LO[ac];
target-mips/dsp_helper.c:    tempB = env->active_tc.HI[ac];
target-mips/dsp_helper.c:    tempA = env->active_tc.LO[ac];
target-mips/dsp_helper.c:    acc   = (((uint64_t)env->active_tc.HI[ac] << 32) & MIPSDSP_LHI) |
target-mips/dsp_helper.c:            ((uint64_t)env->active_tc.LO[ac] & MIPSDSP_LLO);
target-mips/dsp_helper.c:    env->active_tc.HI[ac] = (target_ulong)(int32_t)((temp & MIPSDSP_LHI) >> 32);
target-mips/dsp_helper.c:    env->active_tc.LO[ac] = (target_ulong)(int32_t)(temp & MIPSDSP_LLO);
target-mips/dsp_helper.c:    tempB = env->active_tc.HI[ac];
target-mips/dsp_helper.c:    tempA = env->active_tc.LO[ac];
target-mips/dsp_helper.c:    env->active_tc.HI[ac] = tempB;
target-mips/dsp_helper.c:    env->active_tc.LO[ac] = tempA;
target-mips/dsp_helper.c:    tempB = env->active_tc.LO[ac];
target-mips/dsp_helper.c:    env->active_tc.HI[ac] = (target_long)tempB;
target-mips/dsp_helper.c:    env->active_tc.LO[ac] = (target_long)tempA;
target-mips/dsp_helper.c:    tempB = env->active_tc.LO[ac_t];
target-mips/dsp_helper.c:    env->active_tc.HI[ac_t] = tempB;
target-mips/dsp_helper.c:    env->active_tc.LO[ac_t] = tempA;
target-mips/dsp_helper.c:    dsp = env->active_tc.DSPControl;
target-mips/dsp_helper.c:    env->active_tc.DSPControl = dsp;
target-mips/dsp_helper.c:    dsp = env->active_tc.DSPControl;
target-mips/cpu.c:    env->active_tc.PC = value & ~(target_ulong)1;
target-mips/cpu.c:        env->hflags |= MIPS_HFLAG_M16;
target-mips/cpu.c:        env->hflags &= ~(MIPS_HFLAG_M16);
target-mips/cpu.c:    env->active_tc.PC = tb->pc;
target-mips/cpu.c:    env->hflags &= ~MIPS_HFLAG_BMASK;
target-mips/cpu.c:    env->hflags |= tb->flags & MIPS_HFLAG_BMASK;
target-mips/cpu.c:    if (env->CP0_Config3 & (1 << CP0C3_MT)) {
target-mips/op_helper.c:    env->error_code = error_code;
target-mips/op_helper.c:    return ((uint64_t)(env->active_tc.HI[0]) << 32) | (uint32_t)env->active_tc.LO[0];
target-mips/op_helper.c:    env->active_tc.LO[0] = (int32_t)(HILO & 0xFFFFFFFF);
target-mips/op_helper.c:    tmp = env->active_tc.HI[0] = (int32_t)(HILO >> 32);
target-mips/op_helper.c:    target_ulong tmp = env->active_tc.LO[0] = (int32_t)(HILO & 0xFFFFFFFF);
target-mips/op_helper.c:    env->active_tc.HI[0] = (int32_t)(HILO >> 32);
target-mips/op_helper.c:    env->lladdr = do_translate_address(env, arg, 0);                          \
target-mips/op_helper.c:    env->llval = do_##insn(env, arg, mem_idx);                                \
target-mips/op_helper.c:    return env->llval;                                                        \
target-mips/op_helper.c:        env->CP0_BadVAddr = arg2;                                             \
target-mips/op_helper.c:    if (do_translate_address(env, arg2, 1) == env->lladdr) {                  \
target-mips/op_helper.c:        if (tmp == env->llval) {                                              \
target-mips/op_helper.c:            env->active_tc.gpr[multiple_regs[i]] =
target-mips/op_helper.c:        env->active_tc.gpr[31] = (target_long)do_lw(env, addr, mem_idx);
target-mips/op_helper.c:            do_sw(env, addr, env->active_tc.gpr[multiple_regs[i]], mem_idx);
target-mips/op_helper.c:        do_sw(env, addr, env->active_tc.gpr[31], mem_idx);
target-mips/op_helper.c:            env->active_tc.gpr[multiple_regs[i]] = do_ld(env, addr, mem_idx);
target-mips/op_helper.c:        env->active_tc.gpr[31] = do_ld(env, addr, mem_idx);
target-mips/op_helper.c:            do_sd(env, addr, env->active_tc.gpr[multiple_regs[i]], mem_idx);
target-mips/op_helper.c:        do_sd(env, addr, env->active_tc.gpr[31], mem_idx);
target-mips/op_helper.c:    if (!(env->CP0_VPEConf0 & (1 << CP0VPEC0_MVP))) {
target-mips/op_helper.c:        *tc = env->current_tc;
target-mips/op_helper.c:    asid = env->CP0_EntryHi & 0xff;
target-mips/op_helper.c:    return env->mvp->CP0_MVPControl;
target-mips/op_helper.c:    return env->mvp->CP0_MVPConf0;
target-mips/op_helper.c:    return env->mvp->CP0_MVPConf1;
target-mips/op_helper.c:    return env->active_tc.CP0_TCStatus;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    return env->active_tc.CP0_TCBind;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    return env->active_tc.PC;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    return env->active_tc.CP0_TCHalt;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    return env->active_tc.CP0_TCContext;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    return env->active_tc.CP0_TCSchedule;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    return env->active_tc.CP0_TCScheFBack;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    return (int32_t)(env->lladdr >> env->CP0_LLAddr_shift);
target-mips/op_helper.c:    return (int32_t)env->CP0_WatchLo[sel];
target-mips/op_helper.c:    return env->CP0_WatchHi[sel];
target-mips/op_helper.c:    target_ulong t0 = env->CP0_Debug;
target-mips/op_helper.c:    if (env->hflags & MIPS_HFLAG_DM)
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    return env->active_tc.PC;
target-mips/op_helper.c:    return env->active_tc.CP0_TCHalt;
target-mips/op_helper.c:    return env->active_tc.CP0_TCContext;
target-mips/op_helper.c:    return env->active_tc.CP0_TCSchedule;
target-mips/op_helper.c:    return env->active_tc.CP0_TCScheFBack;
target-mips/op_helper.c:    return env->lladdr >> env->CP0_LLAddr_shift;
target-mips/op_helper.c:    return env->CP0_WatchLo[sel];
target-mips/op_helper.c:    unsigned int tmp = env->tlb->nb_tlb;
target-mips/op_helper.c:    env->CP0_Index = (env->CP0_Index & 0x80000000) | (arg1 & (num - 1));
target-mips/op_helper.c:    if (env->CP0_VPEConf0 & (1 << CP0VPEC0_MVP))
target-mips/op_helper.c:    if (env->mvp->CP0_MVPControl & (1 << CP0MVPCo_VPC))
target-mips/op_helper.c:    newval = (env->mvp->CP0_MVPControl & ~mask) | (arg1 & mask);
target-mips/op_helper.c:    env->mvp->CP0_MVPControl = newval;
target-mips/op_helper.c:    newval = (env->CP0_VPEControl & ~mask) | (arg1 & mask);
target-mips/op_helper.c:    env->CP0_VPEControl = newval;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    if (env->CP0_VPEConf0 & (1 << CP0VPEC0_MVP)) {
target-mips/op_helper.c:        if (env->CP0_VPEConf0 & (1 << CP0VPEC0_VPA))
target-mips/op_helper.c:    newval = (env->CP0_VPEConf0 & ~mask) | (arg1 & mask);
target-mips/op_helper.c:    env->CP0_VPEConf0 = newval;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    if (env->mvp->CP0_MVPControl & (1 << CP0MVPCo_VPC))
target-mips/op_helper.c:    newval = (env->CP0_VPEConf1 & ~mask) | (arg1 & mask);
target-mips/op_helper.c:    env->CP0_VPEConf1 = newval;
target-mips/op_helper.c:    env->CP0_YQMask = 0x00000000;
target-mips/op_helper.c:    env->CP0_VPEOpt = arg1 & 0x0000ffff;
target-mips/op_helper.c:    env->CP0_EntryLo0 = arg1 & 0x3FFFFFFF;
target-mips/op_helper.c:    uint32_t mask = env->CP0_TCStatus_rw_bitmask;
target-mips/op_helper.c:    newval = (env->active_tc.CP0_TCStatus & ~mask) | (arg1 & mask);
target-mips/op_helper.c:    env->active_tc.CP0_TCStatus = newval;
target-mips/op_helper.c:    sync_c0_tcstatus(env, env->current_tc, newval);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    if (env->mvp->CP0_MVPControl & (1 << CP0MVPCo_VPC))
target-mips/op_helper.c:    newval = (env->active_tc.CP0_TCBind & ~mask) | (arg1 & mask);
target-mips/op_helper.c:    env->active_tc.CP0_TCBind = newval;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    env->active_tc.PC = arg1;
target-mips/op_helper.c:    env->active_tc.CP0_TCStatus &= ~(1 << CP0TCSt_TDS);
target-mips/op_helper.c:    env->lladdr = 0ULL;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    env->active_tc.CP0_TCHalt = arg1 & 0x1;
target-mips/op_helper.c:    if (env->active_tc.CP0_TCHalt & 1) {
target-mips/op_helper.c:        mips_tc_sleep(cpu, env->current_tc);
target-mips/op_helper.c:        mips_tc_wake(cpu, env->current_tc);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    env->active_tc.CP0_TCContext = arg1;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    env->active_tc.CP0_TCSchedule = arg1;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    env->active_tc.CP0_TCScheFBack = arg1;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    env->CP0_EntryLo1 = arg1 & 0x3FFFFFFF;
target-mips/op_helper.c:    env->CP0_Context = (env->CP0_Context & 0x007FFFFF) | (arg1 & ~0x007FFFFF);
target-mips/op_helper.c:    env->CP0_PageMask = arg1 & (0x1FFFFFFF & (TARGET_PAGE_MASK << 1));
target-mips/op_helper.c:    env->CP0_PageGrain = 0;
target-mips/op_helper.c:    env->CP0_Wired = arg1 % env->tlb->nb_tlb;
target-mips/op_helper.c:    env->CP0_SRSConf0 |= arg1 & env->CP0_SRSConf0_rw_bitmask;
target-mips/op_helper.c:    env->CP0_SRSConf1 |= arg1 & env->CP0_SRSConf1_rw_bitmask;
target-mips/op_helper.c:    env->CP0_SRSConf2 |= arg1 & env->CP0_SRSConf2_rw_bitmask;
target-mips/op_helper.c:    env->CP0_SRSConf3 |= arg1 & env->CP0_SRSConf3_rw_bitmask;
target-mips/op_helper.c:    env->CP0_SRSConf4 |= arg1 & env->CP0_SRSConf4_rw_bitmask;
target-mips/op_helper.c:    if (env->CP0_Config3 & (1 << CP0C3_ULRI)) {
target-mips/op_helper.c:            env->hflags |= MIPS_HFLAG_HWRENA_ULR;
target-mips/op_helper.c:            env->hflags &= ~MIPS_HFLAG_HWRENA_ULR;
target-mips/op_helper.c:    env->CP0_HWREna = arg1 & mask;
target-mips/op_helper.c:    val &= env->SEGMask;
target-mips/op_helper.c:    old = env->CP0_EntryHi;
target-mips/op_helper.c:    env->CP0_EntryHi = val;
target-mips/op_helper.c:    if (env->CP0_Config3 & (1 << CP0C3_MT)) {
target-mips/op_helper.c:        sync_c0_entryhi(env, env->current_tc);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    uint32_t mask = env->CP0_Status_rw_bitmask;
target-mips/op_helper.c:    old = env->CP0_Status;
target-mips/op_helper.c:    env->CP0_Status = (env->CP0_Status & ~mask) | val;
target-mips/op_helper.c:    if (env->CP0_Config3 & (1 << CP0C3_MT)) {
target-mips/op_helper.c:        sync_c0_status(env, env, env->current_tc);
target-mips/op_helper.c:                old, old & env->CP0_Cause & CP0Ca_IP_mask,
target-mips/op_helper.c:                val, val & env->CP0_Cause & CP0Ca_IP_mask,
target-mips/op_helper.c:                env->CP0_Cause);
target-mips/op_helper.c:        switch (env->hflags & MIPS_HFLAG_KSU) {
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    env->CP0_IntCtl = (env->CP0_IntCtl & ~0x000003e0) | (arg1 & 0x000003e0);
target-mips/op_helper.c:    env->CP0_SRSCtl = (env->CP0_SRSCtl & ~mask) | (arg1 & mask);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    env->CP0_EBase = (env->CP0_EBase & ~0x3FFFF000) | (arg1 & 0x3FFFF000);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    env->CP0_Config0 = (env->CP0_Config0 & 0x81FFFFF8) | (arg1 & 0x00000007);
target-mips/op_helper.c:    env->CP0_Config2 = (env->CP0_Config2 & 0x8FFF0FFF);
target-mips/op_helper.c:    env->CP0_Config4 = (env->CP0_Config4 & (~env->CP0_Config4_rw_bitmask)) |
target-mips/op_helper.c:                       (arg1 & env->CP0_Config4_rw_bitmask);
target-mips/op_helper.c:    env->CP0_Config5 = (env->CP0_Config5 & (~env->CP0_Config5_rw_bitmask)) |
target-mips/op_helper.c:                       (arg1 & env->CP0_Config5_rw_bitmask);
target-mips/op_helper.c:    target_long mask = env->CP0_LLAddr_rw_bitmask;
target-mips/op_helper.c:    arg1 = arg1 << env->CP0_LLAddr_shift;
target-mips/op_helper.c:    env->lladdr = (env->lladdr & ~mask) | (arg1 & mask);
target-mips/op_helper.c:    env->CP0_WatchLo[sel] = (arg1 & ~0x7);
target-mips/op_helper.c:    env->CP0_WatchHi[sel] = (arg1 & 0x40FF0FF8);
target-mips/op_helper.c:    env->CP0_WatchHi[sel] &= ~(env->CP0_WatchHi[sel] & arg1 & 0x7);
target-mips/op_helper.c:    target_ulong mask = (1ULL << (env->SEGBITS - 7)) - 1;
target-mips/op_helper.c:    env->CP0_XContext = (env->CP0_XContext & mask) | (arg1 & ~mask);
target-mips/op_helper.c:    env->CP0_Framemask = arg1; /* XXX */
target-mips/op_helper.c:    env->CP0_Debug = (env->CP0_Debug & 0x8C03FC1F) | (arg1 & 0x13300120);
target-mips/op_helper.c:        env->hflags |= MIPS_HFLAG_DM;
target-mips/op_helper.c:        env->hflags &= ~MIPS_HFLAG_DM;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    env->CP0_Performance0 = arg1 & 0x000007ff;
target-mips/op_helper.c:    env->CP0_TagLo = arg1 & 0xFFFFFCF6;
target-mips/op_helper.c:    env->CP0_DataLo = arg1; /* XXX */
target-mips/op_helper.c:    env->CP0_TagHi = arg1; /* XXX */
target-mips/op_helper.c:    env->CP0_DataHi = arg1; /* XXX */
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    target_ulong prev = env->mvp->CP0_MVPControl;
target-mips/op_helper.c:    target_ulong prev = env->mvp->CP0_MVPControl;
target-mips/op_helper.c:            if (env->CP0_VPEControl & (1 << CP0VPECo_YSI) &&
target-mips/op_helper.c:                env->active_tc.CP0_TCStatus & (1 << CP0TCSt_DT)) {
target-mips/op_helper.c:                env->CP0_VPEControl &= ~(0x7 << CP0VPECo_EXCPT);
target-mips/op_helper.c:                env->CP0_VPEControl |= 4 << CP0VPECo_EXCPT;
target-mips/op_helper.c:            env->CP0_VPEControl &= ~(0x7 << CP0VPECo_EXCPT);
target-mips/op_helper.c:        env->CP0_VPEControl &= ~(0x7 << CP0VPECo_EXCPT);
target-mips/op_helper.c:        env->CP0_VPEControl |= 2 << CP0VPECo_EXCPT;
target-mips/op_helper.c:    return env->CP0_YQMask;
target-mips/op_helper.c:    env->tlb->tlb_in_use = env->tlb->nb_tlb;
target-mips/op_helper.c:    /* Discard entries from env->tlb[first] onwards.  */
target-mips/op_helper.c:    while (env->tlb->tlb_in_use > first) {
target-mips/op_helper.c:        r4k_invalidate_tlb(env, --env->tlb->tlb_in_use, 0);
target-mips/op_helper.c:    tlb = &env->tlb->mmu.r4k.tlb[idx];
target-mips/op_helper.c:    tlb->VPN = env->CP0_EntryHi & (TARGET_PAGE_MASK << 1);
target-mips/op_helper.c:    tlb->VPN &= env->SEGMask;
target-mips/op_helper.c:    tlb->ASID = env->CP0_EntryHi & 0xFF;
target-mips/op_helper.c:    tlb->PageMask = env->CP0_PageMask;
target-mips/op_helper.c:    tlb->G = env->CP0_EntryLo0 & env->CP0_EntryLo1 & 1;
target-mips/op_helper.c:    tlb->V0 = (env->CP0_EntryLo0 & 2) != 0;
target-mips/op_helper.c:    tlb->D0 = (env->CP0_EntryLo0 & 4) != 0;
target-mips/op_helper.c:    tlb->C0 = (env->CP0_EntryLo0 >> 3) & 0x7;
target-mips/op_helper.c:    tlb->PFN[0] = (env->CP0_EntryLo0 >> 6) << 12;
target-mips/op_helper.c:    tlb->V1 = (env->CP0_EntryLo1 & 2) != 0;
target-mips/op_helper.c:    tlb->D1 = (env->CP0_EntryLo1 & 4) != 0;
target-mips/op_helper.c:    tlb->C1 = (env->CP0_EntryLo1 >> 3) & 0x7;
target-mips/op_helper.c:    tlb->PFN[1] = (env->CP0_EntryLo1 >> 6) << 12;
target-mips/op_helper.c:    idx = (env->CP0_Index & ~0x80000000) % env->tlb->nb_tlb;
target-mips/op_helper.c:    tlb = &env->tlb->mmu.r4k.tlb[idx];
target-mips/op_helper.c:    VPN = env->CP0_EntryHi & (TARGET_PAGE_MASK << 1);
target-mips/op_helper.c:    VPN &= env->SEGMask;
target-mips/op_helper.c:    ASID = env->CP0_EntryHi & 0xff;
target-mips/op_helper.c:    G = env->CP0_EntryLo0 & env->CP0_EntryLo1 & 1;
target-mips/op_helper.c:    V0 = (env->CP0_EntryLo0 & 2) != 0;
target-mips/op_helper.c:    D0 = (env->CP0_EntryLo0 & 4) != 0;
target-mips/op_helper.c:    V1 = (env->CP0_EntryLo1 & 2) != 0;
target-mips/op_helper.c:    D1 = (env->CP0_EntryLo1 & 4) != 0;
target-mips/op_helper.c:        r4k_mips_tlb_flush_extra(env, env->tlb->nb_tlb);
target-mips/op_helper.c:    ASID = env->CP0_EntryHi & 0xFF;
target-mips/op_helper.c:    for (i = 0; i < env->tlb->nb_tlb; i++) {
target-mips/op_helper.c:        tlb = &env->tlb->mmu.r4k.tlb[i];
target-mips/op_helper.c:        tag = env->CP0_EntryHi & ~mask;
target-mips/op_helper.c:        tag &= env->SEGMask;
target-mips/op_helper.c:            env->CP0_Index = i;
target-mips/op_helper.c:    if (i == env->tlb->nb_tlb) {
target-mips/op_helper.c:        for (i = env->tlb->nb_tlb; i < env->tlb->tlb_in_use; i++) {
target-mips/op_helper.c:            tlb = &env->tlb->mmu.r4k.tlb[i];
target-mips/op_helper.c:            tag = env->CP0_EntryHi & ~mask;
target-mips/op_helper.c:            tag &= env->SEGMask;
target-mips/op_helper.c:        env->CP0_Index |= 0x80000000;
target-mips/op_helper.c:    ASID = env->CP0_EntryHi & 0xFF;
target-mips/op_helper.c:    idx = (env->CP0_Index & ~0x80000000) % env->tlb->nb_tlb;
target-mips/op_helper.c:    tlb = &env->tlb->mmu.r4k.tlb[idx];
target-mips/op_helper.c:    r4k_mips_tlb_flush_extra(env, env->tlb->nb_tlb);
target-mips/op_helper.c:    env->CP0_EntryHi = tlb->VPN | tlb->ASID;
target-mips/op_helper.c:    env->CP0_PageMask = tlb->PageMask;
target-mips/op_helper.c:    env->CP0_EntryLo0 = tlb->G | (tlb->V0 << 1) | (tlb->D0 << 2) |
target-mips/op_helper.c:    env->CP0_EntryLo1 = tlb->G | (tlb->V1 << 1) | (tlb->D1 << 2) |
target-mips/op_helper.c:    env->tlb->helper_tlbwi(env);
target-mips/op_helper.c:    env->tlb->helper_tlbwr(env);
target-mips/op_helper.c:    env->tlb->helper_tlbp(env);
target-mips/op_helper.c:    env->tlb->helper_tlbr(env);
target-mips/op_helper.c:    target_ulong t0 = env->CP0_Status;
target-mips/op_helper.c:    env->CP0_Status = t0 & ~(1 << CP0St_IE);
target-mips/op_helper.c:    target_ulong t0 = env->CP0_Status;
target-mips/op_helper.c:    env->CP0_Status = t0 | (1 << CP0St_IE);
target-mips/op_helper.c:                env->active_tc.PC, env->CP0_EPC);
target-mips/op_helper.c:        if (env->CP0_Status & (1 << CP0St_ERL))
target-mips/op_helper.c:            qemu_log(" ErrorEPC " TARGET_FMT_lx, env->CP0_ErrorEPC);
target-mips/op_helper.c:        if (env->hflags & MIPS_HFLAG_DM)
target-mips/op_helper.c:            qemu_log(" DEPC " TARGET_FMT_lx, env->CP0_DEPC);
target-mips/op_helper.c:                env->active_tc.PC, env->CP0_EPC);
target-mips/op_helper.c:        if (env->CP0_Status & (1 << CP0St_ERL))
target-mips/op_helper.c:            qemu_log(" ErrorEPC " TARGET_FMT_lx, env->CP0_ErrorEPC);
target-mips/op_helper.c:        if (env->hflags & MIPS_HFLAG_DM)
target-mips/op_helper.c:            qemu_log(" DEPC " TARGET_FMT_lx, env->CP0_DEPC);
target-mips/op_helper.c:        switch (env->hflags & MIPS_HFLAG_KSU) {
target-mips/op_helper.c:    env->active_tc.PC = error_pc & ~(target_ulong)1;
target-mips/op_helper.c:        env->hflags |= MIPS_HFLAG_M16;
target-mips/op_helper.c:        env->hflags &= ~(MIPS_HFLAG_M16);
target-mips/op_helper.c:    if (env->CP0_Status & (1 << CP0St_ERL)) {
target-mips/op_helper.c:        set_pc(env, env->CP0_ErrorEPC);
target-mips/op_helper.c:        env->CP0_Status &= ~(1 << CP0St_ERL);
target-mips/op_helper.c:        set_pc(env, env->CP0_EPC);
target-mips/op_helper.c:        env->CP0_Status &= ~(1 << CP0St_EXL);
target-mips/op_helper.c:    env->lladdr = 1;
target-mips/op_helper.c:    set_pc(env, env->CP0_DEPC);
target-mips/op_helper.c:    env->hflags &= MIPS_HFLAG_DM;
target-mips/op_helper.c:    env->lladdr = 1;
target-mips/op_helper.c:    if ((env->hflags & MIPS_HFLAG_CP0) ||
target-mips/op_helper.c:        (env->CP0_HWREna & (1 << 0)))
target-mips/op_helper.c:        return env->CP0_EBase & 0x3ff;
target-mips/op_helper.c:    if ((env->hflags & MIPS_HFLAG_CP0) ||
target-mips/op_helper.c:        (env->CP0_HWREna & (1 << 1)))
target-mips/op_helper.c:        return env->SYNCI_Step;
target-mips/op_helper.c:    if ((env->hflags & MIPS_HFLAG_CP0) ||
target-mips/op_helper.c:        (env->CP0_HWREna & (1 << 2)))
target-mips/op_helper.c:        return env->CP0_Count;
target-mips/op_helper.c:    if ((env->hflags & MIPS_HFLAG_CP0) ||
target-mips/op_helper.c:        (env->CP0_HWREna & (1 << 3)))
target-mips/op_helper.c:        return env->CCRes;
target-mips/op_helper.c:        if (env->active_tc.gpr[4] == 0)
target-mips/op_helper.c:            env->active_tc.gpr[2] = -1;
target-mips/op_helper.c:        env->active_tc.gpr[2] = -1;
target-mips/op_helper.c:        printf("%c", (char)(env->active_tc.gpr[4] & 0xFF));
target-mips/op_helper.c:            unsigned char *fmt = (void *)(uintptr_t)env->active_tc.gpr[4];
target-mips/op_helper.c:    env->CP0_BadVAddr = addr;
target-mips/op_helper.c:                               env->error_code, retaddr);
target-mips/op_helper.c:    set_float_rounding_mode(ieee_rm[env->active_fpu.fcr31 & 3],
target-mips/op_helper.c:                            &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_flush_to_zero((env->active_fpu.fcr31 & (1 << 24)) != 0,
target-mips/op_helper.c:                      &env->active_fpu.fp_status);
target-mips/op_helper.c:        arg1 = (int32_t)env->active_fpu.fcr0;
target-mips/op_helper.c:        if (env->active_fpu.fcr0 & (1 << FCR0_UFRP)) {
target-mips/op_helper.c:            if (env->CP0_Config5 & (1 << CP0C5_UFR)) {
target-mips/op_helper.c:                       ((env->CP0_Status & (1  << CP0St_FR)) >> CP0St_FR);
target-mips/op_helper.c:        arg1 = ((env->active_fpu.fcr31 >> 24) & 0xfe) | ((env->active_fpu.fcr31 >> 23) & 0x1);
target-mips/op_helper.c:        arg1 = env->active_fpu.fcr31 & 0x0003f07c;
target-mips/op_helper.c:        arg1 = (env->active_fpu.fcr31 & 0x00000f83) | ((env->active_fpu.fcr31 >> 22) & 0x4);
target-mips/op_helper.c:        arg1 = (int32_t)env->active_fpu.fcr31;
target-mips/op_helper.c:        if (!((env->active_fpu.fcr0 & (1 << FCR0_UFRP)) && (rt == 0))) {
target-mips/op_helper.c:        if (env->CP0_Config5 & (1 << CP0C5_UFR)) {
target-mips/op_helper.c:            env->CP0_Status &= ~(1 << CP0St_FR);
target-mips/op_helper.c:        if (!((env->active_fpu.fcr0 & (1 << FCR0_UFRP)) && (rt == 0))) {
target-mips/op_helper.c:        if (env->CP0_Config5 & (1 << CP0C5_UFR)) {
target-mips/op_helper.c:            env->CP0_Status |= (1 << CP0St_FR);
target-mips/op_helper.c:        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0x017fffff) | ((arg1 & 0xfe) << 24) |
target-mips/op_helper.c:        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfffc0f83) | (arg1 & 0x0003f07c);
target-mips/op_helper.c:        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfefff07c) | (arg1 & 0x00000f83) |
target-mips/op_helper.c:        env->active_fpu.fcr31 = arg1;
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if ((GET_FP_ENABLE(env->active_fpu.fcr31) | 0x20) & GET_FP_CAUSE(env->active_fpu.fcr31))
target-mips/op_helper.c:    int tmp = ieee_ex_to_mips(get_float_exception_flags(&env->active_fpu.fp_status));
target-mips/op_helper.c:    SET_FP_CAUSE(env->active_fpu.fcr31, tmp);
target-mips/op_helper.c:        set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:        if (GET_FP_ENABLE(env->active_fpu.fcr31) & tmp) {
target-mips/op_helper.c:            UPDATE_FP_FLAGS(env->active_fpu.fcr31, tmp);
target-mips/op_helper.c:    fdt0 = float64_sqrt(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst0 = float32_sqrt(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float32_to_float64(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = int32_to_float64(wt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = int64_to_float64(dt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    dt2 = float64_to_int64(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (get_float_exception_flags(&env->active_fpu.fp_status)
target-mips/op_helper.c:    dt2 = float32_to_int64(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (get_float_exception_flags(&env->active_fpu.fp_status)
target-mips/op_helper.c:    fst2 = int32_to_float32(dt0 & 0XFFFFFFFF, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fsth2 = int32_to_float32(dt0 >> 32, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wt2 = float32_to_int32(fdt0 & 0XFFFFFFFF, &env->active_fpu.fp_status);
target-mips/op_helper.c:    excp = get_float_exception_flags(&env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wth2 = float32_to_int32(fdt0 >> 32, &env->active_fpu.fp_status);
target-mips/op_helper.c:    excph = get_float_exception_flags(&env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(excp | excph, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float64_to_float32(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = int32_to_float32(wt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = int64_to_float32(dt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wt2 = float32_to_int32(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (get_float_exception_flags(&env->active_fpu.fp_status)
target-mips/op_helper.c:    wt2 = float64_to_int32(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (get_float_exception_flags(&env->active_fpu.fp_status)
target-mips/op_helper.c:    set_float_rounding_mode(float_round_nearest_even, &env->active_fpu.fp_status);
target-mips/op_helper.c:    dt2 = float64_to_int64(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (get_float_exception_flags(&env->active_fpu.fp_status)
target-mips/op_helper.c:    set_float_rounding_mode(float_round_nearest_even, &env->active_fpu.fp_status);
target-mips/op_helper.c:    dt2 = float32_to_int64(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (get_float_exception_flags(&env->active_fpu.fp_status)
target-mips/op_helper.c:    set_float_rounding_mode(float_round_nearest_even, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wt2 = float64_to_int32(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (get_float_exception_flags(&env->active_fpu.fp_status)
target-mips/op_helper.c:    set_float_rounding_mode(float_round_nearest_even, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wt2 = float32_to_int32(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (get_float_exception_flags(&env->active_fpu.fp_status)
target-mips/op_helper.c:    dt2 = float64_to_int64_round_to_zero(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (get_float_exception_flags(&env->active_fpu.fp_status)
target-mips/op_helper.c:    dt2 = float32_to_int64_round_to_zero(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (get_float_exception_flags(&env->active_fpu.fp_status)
target-mips/op_helper.c:    wt2 = float64_to_int32_round_to_zero(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (get_float_exception_flags(&env->active_fpu.fp_status)
target-mips/op_helper.c:    wt2 = float32_to_int32_round_to_zero(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (get_float_exception_flags(&env->active_fpu.fp_status)
target-mips/op_helper.c:    set_float_rounding_mode(float_round_up, &env->active_fpu.fp_status);
target-mips/op_helper.c:    dt2 = float64_to_int64(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (get_float_exception_flags(&env->active_fpu.fp_status)
target-mips/op_helper.c:    set_float_rounding_mode(float_round_up, &env->active_fpu.fp_status);
target-mips/op_helper.c:    dt2 = float32_to_int64(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (get_float_exception_flags(&env->active_fpu.fp_status)
target-mips/op_helper.c:    set_float_rounding_mode(float_round_up, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wt2 = float64_to_int32(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (get_float_exception_flags(&env->active_fpu.fp_status)
target-mips/op_helper.c:    set_float_rounding_mode(float_round_up, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wt2 = float32_to_int32(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (get_float_exception_flags(&env->active_fpu.fp_status)
target-mips/op_helper.c:    set_float_rounding_mode(float_round_down, &env->active_fpu.fp_status);
target-mips/op_helper.c:    dt2 = float64_to_int64(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (get_float_exception_flags(&env->active_fpu.fp_status)
target-mips/op_helper.c:    set_float_rounding_mode(float_round_down, &env->active_fpu.fp_status);
target-mips/op_helper.c:    dt2 = float32_to_int64(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (get_float_exception_flags(&env->active_fpu.fp_status)
target-mips/op_helper.c:    set_float_rounding_mode(float_round_down, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wt2 = float64_to_int32(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (get_float_exception_flags(&env->active_fpu.fp_status)
target-mips/op_helper.c:    set_float_rounding_mode(float_round_down, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wt2 = float32_to_int32(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (get_float_exception_flags(&env->active_fpu.fp_status)
target-mips/op_helper.c:    fdt2 = float64_div(float64_one, fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_div(float32_one, fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float64_sqrt(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float64_div(float64_one, fdt2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_sqrt(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_div(float32_one, fst2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float64_div(float64_one, fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_div(float32_one, fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_div(float32_one, fdt0 & 0XFFFFFFFF, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fsth2 = float32_div(float32_one, fdt0 >> 32, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float64_sqrt(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float64_div(float64_one, fdt2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_sqrt(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_div(float32_one, fst2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_sqrt(fdt0 & 0XFFFFFFFF, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fsth2 = float32_sqrt(fdt0 >> 32, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_div(float32_one, fst2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fsth2 = float32_div(float32_one, fsth2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    dt2 = float64_ ## name (fdt0, fdt1, &env->active_fpu.fp_status);     \
target-mips/op_helper.c:    wt2 = float32_ ## name (fst0, fst1, &env->active_fpu.fp_status);     \
target-mips/op_helper.c:    wt2 = float32_ ## name (fst0, fst1, &env->active_fpu.fp_status);     \
target-mips/op_helper.c:    wth2 = float32_ ## name (fsth0, fsth1, &env->active_fpu.fp_status);  \
target-mips/op_helper.c:    a = prefix##_mul(a, b, &env->active_fpu.fp_status);              \
target-mips/op_helper.c:        a = prefix##_sub(a, c, &env->active_fpu.fp_status);          \
target-mips/op_helper.c:        a = prefix##_add(a, c, &env->active_fpu.fp_status);          \
target-mips/op_helper.c:    fdt2 = float64_mul(fdt0, fdt2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float64_chs(float64_sub(fdt2, float64_one, &env->active_fpu.fp_status));
target-mips/op_helper.c:    fst2 = float32_mul(fst0, fst2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_chs(float32_sub(fst2, float32_one, &env->active_fpu.fp_status));
target-mips/op_helper.c:    fst2 = float32_mul(fst0, fst2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fsth2 = float32_mul(fsth0, fsth2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_chs(float32_sub(fst2, float32_one, &env->active_fpu.fp_status));
target-mips/op_helper.c:    fsth2 = float32_chs(float32_sub(fsth2, float32_one, &env->active_fpu.fp_status));
target-mips/op_helper.c:    fdt2 = float64_mul(fdt0, fdt2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float64_sub(fdt2, float64_one, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float64_chs(float64_div(fdt2, FLOAT_TWO64, &env->active_fpu.fp_status));
target-mips/op_helper.c:    fst2 = float32_mul(fst0, fst2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_sub(fst2, float32_one, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_chs(float32_div(fst2, FLOAT_TWO32, &env->active_fpu.fp_status));
target-mips/op_helper.c:    fst2 = float32_mul(fst0, fst2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fsth2 = float32_mul(fsth0, fsth2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_sub(fst2, float32_one, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fsth2 = float32_sub(fsth2, float32_one, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_chs(float32_div(fst2, FLOAT_TWO32, &env->active_fpu.fp_status));
target-mips/op_helper.c:    fsth2 = float32_chs(float32_div(fsth2, FLOAT_TWO32, &env->active_fpu.fp_status));
target-mips/op_helper.c:    fst2 = float32_add (fst0, fsth0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fsth2 = float32_add (fst1, fsth1, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_mul (fst0, fsth0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fsth2 = float32_mul (fst1, fsth1, &env->active_fpu.fp_status);
target-mips/op_helper.c:        SET_FP_COND(cc, env->active_fpu);                      \
target-mips/op_helper.c:        CLEAR_FP_COND(cc, env->active_fpu);                    \
target-mips/op_helper.c:        SET_FP_COND(cc, env->active_fpu);                      \
target-mips/op_helper.c:        CLEAR_FP_COND(cc, env->active_fpu);                    \
target-mips/op_helper.c:FOP_COND_D(f,   (float64_unordered_quiet(fdt1, fdt0, &env->active_fpu.fp_status), 0))
target-mips/op_helper.c:FOP_COND_D(un,  float64_unordered_quiet(fdt1, fdt0, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(eq,  float64_eq_quiet(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(ueq, float64_unordered_quiet(fdt1, fdt0, &env->active_fpu.fp_status)  || float64_eq_quiet(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(olt, float64_lt_quiet(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(ult, float64_unordered_quiet(fdt1, fdt0, &env->active_fpu.fp_status)  || float64_lt_quiet(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(ole, float64_le_quiet(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(ule, float64_unordered_quiet(fdt1, fdt0, &env->active_fpu.fp_status)  || float64_le_quiet(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(sf,  (float64_unordered(fdt1, fdt0, &env->active_fpu.fp_status), 0))
target-mips/op_helper.c:FOP_COND_D(ngle,float64_unordered(fdt1, fdt0, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(seq, float64_eq(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(ngl, float64_unordered(fdt1, fdt0, &env->active_fpu.fp_status)  || float64_eq(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(lt,  float64_lt(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(nge, float64_unordered(fdt1, fdt0, &env->active_fpu.fp_status)  || float64_lt(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(le,  float64_le(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(ngt, float64_unordered(fdt1, fdt0, &env->active_fpu.fp_status)  || float64_le(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:        SET_FP_COND(cc, env->active_fpu);                      \
target-mips/op_helper.c:        CLEAR_FP_COND(cc, env->active_fpu);                    \
target-mips/op_helper.c:        SET_FP_COND(cc, env->active_fpu);                      \
target-mips/op_helper.c:        CLEAR_FP_COND(cc, env->active_fpu);                    \
target-mips/op_helper.c:FOP_COND_S(f,   (float32_unordered_quiet(fst1, fst0, &env->active_fpu.fp_status), 0))
target-mips/op_helper.c:FOP_COND_S(un,  float32_unordered_quiet(fst1, fst0, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(eq,  float32_eq_quiet(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(ueq, float32_unordered_quiet(fst1, fst0, &env->active_fpu.fp_status)  || float32_eq_quiet(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(olt, float32_lt_quiet(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(ult, float32_unordered_quiet(fst1, fst0, &env->active_fpu.fp_status)  || float32_lt_quiet(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(ole, float32_le_quiet(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(ule, float32_unordered_quiet(fst1, fst0, &env->active_fpu.fp_status)  || float32_le_quiet(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(sf,  (float32_unordered(fst1, fst0, &env->active_fpu.fp_status), 0))
target-mips/op_helper.c:FOP_COND_S(ngle,float32_unordered(fst1, fst0, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(seq, float32_eq(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(ngl, float32_unordered(fst1, fst0, &env->active_fpu.fp_status)  || float32_eq(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(lt,  float32_lt(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(nge, float32_unordered(fst1, fst0, &env->active_fpu.fp_status)  || float32_lt(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(le,  float32_le(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(ngt, float32_unordered(fst1, fst0, &env->active_fpu.fp_status)  || float32_le(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:        SET_FP_COND(cc, env->active_fpu);                       \
target-mips/op_helper.c:        CLEAR_FP_COND(cc, env->active_fpu);                     \
target-mips/op_helper.c:        SET_FP_COND(cc + 1, env->active_fpu);                   \
target-mips/op_helper.c:        CLEAR_FP_COND(cc + 1, env->active_fpu);                 \
target-mips/op_helper.c:        SET_FP_COND(cc, env->active_fpu);                       \
target-mips/op_helper.c:        CLEAR_FP_COND(cc, env->active_fpu);                     \
target-mips/op_helper.c:        SET_FP_COND(cc + 1, env->active_fpu);                   \
target-mips/op_helper.c:        CLEAR_FP_COND(cc + 1, env->active_fpu);                 \
target-mips/op_helper.c:FOP_COND_PS(f,   (float32_unordered_quiet(fst1, fst0, &env->active_fpu.fp_status), 0),
target-mips/op_helper.c:                 (float32_unordered_quiet(fsth1, fsth0, &env->active_fpu.fp_status), 0))
target-mips/op_helper.c:FOP_COND_PS(un,  float32_unordered_quiet(fst1, fst0, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_unordered_quiet(fsth1, fsth0, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(eq,  float32_eq_quiet(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_eq_quiet(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(ueq, float32_unordered_quiet(fst1, fst0, &env->active_fpu.fp_status)    || float32_eq_quiet(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_unordered_quiet(fsth1, fsth0, &env->active_fpu.fp_status)  || float32_eq_quiet(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(olt, float32_lt_quiet(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_lt_quiet(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(ult, float32_unordered_quiet(fst1, fst0, &env->active_fpu.fp_status)    || float32_lt_quiet(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_unordered_quiet(fsth1, fsth0, &env->active_fpu.fp_status)  || float32_lt_quiet(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(ole, float32_le_quiet(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_le_quiet(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(ule, float32_unordered_quiet(fst1, fst0, &env->active_fpu.fp_status)    || float32_le_quiet(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_unordered_quiet(fsth1, fsth0, &env->active_fpu.fp_status)  || float32_le_quiet(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(sf,  (float32_unordered(fst1, fst0, &env->active_fpu.fp_status), 0),
target-mips/op_helper.c:                 (float32_unordered(fsth1, fsth0, &env->active_fpu.fp_status), 0))
target-mips/op_helper.c:FOP_COND_PS(ngle,float32_unordered(fst1, fst0, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_unordered(fsth1, fsth0, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(seq, float32_eq(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_eq(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(ngl, float32_unordered(fst1, fst0, &env->active_fpu.fp_status)    || float32_eq(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_unordered(fsth1, fsth0, &env->active_fpu.fp_status)  || float32_eq(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(lt,  float32_lt(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_lt(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(nge, float32_unordered(fst1, fst0, &env->active_fpu.fp_status)    || float32_lt(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_unordered(fsth1, fsth0, &env->active_fpu.fp_status)  || float32_lt(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(le,  float32_le(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_le(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(ngt, float32_unordered(fst1, fst0, &env->active_fpu.fp_status)    || float32_le(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_unordered(fsth1, fsth0, &env->active_fpu.fp_status)  || float32_le(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/translate_init.c:    env->tlb->nb_tlb = 1;
target-mips/translate_init.c:    env->tlb->map_address = &no_mmu_map_address;
target-mips/translate_init.c:    env->tlb->nb_tlb = 1;
target-mips/translate_init.c:    env->tlb->map_address = &fixed_mmu_map_address;
target-mips/translate_init.c:    env->tlb->nb_tlb = 1 + ((def->CP0_Config1 >> CP0C1_MMU) & 63);
target-mips/translate_init.c:    env->tlb->map_address = &r4k_map_address;
target-mips/translate_init.c:    env->tlb->helper_tlbwi = r4k_helper_tlbwi;
target-mips/translate_init.c:    env->tlb->helper_tlbwr = r4k_helper_tlbwr;
target-mips/translate_init.c:    env->tlb->helper_tlbp = r4k_helper_tlbp;
target-mips/translate_init.c:    env->tlb->helper_tlbr = r4k_helper_tlbr;
target-mips/translate_init.c:    env->tlb = g_malloc0(sizeof(CPUMIPSTLBContext));
target-mips/translate_init.c:        env->fpus[i].fcr0 = def->CP1_fcr0;
target-mips/translate_init.c:    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));
target-mips/translate_init.c:    env->mvp = g_malloc0(sizeof(CPUMIPSMVPContext));
target-mips/translate_init.c:    env->mvp->CP0_MVPConf0 = (1U << CP0MVPC0_M) | (1 << CP0MVPC0_TLBS) |
target-mips/translate_init.c:    env->mvp->CP0_MVPConf0 |= (env->tlb->nb_tlb << CP0MVPC0_PTLBE);
target-mips/translate_init.c:    env->mvp->CP0_MVPConf1 = (1U << CP0MVPC1_CIM) | (1 << CP0MVPC1_CIF) |
monitor.c:                if ((env->efer & MSR_EFER_LMA) &&
monitor.c:                    (env->segs[R_CS].flags & DESC_L_MASK))
monitor.c:                if (!(env->segs[R_CS].flags & DESC_B_MASK))
monitor.c:        flags |= env->bfd_mach;
monitor.c:    pgd = env->cr[3] & ~0xfff;
monitor.c:            if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {
monitor.c:    pdp_addr = env->cr[3] & ~0x1f;
monitor.c:    pml4_addr = env->cr[3] & 0x3fffffffff000ULL;
monitor.c:    if (!(env->cr[0] & CR0_PG_MASK)) {
monitor.c:    if (env->cr[4] & CR4_PAE_MASK) {
monitor.c:        if (env->hflags & HF_LMA_MASK) {
monitor.c:    pgd = env->cr[3] & ~0xfff;
monitor.c:            if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {
monitor.c:    pdp_addr = env->cr[3] & ~0x1f;
monitor.c:    pml4_addr = env->cr[3] & 0x3fffffffff000ULL;
monitor.c:    if (!(env->cr[0] & CR0_PG_MASK)) {
monitor.c:    if (env->cr[4] & CR4_PAE_MASK) {
monitor.c:        if (env->hflags & HF_LMA_MASK) {
monitor.c:        print_tlb (mon, i, &env->itlb[i]);
monitor.c:        print_tlb (mon, i, &env->utlb[i]);
monitor.c:    return env->eip + env->segs[R_CS].base;
monitor.c:        u |= env->crf[i] << (32 - (4 * i));
monitor.c:    return env->msr;
monitor.c:    return env->xer;
monitor.c:    return env->regwptr[val];
target-openrisc/gdbstub.c:        return gdb_get_reg32(mem_buf, env->gpr[n]);
target-openrisc/gdbstub.c:            return gdb_get_reg32(mem_buf, env->ppc);
target-openrisc/gdbstub.c:            return gdb_get_reg32(mem_buf, env->npc);
target-openrisc/gdbstub.c:            return gdb_get_reg32(mem_buf, env->sr);
target-openrisc/gdbstub.c:        env->gpr[n] = tmp;
target-openrisc/gdbstub.c:            env->ppc = tmp;
target-openrisc/gdbstub.c:            env->npc = tmp;
target-openrisc/gdbstub.c:            env->sr = tmp;
target-openrisc/interrupt.c:    env->epcr = env->pc;
target-openrisc/interrupt.c:    if (env->flags & D_FLAG) {
target-openrisc/interrupt.c:        env->flags &= ~D_FLAG;
target-openrisc/interrupt.c:        env->sr |= SR_DSX;
target-openrisc/interrupt.c:        env->epcr -= 4;
target-openrisc/interrupt.c:        env->epcr += 4;
target-openrisc/interrupt.c:    env->esr = env->sr;
target-openrisc/interrupt.c:    env->sr &= ~SR_DME;
target-openrisc/interrupt.c:    env->sr &= ~SR_IME;
target-openrisc/interrupt.c:    env->sr |= SR_SM;
target-openrisc/interrupt.c:    env->sr &= ~SR_IEE;
target-openrisc/interrupt.c:    env->sr &= ~SR_TEE;
target-openrisc/interrupt.c:    env->tlb->cpu_openrisc_map_address_data = &cpu_openrisc_get_phys_nommu;
target-openrisc/interrupt.c:    env->tlb->cpu_openrisc_map_address_code = &cpu_openrisc_get_phys_nommu;
target-openrisc/interrupt.c:        env->pc = (cs->exception_index << 8);
target-openrisc/translate.c:    cpu_fprintf(f, "PC=%08x\n", env->pc);
target-openrisc/translate.c:        cpu_fprintf(f, "R%02d=%08x%c", i, env->gpr[i],
target-openrisc/translate.c:    env->pc = tcg_ctx.gen_opc_pc[pc_pos];
target-openrisc/sys_helper.c:        env->vr = rb;
target-openrisc/sys_helper.c:        env->npc = rb;
target-openrisc/sys_helper.c:        if ((env->sr & (SR_IME | SR_DME | SR_SM)) ^
target-openrisc/sys_helper.c:        env->sr = rb;
target-openrisc/sys_helper.c:        env->sr |= SR_FO;      /* FO is const equal to 1 */
target-openrisc/sys_helper.c:        if (env->sr & SR_DME) {
target-openrisc/sys_helper.c:            env->tlb->cpu_openrisc_map_address_data =
target-openrisc/sys_helper.c:            env->tlb->cpu_openrisc_map_address_data =
target-openrisc/sys_helper.c:        if (env->sr & SR_IME) {
target-openrisc/sys_helper.c:            env->tlb->cpu_openrisc_map_address_code =
target-openrisc/sys_helper.c:            env->tlb->cpu_openrisc_map_address_code =
target-openrisc/sys_helper.c:        env->ppc = rb;
target-openrisc/sys_helper.c:        env->epcr = rb;
target-openrisc/sys_helper.c:        env->eear = rb;
target-openrisc/sys_helper.c:        env->esr = rb;
target-openrisc/sys_helper.c:            tlb_flush_page(cs, env->tlb->dtlb[0][idx].mr & TARGET_PAGE_MASK);
target-openrisc/sys_helper.c:        env->tlb->dtlb[0][idx].mr = rb;
target-openrisc/sys_helper.c:        env->tlb->dtlb[0][idx].tr = rb;
target-openrisc/sys_helper.c:            tlb_flush_page(cs, env->tlb->itlb[0][idx].mr & TARGET_PAGE_MASK);
target-openrisc/sys_helper.c:        env->tlb->itlb[0][idx].mr = rb;
target-openrisc/sys_helper.c:        env->tlb->itlb[0][idx].tr = rb;
target-openrisc/sys_helper.c:        env->picmr |= rb;
target-openrisc/sys_helper.c:        env->picsr &= ~rb;
target-openrisc/sys_helper.c:            if ((env->ttmr & TTMR_M) ^ (rb & TTMR_M)) {
target-openrisc/sys_helper.c:            int ip = env->ttmr & TTMR_IP;
target-openrisc/sys_helper.c:                env->ttmr = (rb & ~TTMR_IP) | ip;
target-openrisc/sys_helper.c:                env->ttmr = rb & ~TTMR_IP;
target-openrisc/sys_helper.c:        env->ttcr = rb;
target-openrisc/sys_helper.c:        if (env->ttmr & TIMER_NONE) {
target-openrisc/sys_helper.c:        return env->vr & SPR_VR;
target-openrisc/sys_helper.c:        return env->upr;    /* TT, DM, IM, UP present */
target-openrisc/sys_helper.c:        return env->cpucfgr;
target-openrisc/sys_helper.c:        return env->dmmucfgr;    /* 1Way, 64 entries */
target-openrisc/sys_helper.c:        return env->immucfgr;
target-openrisc/sys_helper.c:        return env->npc;
target-openrisc/sys_helper.c:        return env->sr;
target-openrisc/sys_helper.c:        return env->ppc;
target-openrisc/sys_helper.c:        return env->epcr;
target-openrisc/sys_helper.c:        return env->eear;
target-openrisc/sys_helper.c:        return env->esr;
target-openrisc/sys_helper.c:        return env->tlb->dtlb[0][idx].mr;
target-openrisc/sys_helper.c:        return env->tlb->dtlb[0][idx].tr;
target-openrisc/sys_helper.c:        return env->tlb->itlb[0][idx].mr;
target-openrisc/sys_helper.c:        return env->tlb->itlb[0][idx].tr;
target-openrisc/sys_helper.c:        return env->picmr;
target-openrisc/sys_helper.c:        return env->picsr;
target-openrisc/sys_helper.c:        return env->ttmr;
target-openrisc/sys_helper.c:        return env->ttcr;
target-openrisc/cpu.h:    *pc = env->pc;
target-openrisc/cpu.h:    *flags = (env->flags & D_FLAG);
target-openrisc/cpu.h:    if (!(env->sr & SR_IME)) {
target-openrisc/cpu.h:    return (env->sr & SR_SM) == 0 ? MMU_USER_IDX : MMU_SUPERVISOR_IDX;
target-openrisc/cpu.h:    return env->pc;
target-openrisc/fpu_helper.c:    hi = env->fpmaddhi;                                                   \
target-openrisc/fpu_helper.c:    lo = env->fpmaddlo;                                                   \
hw/s390x/s390-virtio-hcall.c:    if (env->regs[1] < MAX_DIAG_SUBCODES) {
hw/s390x/s390-virtio-hcall.c:        fn = s390_diag500_table[env->regs[1]];
hw/s390x/s390-virtio-hcall.c:            env->regs[2] = fn(&env->regs[2]);
hw/s390x/ipl.c:    env->psw.addr = ipl->start_addr;
hw/s390x/ipl.c:    env->psw.mask = IPL_PSW_MASK;
hw/s390x/ipl.c:        env->regs[7] = -1;
hw/s390x/ipl.c:                env->regs[7] = ccw_dev->sch->cssid << 24 |
hw/s390x/sclp.c:    if (env->psw.mask & PSW_MASK_PSTATE) {
hw/s390x/sclp.c:    if ((sccb & ~0x1fffUL) == 0 || (sccb & ~0x1fffUL) == env->psa
hw/microblaze/boot.c:    env->regs[5] = boot_info.cmdline;
hw/microblaze/boot.c:    env->regs[6] = boot_info.initrd_start;
hw/microblaze/boot.c:    env->regs[7] = boot_info.fdt;
hw/microblaze/boot.c:    env->sregs[SR_PC] = boot_info.bootstrap_pc;
hw/microblaze/petalogix_s3adsp1800_mmu.c:    env->pvr.regs[10] = 0x0c000000; /* spartan 3a dsp family.  */
hw/microblaze/petalogix_ml605_mmu.c:    env->pvr.regs[10] = 0x0e000000; /* virtex 6 */
hw/microblaze/petalogix_ml605_mmu.c:    env->pvr.regs[5] |= PVR5_DCACHE_WRITEBACK_MASK;
hw/microblaze/petalogix_ml605_mmu.c:    env->pvr.regs[0] |= PVR0_USE_FPU_MASK | PVR0_ENDI;
hw/microblaze/petalogix_ml605_mmu.c:    env->pvr.regs[0] = (env->pvr.regs[0] & ~PVR0_VERSION_MASK) | (0x14 << 8);
hw/microblaze/petalogix_ml605_mmu.c:    env->pvr.regs[2] ^= PVR2_USE_FPU2_MASK;
hw/microblaze/petalogix_ml605_mmu.c:    env->pvr.regs[4] = 0xc56b8000;
hw/microblaze/petalogix_ml605_mmu.c:    env->pvr.regs[5] = 0xc56be000;
hw/i386/kvmvapic.c:    if (cpu_memory_rw_debug(CPU(cpu), env->segs[R_FS].base,
hw/i386/kvmvapic.c:        kpcr.self != env->segs[R_FS].base) {
hw/i386/kvmvapic.c:            rom_paddr = (env->segs[R_CS].base + env->eip) & ROM_BLOCK_MASK;
hw/i386/kvmvapic.c:            patch_byte(cpu, env->eip - 2, 0x66);
hw/i386/kvmvapic.c:            patch_byte(cpu, env->eip - 1, 0x90);
hw/i386/kvmvapic.c:        if (update_rom_mapping(s, env, env->eip) < 0) {
hw/i386/pc.c:        smm_set(!!(env->hflags & HF_SMM_MASK), smm_arg);
hw/misc/vmport.c:    eax = env->regs[R_EAX];
hw/misc/vmport.c:    command = env->regs[R_ECX];
hw/misc/vmport.c:    data[0] = env->regs[R_EAX]; data[1] = env->regs[R_EBX];
hw/misc/vmport.c:    data[2] = env->regs[R_ECX]; data[3] = env->regs[R_EDX];
hw/misc/vmport.c:    data[4] = env->regs[R_ESI]; data[5] = env->regs[R_EDI];
hw/misc/vmport.c:    env->regs[R_EAX] = data[0]; env->regs[R_EBX] = data[1];
hw/misc/vmport.c:    env->regs[R_ECX] = data[2]; env->regs[R_EDX] = data[3];
hw/misc/vmport.c:    env->regs[R_ESI] = data[4]; env->regs[R_EDI] = data[5];
hw/xtensa/sim.c:        env->sregs[PRID] = n;
hw/xtensa/sim.c:            env->pc = elf_entry;
hw/xtensa/pic_cpu.c:    uint32_t old_ccount = env->sregs[CCOUNT];
hw/xtensa/pic_cpu.c:    env->sregs[CCOUNT] += d;
hw/xtensa/pic_cpu.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_TIMER_INTERRUPT)) {
hw/xtensa/pic_cpu.c:        for (i = 0; i < env->config->nccompare; ++i) {
hw/xtensa/pic_cpu.c:            if (env->sregs[CCOMPARE + i] - old_ccount <= d) {
hw/xtensa/pic_cpu.c:    uint32_t int_set_enabled = env->sregs[INTSET] & env->sregs[INTENABLE];
hw/xtensa/pic_cpu.c:                muldiv64(now - env->halt_clock,
hw/xtensa/pic_cpu.c:                    env->config->clock_freq_khz, 1000000));
hw/xtensa/pic_cpu.c:        env->halt_clock = now;
hw/xtensa/pic_cpu.c:    for (level = env->config->nlevel; level > minlevel; --level) {
hw/xtensa/pic_cpu.c:        if (env->config->level_mask[level] & int_set_enabled) {
hw/xtensa/pic_cpu.c:            env->pending_irq_level = level;
hw/xtensa/pic_cpu.c:                    env->pc, env->regs[0], env->sregs[PS],
hw/xtensa/pic_cpu.c:                    env->sregs[INTSET], env->sregs[INTENABLE],
hw/xtensa/pic_cpu.c:                    env->sregs[CCOUNT]);
hw/xtensa/pic_cpu.c:    env->pending_irq_level = 0;
hw/xtensa/pic_cpu.c:    if (irq >= env->config->ninterrupt) {
hw/xtensa/pic_cpu.c:            env->sregs[INTSET] |= irq_bit;
hw/xtensa/pic_cpu.c:        } else if (env->config->interrupt[irq].inttype == INTTYPE_LEVEL) {
hw/xtensa/pic_cpu.c:            env->sregs[INTSET] &= ~irq_bit;
hw/xtensa/pic_cpu.c:    qemu_set_irq(env->irq_inputs[env->config->timerint[id]], active);
hw/xtensa/pic_cpu.c:    uint32_t wake_ccount = env->sregs[CCOUNT] - 1;
hw/xtensa/pic_cpu.c:    for (i = 0; i < env->config->nccompare; ++i) {
hw/xtensa/pic_cpu.c:        if (env->sregs[CCOMPARE + i] - env->sregs[CCOUNT] <
hw/xtensa/pic_cpu.c:                wake_ccount - env->sregs[CCOUNT]) {
hw/xtensa/pic_cpu.c:            wake_ccount = env->sregs[CCOMPARE + i];
hw/xtensa/pic_cpu.c:    env->wake_ccount = wake_ccount;
hw/xtensa/pic_cpu.c:    timer_mod(env->ccompare_timer, env->halt_clock +
hw/xtensa/pic_cpu.c:            muldiv64(wake_ccount - env->sregs[CCOUNT],
hw/xtensa/pic_cpu.c:                1000000, env->config->clock_freq_khz));
hw/xtensa/pic_cpu.c:        env->halt_clock = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);
hw/xtensa/pic_cpu.c:        xtensa_advance_ccount(env, env->wake_ccount - env->sregs[CCOUNT]);
hw/xtensa/pic_cpu.c:            env->sregs[CCOUNT] = env->wake_ccount + 1;
hw/xtensa/pic_cpu.c:    env->irq_inputs = (void **)qemu_allocate_irqs(
hw/xtensa/pic_cpu.c:            xtensa_set_irq, env, env->config->ninterrupt);
hw/xtensa/pic_cpu.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_TIMER_INTERRUPT) &&
hw/xtensa/pic_cpu.c:            env->config->nccompare > 0) {
hw/xtensa/pic_cpu.c:        env->ccompare_timer =
hw/xtensa/pic_cpu.c:    if (extint < env->config->nextint) {
hw/xtensa/pic_cpu.c:        unsigned irq = env->config->extint[extint];
hw/xtensa/pic_cpu.c:        return env->irq_inputs[irq];
hw/xtensa/xtfpga.c:        env->sregs[PRID] = n;
hw/xtensa/xtfpga.c:        uint32_t entry_point = env->pc;
hw/xtensa/xtfpga.c:        env->regs[2] = tagptr;
hw/xtensa/xtfpga.c:        if (entry_point != env->pc) {
hw/xtensa/xtfpga.c:            env->regs[0] = entry_point;
hw/xtensa/xtfpga.c:            cpu_physical_memory_write(env->pc, jx_a0, sizeof(jx_a0));
hw/intc/xics.c:        ss->output = env->irq_inputs[POWER7_INPUT_INT];
hw/intc/xics.c:        ss->output = env->irq_inputs[PPC970_INPUT_INT];
hw/lm32/milkymist.c:    env->pc = reset_info->bootstrap_pc;
hw/lm32/milkymist.c:    env->regs[R_R1] = reset_info->cmdline_base;
hw/lm32/milkymist.c:    env->regs[R_R2] = reset_info->initrd_base;
hw/lm32/milkymist.c:    env->regs[R_R3] = reset_info->initrd_base + reset_info->initrd_size;
hw/lm32/milkymist.c:    env->eba = reset_info->flash_base;
hw/lm32/milkymist.c:    env->deba = reset_info->flash_base;
hw/lm32/milkymist.c:    env->pic_state = lm32_pic_init(*cpu_irq);
hw/lm32/milkymist.c:        irq[i] = qdev_get_gpio_in(env->pic_state, i);
hw/lm32/milkymist.c:    env->juart_state = lm32_juart_init();
hw/lm32/lm32_boards.c:    env->pc = (uint32_t)reset_info->bootstrap_pc;
hw/lm32/lm32_boards.c:    env->regs[R_R1] = (uint32_t)reset_info->hwsetup_base;
hw/lm32/lm32_boards.c:    env->regs[R_R2] = (uint32_t)reset_info->cmdline_base;
hw/lm32/lm32_boards.c:    env->regs[R_R3] = (uint32_t)reset_info->initrd_base;
hw/lm32/lm32_boards.c:    env->regs[R_R4] = (uint32_t)(reset_info->initrd_base +
hw/lm32/lm32_boards.c:    env->eba = reset_info->flash_base;
hw/lm32/lm32_boards.c:    env->deba = reset_info->flash_base;
hw/lm32/lm32_boards.c:    env->pic_state = lm32_pic_init(*cpu_irq);
hw/lm32/lm32_boards.c:        irq[i] = qdev_get_gpio_in(env->pic_state, i);
hw/lm32/lm32_boards.c:    env->juart_state = lm32_juart_init();
hw/lm32/lm32_boards.c:    env->pic_state = lm32_pic_init(*cpu_irq);
hw/lm32/lm32_boards.c:        irq[i] = qdev_get_gpio_in(env->pic_state, i);
hw/lm32/lm32_boards.c:    env->juart_state = lm32_juart_init();
hw/sparc64/sun4u.c:    uint32_t pil = env->pil_in |
hw/sparc64/sun4u.c:                  (env->softint & ~(SOFTINT_TIMER | SOFTINT_STIMER));
hw/sparc64/sun4u.c:    if (env->ivec_status & 0x20) {
hw/sparc64/sun4u.c:    if (env->softint & (SOFTINT_TIMER | SOFTINT_STIMER)) {
hw/sparc64/sun4u.c:    if (pil < (2 << env->psrpil)){
hw/sparc64/sun4u.c:                           env->interrupt_index);
hw/sparc64/sun4u.c:            env->interrupt_index = 0;
hw/sparc64/sun4u.c:        for (i = 15; i > env->psrpil; i--) {
hw/sparc64/sun4u.c:                int old_interrupt = env->interrupt_index;
hw/sparc64/sun4u.c:                if (unlikely(env->tl > 0 && cpu_tsptr(env)->tt > new_interrupt
hw/sparc64/sun4u.c:                                   env->tl, cpu_tsptr(env)->tt, new_interrupt);
hw/sparc64/sun4u.c:                    env->interrupt_index = new_interrupt;
hw/sparc64/sun4u.c:                       pil, env->pil_in, env->softint, env->interrupt_index);
hw/sparc64/sun4u.c:        env->interrupt_index = 0;
hw/sparc64/sun4u.c:        if (!(env->ivec_status & 0x20)) {
hw/sparc64/sun4u.c:            env->interrupt_index = TT_IVEC;
hw/sparc64/sun4u.c:            env->ivec_status |= 0x20;
hw/sparc64/sun4u.c:            env->ivec_data[0] = (0x1f << 6) | irq;
hw/sparc64/sun4u.c:            env->ivec_data[1] = 0;
hw/sparc64/sun4u.c:            env->ivec_data[2] = 0;
hw/sparc64/sun4u.c:        if (env->ivec_status & 0x20) {
hw/sparc64/sun4u.c:            env->ivec_status &= ~0x20;
hw/sparc64/sun4u.c:    cpu_timer_reset(env->tick);
hw/sparc64/sun4u.c:    cpu_timer_reset(env->stick);
hw/sparc64/sun4u.c:    cpu_timer_reset(env->hstick);
hw/sparc64/sun4u.c:    env->gregs[1] = 0; // Memory start
hw/sparc64/sun4u.c:    env->gregs[2] = ram_size; // Memory size
hw/sparc64/sun4u.c:    env->gregs[3] = 0; // Machine description XXX
hw/sparc64/sun4u.c:        env->pc = s->prom_addr + 0x20ULL;
hw/sparc64/sun4u.c:        env->pc = s->prom_addr + 0x40ULL;
hw/sparc64/sun4u.c:    env->npc = env->pc + 4;
hw/sparc64/sun4u.c:    CPUTimer* timer = env->tick;
hw/sparc64/sun4u.c:    env->softint |= SOFTINT_TIMER;
hw/sparc64/sun4u.c:    CPUTimer* timer = env->stick;
hw/sparc64/sun4u.c:    env->softint |= SOFTINT_STIMER;
hw/sparc64/sun4u.c:    CPUTimer* timer = env->hstick;
hw/sparc64/sun4u.c:    env->softint |= SOFTINT_STIMER;
hw/sparc64/sun4u.c:    env->tick = cpu_timer_create("tick", cpu, tick_irq,
hw/sparc64/sun4u.c:    env->stick = cpu_timer_create("stick", cpu, stick_irq,
hw/sparc64/sun4u.c:    env->hstick = cpu_timer_create("hstick", cpu, hstick_irq,
hw/ppc/e500.c:                              env->dcache_line_size);
hw/ppc/e500.c:                              env->icache_line_size);
hw/ppc/e500.c:    struct boot_info *bi = env->load_info;
hw/ppc/e500.c:    env->tlb_dirty = true;
hw/ppc/e500.c:    struct boot_info *bi = env->load_info;
hw/ppc/e500.c:    env->gpr[1] = (16<<20) - 8;
hw/ppc/e500.c:    env->gpr[3] = bi->dt_base;
hw/ppc/e500.c:    env->gpr[4] = 0;
hw/ppc/e500.c:    env->gpr[5] = 0;
hw/ppc/e500.c:    env->gpr[6] = EPAPR_MAGIC;
hw/ppc/e500.c:    env->gpr[7] = mmubooke_initial_mapsize(env);
hw/ppc/e500.c:    env->gpr[8] = 0;
hw/ppc/e500.c:    env->gpr[9] = 0;
hw/ppc/e500.c:    env->nip = bi->entry;
hw/ppc/e500.c:        input = (qemu_irq *)env->irq_inputs;
hw/ppc/e500.c:        env->spr_cb[SPR_BOOKE_PIR].default_value = cs->cpu_index = i;
hw/ppc/e500.c:        env->mpic_iack = MPC8544_CCSRBAR_BASE +
hw/ppc/e500.c:            env->load_info = boot_info;
hw/ppc/e500.c:    boot_info = env->load_info;
hw/ppc/virtex_ml507.c:    ppcemb_tlb_t *tlb = &env->tlb.tlbe[0];
hw/ppc/virtex_ml507.c:    tlb = &env->tlb.tlbe[1];
hw/ppc/virtex_ml507.c:    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];
hw/ppc/virtex_ml507.c:    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];
hw/ppc/virtex_ml507.c:    struct boot_info *bi = env->load_info;
hw/ppc/virtex_ml507.c:    env->gpr[1] = (16<<20) - 8;
hw/ppc/virtex_ml507.c:    env->gpr[3] = bi->fdt;
hw/ppc/virtex_ml507.c:    env->nip = bi->bootstrap_pc;
hw/ppc/virtex_ml507.c:    env->gpr[6] = tswap32(EPAPR_MAGIC);
hw/ppc/virtex_ml507.c:    env->gpr[7] = bi->ima_size;
hw/ppc/virtex_ml507.c:    cpu_irq = (qemu_irq *) &env->irq_inputs[PPC40x_INPUT_INT];
hw/ppc/virtex_ml507.c:    env->load_info = &boot_info;
hw/ppc/ppc405_uc.c:    dbsr = env->spr[SPR_40x_DBSR];
hw/ppc/ppc405_uc.c:    env->spr[SPR_40x_DBSR] = dbsr;
hw/ppc/ppc405_uc.c:    dbsr = env->spr[SPR_40x_DBSR];
hw/ppc/ppc405_uc.c:    env->spr[SPR_40x_DBSR] = dbsr;
hw/ppc/ppc405_uc.c:        ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];
hw/ppc/ppc405_uc.c:        ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];
hw/ppc/ppc405_uc.c:        ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];
hw/ppc/ppc405_uc.c:        ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];
hw/ppc/mac_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];
hw/ppc/mac_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];
hw/ppc/mac_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_MCP];
hw/ppc/mac_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_HRESET];
hw/ppc/mac_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];
hw/ppc/mac_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];
hw/ppc/mac_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_MCP];
hw/ppc/mac_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_HRESET];
hw/ppc/mpc8544_guts.c:        value = env->spr[SPR_PVR];
hw/ppc/mpc8544_guts.c:        value = env->spr[SPR_E500_SVR];
hw/ppc/ppc.c:    unsigned int old_pending = env->pending_interrupts;
hw/ppc/ppc.c:        env->pending_interrupts |= 1 << n_IRQ;
hw/ppc/ppc.c:        env->pending_interrupts &= ~(1 << n_IRQ);
hw/ppc/ppc.c:        if (env->pending_interrupts == 0) {
hw/ppc/ppc.c:    if (old_pending != env->pending_interrupts) {
hw/ppc/ppc.c:                env->pending_interrupts, CPU(cpu)->interrupt_request);
hw/ppc/ppc.c:    cur_level = (env->irq_input_state >> pin) & 1;
hw/ppc/ppc.c:            env->irq_input_state |= 1 << pin;
hw/ppc/ppc.c:            env->irq_input_state &= ~(1 << pin);
hw/ppc/ppc.c:    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc6xx_set_irq, cpu,
hw/ppc/ppc.c:    cur_level = (env->irq_input_state >> pin) & 1;
hw/ppc/ppc.c:            env->irq_input_state |= 1 << pin;
hw/ppc/ppc.c:            env->irq_input_state &= ~(1 << pin);
hw/ppc/ppc.c:    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, cpu,
hw/ppc/ppc.c:        env->irq_input_state |= 1 << pin;
hw/ppc/ppc.c:        env->irq_input_state &= ~(1 << pin);
hw/ppc/ppc.c:    env->irq_inputs = (void **)qemu_allocate_irqs(&power7_set_irq, cpu,
hw/ppc/ppc.c:    cur_level = (env->irq_input_state >> pin) & 1;
hw/ppc/ppc.c:            env->irq_input_state |= 1 << pin;
hw/ppc/ppc.c:            env->irq_input_state &= ~(1 << pin);
hw/ppc/ppc.c:    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc40x_set_irq,
hw/ppc/ppc.c:    cur_level = (env->irq_input_state >> pin) & 1;
hw/ppc/ppc.c:            env->irq_input_state |= 1 << pin;
hw/ppc/ppc.c:            env->irq_input_state &= ~(1 << pin);
hw/ppc/ppc.c:    env->irq_inputs = (void **)qemu_allocate_irqs(&ppce500_set_irq,
hw/ppc/ppc.c:    return muldiv64(vmclk, tb_env->tb_freq, get_ticks_per_sec()) + tb_offset;
hw/ppc/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc.c:        return env->spr[SPR_TBL];
hw/ppc/ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL), tb_env->tb_offset);
hw/ppc/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL), tb_env->tb_offset);
hw/ppc/ppc.c:        return env->spr[SPR_TBU];
hw/ppc/ppc.c:    *tb_offsetp = value - muldiv64(vmclk, tb_env->tb_freq, get_ticks_per_sec());
hw/ppc/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL), tb_env->tb_offset);
hw/ppc/ppc.c:                     &tb_env->tb_offset, tb | (uint64_t)value);
hw/ppc/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL), tb_env->tb_offset);
hw/ppc/ppc.c:                     &tb_env->tb_offset, ((uint64_t)value << 32) | tb);
hw/ppc/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL), tb_env->atb_offset);
hw/ppc/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL), tb_env->atb_offset);
hw/ppc/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL), tb_env->atb_offset);
hw/ppc/ppc.c:                     &tb_env->atb_offset, tb | (uint64_t)value);
hw/ppc/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL), tb_env->atb_offset);
hw/ppc/ppc.c:                     &tb_env->atb_offset, ((uint64_t)value << 32) | tb);
hw/ppc/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc.c:    if (tb_env->tb_freq != 0) {
hw/ppc/ppc.c:        tb = cpu_ppc_get_tb(tb_env, vmclk, tb_env->tb_offset);
hw/ppc/ppc.c:        atb = cpu_ppc_get_tb(tb_env, vmclk, tb_env->atb_offset);
hw/ppc/ppc.c:        cpu_ppc_store_tb(tb_env, vmclk, &tb_env->tb_offset, tb);
hw/ppc/ppc.c:        cpu_ppc_store_tb(tb_env, vmclk, &tb_env->atb_offset, atb);
hw/ppc/ppc.c:        tb_env->tb_freq = 0;
hw/ppc/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc.c:    if (tb_env->tb_freq == 0) {
hw/ppc/ppc.c:        tb = tb_env->tb_offset;
hw/ppc/ppc.c:        atb = tb_env->atb_offset;
hw/ppc/ppc.c:        tb_env->tb_freq = tb_env->decr_freq;
hw/ppc/ppc.c:        cpu_ppc_store_tb(tb_env, vmclk, &tb_env->tb_offset, tb);
hw/ppc/ppc.c:        cpu_ppc_store_tb(tb_env, vmclk, &tb_env->atb_offset, atb);
hw/ppc/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc.c:    return ((tb_env->flags & flags) == PPC_DECR_UNDERFLOW_TRIGGERED);
hw/ppc/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc.c:        decr = muldiv64(diff, tb_env->decr_freq, get_ticks_per_sec());
hw/ppc/ppc.c:    } else if (tb_env->flags & PPC_TIMER_BOOKE) {
hw/ppc/ppc.c:        decr = -muldiv64(-diff, tb_env->decr_freq, get_ticks_per_sec());
hw/ppc/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc.c:        return env->spr[SPR_DECR];
hw/ppc/ppc.c:    return _cpu_ppc_load_decr(env, tb_env->decr_next);
hw/ppc/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc.c:    return _cpu_ppc_load_decr(env, tb_env->hdecr_next);
hw/ppc/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc.c:    diff = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) - tb_env->purr_start;
hw/ppc/ppc.c:    return tb_env->purr_load + muldiv64(diff, tb_env->tb_freq, get_ticks_per_sec());
hw/ppc/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc.c:        ((tb_env->flags & PPC_DECR_UNDERFLOW_LEVEL) && (value & 0x80000000)) ||
hw/ppc/ppc.c:        ((tb_env->flags & PPC_DECR_UNDERFLOW_TRIGGERED) && (value & 0x80000000)
hw/ppc/ppc.c:    if (!(value & 0x80000000) && (tb_env->flags & PPC_DECR_UNDERFLOW_LEVEL)) {
hw/ppc/ppc.c:    next = now + muldiv64(value, get_ticks_per_sec(), tb_env->decr_freq);
hw/ppc/ppc.c:    __cpu_ppc_store_decr(cpu, &tb_env->decr_next, tb_env->decr_timer,
hw/ppc/ppc.c:                         tb_env->decr_timer->cb, &cpu_ppc_decr_lower, decr,
hw/ppc/ppc.c:    if (tb_env->hdecr_timer != NULL) {
hw/ppc/ppc.c:        __cpu_ppc_store_decr(cpu, &tb_env->hdecr_next, tb_env->hdecr_timer,
hw/ppc/ppc.c:                             tb_env->hdecr_timer->cb, &cpu_ppc_hdecr_lower,
hw/ppc/ppc.c:    tb_env->purr_load = value;
hw/ppc/ppc.c:    tb_env->purr_start = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);
hw/ppc/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc.c:    tb_env->tb_freq = freq;
hw/ppc/ppc.c:    tb_env->decr_freq = freq;
hw/ppc/ppc.c:    tb->guest_timebase = ticks + first_ppc_cpu->env.tb_env->tb_offset;
hw/ppc/ppc.c:    freq = first_ppc_cpu->env.tb_env->tb_freq;
hw/ppc/ppc.c:    tb_off = first_ppc_cpu->env.tb_env->tb_offset;
hw/ppc/ppc.c:        pcpu->env.tb_env->tb_offset = tb_off_adj;
hw/ppc/ppc.c:    env->tb_env = tb_env;
hw/ppc/ppc.c:    tb_env->flags = PPC_DECR_UNDERFLOW_TRIGGERED;
hw/ppc/ppc.c:    if (env->insns_flags & PPC_SEGMENT_64B) {
hw/ppc/ppc.c:        tb_env->flags |= PPC_DECR_UNDERFLOW_LEVEL;
hw/ppc/ppc.c:    tb_env->decr_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, &cpu_ppc_decr_cb, cpu);
hw/ppc/ppc.c:        tb_env->hdecr_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, &cpu_ppc_hdecr_cb,
hw/ppc/ppc.c:        tb_env->hdecr_timer = NULL;
hw/ppc/ppc.c:    tb_env = env->tb_env;
hw/ppc/ppc.c:    ppc40x_timer = tb_env->opaque;
hw/ppc/ppc.c:    switch ((env->spr[SPR_40x_TCR] >> 24) & 0x3) {
hw/ppc/ppc.c:    next = now + muldiv64(next, get_ticks_per_sec(), tb_env->tb_freq);
hw/ppc/ppc.c:    env->spr[SPR_40x_TSR] |= 1 << 26;
hw/ppc/ppc.c:    if ((env->spr[SPR_40x_TCR] >> 23) & 0x1) {
hw/ppc/ppc.c:           (int)((env->spr[SPR_40x_TCR] >> 23) & 0x1),
hw/ppc/ppc.c:           env->spr[SPR_40x_TCR], env->spr[SPR_40x_TSR]);
hw/ppc/ppc.c:    ppc40x_timer = tb_env->opaque;
hw/ppc/ppc.c:        !((env->spr[SPR_40x_TCR] >> 26) & 0x1) ||
hw/ppc/ppc.c:        (is_excp && !((env->spr[SPR_40x_TCR] >> 22) & 0x1))) {
hw/ppc/ppc.c:        timer_del(tb_env->decr_timer);
hw/ppc/ppc.c:                              get_ticks_per_sec(), tb_env->decr_freq);
hw/ppc/ppc.c:            next += tb_env->decr_next - now;
hw/ppc/ppc.c:        timer_mod(tb_env->decr_timer, next);
hw/ppc/ppc.c:        tb_env->decr_next = next;
hw/ppc/ppc.c:    tb_env = env->tb_env;
hw/ppc/ppc.c:    ppc40x_timer = tb_env->opaque;
hw/ppc/ppc.c:    env->spr[SPR_40x_TSR] |= 1 << 27;
hw/ppc/ppc.c:    if ((env->spr[SPR_40x_TCR] >> 26) & 0x1) {
hw/ppc/ppc.c:           (int)((env->spr[SPR_40x_TCR] >> 22) & 0x1),
hw/ppc/ppc.c:           (int)((env->spr[SPR_40x_TCR] >> 26) & 0x1),
hw/ppc/ppc.c:           env->spr[SPR_40x_TCR], env->spr[SPR_40x_TSR],
hw/ppc/ppc.c:    tb_env = env->tb_env;
hw/ppc/ppc.c:    ppc40x_timer = tb_env->opaque;
hw/ppc/ppc.c:    switch ((env->spr[SPR_40x_TCR] >> 30) & 0x3) {
hw/ppc/ppc.c:    next = now + muldiv64(next, get_ticks_per_sec(), tb_env->decr_freq);
hw/ppc/ppc.c:           env->spr[SPR_40x_TCR], env->spr[SPR_40x_TSR]);
hw/ppc/ppc.c:    switch ((env->spr[SPR_40x_TSR] >> 30) & 0x3) {
hw/ppc/ppc.c:        env->spr[SPR_40x_TSR] |= 1U << 31;
hw/ppc/ppc.c:        env->spr[SPR_40x_TSR] |= 1 << 30;
hw/ppc/ppc.c:        if ((env->spr[SPR_40x_TCR] >> 27) & 0x1) {
hw/ppc/ppc.c:        env->spr[SPR_40x_TSR] &= ~0x30000000;
hw/ppc/ppc.c:        env->spr[SPR_40x_TSR] |= env->spr[SPR_40x_TCR] & 0x30000000;
hw/ppc/ppc.c:        switch ((env->spr[SPR_40x_TCR] >> 28) & 0x3) {
hw/ppc/ppc.c:    tb_env = env->tb_env;
hw/ppc/ppc.c:    ppc40x_timer = tb_env->opaque;
hw/ppc/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc.c:    tb_env->tb_freq = freq;
hw/ppc/ppc.c:    tb_env->decr_freq = freq;
hw/ppc/ppc.c:    env->tb_env = tb_env;
hw/ppc/ppc.c:    tb_env->flags = PPC_DECR_UNDERFLOW_TRIGGERED;
hw/ppc/ppc.c:    tb_env->tb_freq = freq;
hw/ppc/ppc.c:    tb_env->decr_freq = freq;
hw/ppc/ppc.c:    tb_env->opaque = ppc40x_timer;
hw/ppc/ppc.c:        tb_env->decr_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, &cpu_4xx_pit_cb, env);
hw/ppc/ppc.c:    dcr = &dcr_env->dcrn[dcrn];
hw/ppc/ppc.c:    if (dcr_env->read_error != NULL)
hw/ppc/ppc.c:        return (*dcr_env->read_error)(dcrn);
hw/ppc/ppc.c:    dcr = &dcr_env->dcrn[dcrn];
hw/ppc/ppc.c:    if (dcr_env->write_error != NULL)
hw/ppc/ppc.c:        return (*dcr_env->write_error)(dcrn);
hw/ppc/ppc.c:    dcr_env = env->dcr_env;
hw/ppc/ppc.c:    dcr = &dcr_env->dcrn[dcrn];
hw/ppc/ppc.c:    dcr_env->read_error = read_error;
hw/ppc/ppc.c:    dcr_env->write_error = write_error;
hw/ppc/ppc.c:    env->dcr_env = dcr_env;
hw/ppc/ppce500_spin.c:    env->tlb_dirty = true;
hw/ppc/ppce500_spin.c:    stl_p(&curspin->pir, env->spr[SPR_PIR]);
hw/ppc/ppce500_spin.c:    env->nip = ldq_p(&curspin->addr) & (map_size - 1);
hw/ppc/ppce500_spin.c:    env->gpr[3] = ldq_p(&curspin->r3);
hw/ppc/ppce500_spin.c:    env->gpr[4] = 0;
hw/ppc/ppce500_spin.c:    env->gpr[5] = 0;
hw/ppc/ppce500_spin.c:    env->gpr[6] = 0;
hw/ppc/ppce500_spin.c:    env->gpr[7] = map_size;
hw/ppc/ppce500_spin.c:    env->gpr[8] = 0;
hw/ppc/ppce500_spin.c:    env->gpr[9] = 0;
hw/ppc/ppc_booke.c:                (env->spr[SPR_BOOKE_TSR] & TSR_DIS
hw/ppc/ppc_booke.c:                 && env->spr[SPR_BOOKE_TCR] & TCR_DIE));
hw/ppc/ppc_booke.c:                (env->spr[SPR_BOOKE_TSR] & TSR_WIS
hw/ppc/ppc_booke.c:                 && env->spr[SPR_BOOKE_TCR] & TCR_WIE));
hw/ppc/ppc_booke.c:                (env->spr[SPR_BOOKE_TSR] & TSR_FIS
hw/ppc/ppc_booke.c:                 && env->spr[SPR_BOOKE_TCR] & TCR_FIE));
hw/ppc/ppc_booke.c:    uint8_t fp = (env->spr[SPR_BOOKE_TCR] & TCR_FP_MASK) >> TCR_FP_SHIFT;
hw/ppc/ppc_booke.c:    if (tb_env->flags & PPC_TIMER_E500) {
hw/ppc/ppc_booke.c:        uint32_t fpext = (env->spr[SPR_BOOKE_TCR] & TCR_E500_FPEXT_MASK)
hw/ppc/ppc_booke.c:        fp = env->fit_period[fp];
hw/ppc/ppc_booke.c:    uint8_t wp = (env->spr[SPR_BOOKE_TCR] & TCR_WP_MASK) >> TCR_WP_SHIFT;
hw/ppc/ppc_booke.c:    if (tb_env->flags & PPC_TIMER_E500) {
hw/ppc/ppc_booke.c:        uint32_t wpext = (env->spr[SPR_BOOKE_TCR] & TCR_E500_WPEXT_MASK)
hw/ppc/ppc_booke.c:        wp = env->wdt_period[wp];
hw/ppc/ppc_booke.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc_booke.c:    if (!(env->spr[SPR_BOOKE_TSR] & tsr_bit)) {
hw/ppc/ppc_booke.c:    tb  = cpu_ppc_get_tb(tb_env, now, tb_env->tb_offset);
hw/ppc/ppc_booke.c:    *next = now + muldiv64(ticks, get_ticks_per_sec(), tb_env->tb_freq);
hw/ppc/ppc_booke.c:    env->spr[SPR_BOOKE_TSR] |= TSR_DIS;
hw/ppc/ppc_booke.c:    if (env->spr[SPR_BOOKE_TCR] & TCR_ARE) {
hw/ppc/ppc_booke.c:        cpu_ppc_store_decr(env, env->spr[SPR_BOOKE_DECAR]);
hw/ppc/ppc_booke.c:    tb_env = env->tb_env;
hw/ppc/ppc_booke.c:    booke_timer = tb_env->opaque;
hw/ppc/ppc_booke.c:    env->spr[SPR_BOOKE_TSR] |= TSR_FIS;
hw/ppc/ppc_booke.c:    tb_env = env->tb_env;
hw/ppc/ppc_booke.c:    booke_timer = tb_env->opaque;
hw/ppc/ppc_booke.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc_booke.c:    booke_timer_t *booke_timer = tb_env->opaque;
hw/ppc/ppc_booke.c:    env->spr[SPR_BOOKE_TSR] &= ~val;
hw/ppc/ppc_booke.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc/ppc_booke.c:    booke_timer_t *booke_timer = tb_env->opaque;
hw/ppc/ppc_booke.c:    tb_env = env->tb_env;
hw/ppc/ppc_booke.c:    env->spr[SPR_BOOKE_TCR] = val;
hw/ppc/ppc_booke.c:    tb_env->flags = flags | PPC_TIMER_BOOKE | PPC_DECR_ZERO_TRIGGERED;
hw/ppc/ppc_booke.c:    tb_env->tb_freq    = freq;
hw/ppc/ppc_booke.c:    tb_env->decr_freq  = freq;
hw/ppc/ppc_booke.c:    tb_env->opaque     = booke_timer;
hw/ppc/ppc_booke.c:    tb_env->decr_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, &booke_decr_cb, cpu);
hw/ppc/prep.c:        if (env->flags & POWERPC_FLAG_RTC_CLK) {
hw/ppc/spapr.c:        struct ppc_one_seg_page_size *sps = &env->sps.sps[i];
hw/ppc/spapr.c:        _FDT((fdt_property_cell(fdt, "cpu-version", env->spr[SPR_PVR])));
hw/ppc/spapr.c:                                env->dcache_line_size)));
hw/ppc/spapr.c:                                env->dcache_line_size)));
hw/ppc/spapr.c:                                env->icache_line_size)));
hw/ppc/spapr.c:                                env->icache_line_size)));
hw/ppc/spapr.c:        _FDT((fdt_property_cell(fdt, "ibm,slb-size", env->slb_nr)));
hw/ppc/spapr.c:        if (env->spr_cb[SPR_PURR].oea_read) {
hw/ppc/spapr.c:        if (env->mmu_model & POWERPC_MMU_1TSEG) {
hw/ppc/spapr.c:        if (env->insns_flags & PPC_ALTIVEC) {
hw/ppc/spapr.c:            uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;
hw/ppc/spapr.c:        if (env->insns_flags2 & PPC2_DFP) {
hw/ppc/spapr.c:        env->gpr[3] = H_PRIVILEGE;
hw/ppc/spapr.c:        env->gpr[3] = spapr_hypercall(cpu, env->gpr[3], &env->gpr[4]);
hw/ppc/spapr.c:    env->spr[SPR_HIOR] = 0;
hw/ppc/spapr.c:    env->external_htab = (uint8_t *)spapr->htab;
hw/ppc/spapr.c:    if (kvm_enabled() && !env->external_htab) {
hw/ppc/spapr.c:        env->external_htab = (void *)1;
hw/ppc/spapr.c:    env->htab_base = -1;
hw/ppc/spapr.c:    env->htab_mask = (1ULL << ((spapr)->htab_shift - 7)) - 1;
hw/ppc/spapr.c:    env->spr[SPR_SDR1] = (target_ulong)(uintptr_t)spapr->htab |
hw/ppc/spapr.c:        env->msr_mask &= ~(1 << 6);
hw/ppc/spapr_hcall.c:    env->spr[s->spr] &= ~s->mask;
hw/ppc/spapr_hcall.c:    env->spr[s->spr] |= s->value;
hw/ppc/spapr_hcall.c:    if (((pte_index & ~7ULL) / HPTES_PER_GROUP) & ~env->htab_mask) {
hw/ppc/spapr_hcall.c:    hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64);
hw/ppc/spapr_hcall.c:    if (vpa % env->dcache_line_size) {
hw/ppc/spapr_hcall.c:    env->vpa_addr = vpa;
hw/ppc/spapr_hcall.c:    tmp = ldub_phys(cs->as, env->vpa_addr + VPA_SHARED_PROC_OFFSET);
hw/ppc/spapr_hcall.c:    stb_phys(cs->as, env->vpa_addr + VPA_SHARED_PROC_OFFSET, tmp);
hw/ppc/spapr_hcall.c:    if (env->slb_shadow_addr) {
hw/ppc/spapr_hcall.c:    if (env->dtl_addr) {
hw/ppc/spapr_hcall.c:    env->vpa_addr = 0;
hw/ppc/spapr_hcall.c:    if (!env->vpa_addr) {
hw/ppc/spapr_hcall.c:    env->slb_shadow_addr = addr;
hw/ppc/spapr_hcall.c:    env->slb_shadow_size = size;
hw/ppc/spapr_hcall.c:    env->slb_shadow_addr = 0;
hw/ppc/spapr_hcall.c:    env->slb_shadow_size = 0;
hw/ppc/spapr_hcall.c:    if (!env->vpa_addr) {
hw/ppc/spapr_hcall.c:    env->dtl_addr = addr;
hw/ppc/spapr_hcall.c:    env->dtl_size = size;
hw/ppc/spapr_hcall.c:    env->dtl_addr = 0;
hw/ppc/spapr_hcall.c:    env->dtl_size = 0;
hw/ppc/spapr_hcall.c:    env->msr |= (1ULL << MSR_EE);
hw/ppc/spapr_hcall.c:        env->excp_prefix = prefix;
hw/ppc/mac_oldworld.c:                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];
hw/ppc/ppc440_bamboo.c:    ppcemb_tlb_t *tlb = &env->tlb.tlbe[0];
hw/ppc/ppc440_bamboo.c:    tlb = &env->tlb.tlbe[1];
hw/ppc/ppc440_bamboo.c:    env->gpr[1] = (16<<20) - 8;
hw/ppc/ppc440_bamboo.c:    env->gpr[3] = FDT_ADDR;
hw/ppc/ppc440_bamboo.c:    env->nip = entry;
hw/ppc/ppc440_bamboo.c:    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];
hw/ppc/ppc440_bamboo.c:    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];
hw/ppc/ppc405_boards.c:        env->gpr[3] = bdloc;
hw/ppc/ppc405_boards.c:        env->gpr[4] = initrd_base;
hw/ppc/ppc405_boards.c:        env->gpr[5] = initrd_size;
hw/ppc/ppc405_boards.c:            env->gpr[6] = bdloc;
hw/ppc/ppc405_boards.c:            env->gpr[7] = bdloc + len;
hw/ppc/ppc405_boards.c:            env->gpr[6] = 0;
hw/ppc/ppc405_boards.c:            env->gpr[7] = 0;
hw/ppc/ppc405_boards.c:        env->nip = KERNEL_LOAD_ADDR;
hw/ppc/spapr_rtas.c:        env->msr = (1ULL << MSR_SF) | (1ULL << MSR_ME);
hw/ppc/spapr_rtas.c:        env->nip = start;
hw/ppc/spapr_rtas.c:        env->gpr[3] = r3;
hw/ppc/spapr_rtas.c:    env->msr = 0;
hw/sh4/r2d.c:    env->pc = s->vector;
hw/sh4/r2d.c:    reset_info->vector = env->pc;
hw/cris/boot.c:    li = env->load_info;
hw/cris/boot.c:    env->pc = li->entry;
hw/cris/boot.c:        env->regs[8] = 0x56902387; /* RAM boot magic.  */
hw/cris/boot.c:        env->regs[9] = 0x40004000 + li->image_size;
hw/cris/boot.c:        env->regs[10] = 0x87109563;
hw/cris/boot.c:        env->regs[11] = 0x40000000;
hw/cris/boot.c:    env->load_info = li;
hw/cris/axis_dev88.c:    qdev_prop_set_ptr(dev, "interrupt_vector", &env->interrupt_vector);
hw/sparc/sun4m.c:    if (env->pil_in && (env->interrupt_index == 0 ||
hw/sparc/sun4m.c:                        (env->interrupt_index & ~15) == TT_EXTINT)) {
hw/sparc/sun4m.c:            if (env->pil_in & (1 << i)) {
hw/sparc/sun4m.c:                int old_interrupt = env->interrupt_index;
hw/sparc/sun4m.c:                env->interrupt_index = TT_EXTINT | i;
hw/sparc/sun4m.c:                if (old_interrupt != env->interrupt_index) {
hw/sparc/sun4m.c:    } else if (!env->pil_in && (env->interrupt_index & ~15) == TT_EXTINT) {
hw/sparc/sun4m.c:        trace_sun4m_cpu_reset_interrupt(env->interrupt_index & 15);
hw/sparc/sun4m.c:        env->interrupt_index = 0;
hw/sparc/sun4m.c:        env->pil_in |= 1 << irq;
hw/sparc/sun4m.c:        env->pil_in &= ~(1 << irq);
hw/sparc/sun4m.c:    env->prom_addr = prom_addr;
hw/sparc/leon3.c:    env->pc     = s->entry;
hw/sparc/leon3.c:    env->npc    = s->entry + 4;
hw/sparc/leon3.c:    env->regbase[6] = s->sp;
hw/sparc/leon3.c:    env->pil_in = pil_in;
hw/sparc/leon3.c:    if (env->pil_in && (env->interrupt_index == 0 ||
hw/sparc/leon3.c:                        (env->interrupt_index & ~15) == TT_EXTINT)) {
hw/sparc/leon3.c:            if (env->pil_in & (1 << i)) {
hw/sparc/leon3.c:                int old_interrupt = env->interrupt_index;
hw/sparc/leon3.c:                env->interrupt_index = TT_EXTINT | i;
hw/sparc/leon3.c:                if (old_interrupt != env->interrupt_index) {
hw/sparc/leon3.c:    } else if (!env->pil_in && (env->interrupt_index & ~15) == TT_EXTINT) {
hw/sparc/leon3.c:        trace_leon3_reset_irq(env->interrupt_index & 15);
hw/sparc/leon3.c:        env->interrupt_index = 0;
hw/sparc/leon3.c:    env->qemu_irq_ack = leon3_irq_manager;
hw/sparc/leon3.c:            env->pc = entry;
hw/sparc/leon3.c:            env->npc = entry + 4;
hw/arm/boot.c:    env->regs[15] = info->smp_loader_start;
hw/arm/boot.c:    const struct arm_boot_info *info = env->boot_info;
hw/arm/boot.c:            env->regs[15] = info->entry & 0xfffffffe;
hw/arm/boot.c:            env->thumb = info->entry & 1;
hw/arm/boot.c:                if (env->aarch64) {
hw/arm/boot.c:                    env->pc = info->loader_start;
hw/arm/boot.c:                    env->regs[15] = info->loader_start;
hw/arm/highbank.c:        env->regs[15] = SMP_BOOT_ADDR;
hw/arm/armv7m.c:    env->nvic = nvic;
hw/moxie/moxiesim.c:        serial_mm_init(address_space_mem, 0x3f8, 0, env->irq[4],
hw/m68k/dummy_m68k.c:    env->vbr = 0;
hw/m68k/dummy_m68k.c:    env->pc = entry;
hw/m68k/mcf5208.c:    env->vbr = 0;
hw/m68k/mcf5208.c:    env->pc = entry;
hw/m68k/an5206.c:    env->vbr = 0;
hw/m68k/an5206.c:    env->mbar = AN5206_MBAR_ADDR | 1;
hw/m68k/an5206.c:    env->rambar0 = AN5206_RAMBAR_ADDR | 1;
hw/m68k/an5206.c:    env->pc = entry;
hw/mips/mips_r4k.c:    env->active_tc.PC = s->vector;
hw/mips/mips_r4k.c:    reset_info->vector = env->active_tc.PC;
hw/mips/mips_r4k.c:    i8259 = i8259_init(isa_bus, env->irq[2]);
hw/mips/mips_jazz.c:    rc4030_opaque = rc4030_init(env->irq[6], env->irq[3], &rc4030, &dmas,
hw/mips/mips_jazz.c:    i8259 = i8259_init(isa_bus, env->irq[4]);
hw/mips/cputimer.c:        idx = lfsr % (env->tlb->nb_tlb - env->CP0_Wired) + env->CP0_Wired;
hw/mips/cputimer.c:    wait = env->CP0_Compare - env->CP0_Count -
hw/mips/cputimer.c:    timer_mod(env->timer, next);
hw/mips/cputimer.c:    if (env->insn_flags & ISA_MIPS32R2) {
hw/mips/cputimer.c:        env->CP0_Cause |= 1 << CP0Ca_TI;
hw/mips/cputimer.c:    qemu_irq_raise(env->irq[(env->CP0_IntCtl >> CP0IntCtl_IPTI) & 0x7]);
hw/mips/cputimer.c:    if (env->CP0_Cause & (1 << CP0Ca_DC)) {
hw/mips/cputimer.c:        return env->CP0_Count;
hw/mips/cputimer.c:        if (timer_pending(env->timer)
hw/mips/cputimer.c:            && timer_expired(env->timer, now)) {
hw/mips/cputimer.c:        return env->CP0_Count +
hw/mips/cputimer.c:     * So env->timer may be NULL, which is also the case with KVM enabled so
hw/mips/cputimer.c:    if (env->CP0_Cause & (1 << CP0Ca_DC) || !env->timer)
hw/mips/cputimer.c:        env->CP0_Count = count;
hw/mips/cputimer.c:        env->CP0_Count =
hw/mips/cputimer.c:    env->CP0_Compare = value;
hw/mips/cputimer.c:    if (!(env->CP0_Cause & (1 << CP0Ca_DC)))
hw/mips/cputimer.c:    if (env->insn_flags & ISA_MIPS32R2)
hw/mips/cputimer.c:        env->CP0_Cause &= ~(1 << CP0Ca_TI);
hw/mips/cputimer.c:    qemu_irq_lower(env->irq[(env->CP0_IntCtl >> CP0IntCtl_IPTI) & 0x7]);
hw/mips/cputimer.c:    cpu_mips_store_count(env, env->CP0_Count);
hw/mips/cputimer.c:    env->CP0_Count += (uint32_t)muldiv64(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL),
hw/mips/cputimer.c:    if (env->CP0_Cause & (1 << CP0Ca_DC))
hw/mips/cputimer.c:    env->CP0_Count++;
hw/mips/cputimer.c:    env->CP0_Count--;
hw/mips/cputimer.c:        env->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, &mips_timer_cb, env);
hw/mips/mips_int.c:        env->CP0_Cause |= 1 << (irq + CP0Ca_IP);
hw/mips/mips_int.c:        env->CP0_Cause &= ~(1 << (irq + CP0Ca_IP));
hw/mips/mips_int.c:    if (env->CP0_Cause & CP0Ca_IP_mask) {
hw/mips/mips_int.c:        env->irq[i] = qi[i];
hw/mips/mips_int.c:    qemu_set_irq(env->irq[irq], level);
hw/mips/mips_malta.c:    env->mvp->CP0_MVPConf0 |= ((smp_cpus - 1) << CP0MVPC0_PVPE) |
hw/mips/mips_malta.c:        env->CP0_Status &= ~((1 << CP0St_BEV) | (1 << CP0St_ERL));
hw/mips/mips_malta.c:        env->active_tc.PC = 0x40000000 + loaderparams.ram_size;
hw/mips/mips_malta.c:    malta_fpga_init(system_memory, FPGA_ADDRESS, env->irq[4], serial_hds[2]);
hw/mips/mips_malta.c:    s->i8259 = i8259_init(isa_bus, env->irq[2]);
hw/mips/mips_fulong2e.c:    stl_p(p++, 0x3c070000 | (loaderparams.ram_size >> 16));      /* lui a3, high(env->ram_size) */
hw/mips/mips_fulong2e.c:    stl_p(p++, 0x34e70000 | (loaderparams.ram_size & 0xffff));   /* ori a3, a3, low(env->ram_size) */
hw/mips/mips_fulong2e.c:        env->CP0_Status &= ~((1 << CP0St_BEV) | (1 << CP0St_ERL));
hw/mips/mips_fulong2e.c:    pci_bus = bonito_init((qemu_irq *)&(env->irq[2]));
hw/mips/mips_fulong2e.c:    i8259 = i8259_init(isa_bus, env->irq[5]);
hw/mips/mips_mipssim.c:    env->active_tc.PC = s->vector & ~(target_ulong)1;
hw/mips/mips_mipssim.c:        env->hflags |= MIPS_HFLAG_M16;
hw/mips/mips_mipssim.c:    reset_info->vector = env->active_tc.PC;
hw/mips/mips_mipssim.c:        env->active_tc.PC = (target_long)(int32_t)0xbfc00000;
hw/mips/mips_mipssim.c:        serial_init(0x3f8, env->irq[4], 115200, serial_hds[0],
hw/mips/mips_mipssim.c:        mipsnet_init(0x4200, env->irq[2], &nd_table[0]);
